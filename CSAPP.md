# 深入理解计算机系统

## 第一章

> ### 1.1 信息就是位+上下文
>
> * `hello.c`的所有信息全部由`ASCII`进行编码，包括换行符`\n`也是两个`ASCII`字符
> * 只由ASCII码组成的文件称为**文本文件**，其他所有文件都称为**二进制文件**。 hello.c就是一个文本文件
> * 系统中所有的信息都是`比特串`，区分不同数据对象的唯一方法是我们读到这些数据的上下文
>
> ### 1.2  程序被其他程序翻译成不同的格式
>
> * 预处理阶段
>   * `gcc -E main.c -o main.i`
>   * 预处理器将**#incloude <...>**中的内容直接作文本替换 
>   * 让main.c文本文件变成另一个文本文件**main.i**
>
> * 编译阶段
>
>   * `gcc -S main.c -o main.s`
>
>   * 使用这个指令能更方便查看：`gcc -fomit-frame-pointer -fverbose-asm -S main.c -o main.s`
>
>   * 编译器将main.i翻译成文本文件**main.s**
>
>   * main.s 本质上还是一个文本文件
>
>   * 只不过文本文件内的内容从高级语言变成了汇编语言
>
>     ```assembly
>     //打开main.s类似这样
>     subq    $16, %rsp
>     movl    %edi, -4(%rbp)
>     movl    %esi, -8(%rbp)
>     cmpl    $1, -4(%rbp)
>     jne L5
>     cmpl    $65535, -8(%rbp)
>     jne L5
>     leaq    __ZStL8__ioinit(%rip), %rdi
>     call    __ZNSt8ios_base4InitC1Ev
>     leaq    ___dso_handle(%rip), %rdx
>     leaq    __ZStL8__ioinit(%rip), %rsi
>     movq    __ZNSt8ios_base4InitD1Ev@GOTPCREL(%rip), %rax
>     movq    %rax, %rdi
>     call    ___cxa_atexit
>     ```
>
> * 汇编阶段
>
>   * `gcc -c main.c -o main.o`
>
>   * 汇编器将main.s翻译成机器语言指令，把这些指令打包成**relocatable object program**，把结果保存在**main.o**中
>
>   * main.o是一个二进制文件不是一个文本文件，用文本编辑器打开会乱码
>
>   * 但可以使用`objdump`将其转换成`汇编形式`，只不过还没有进行链接
>
>     ```assembly
>     //objdump -d main.o > main.s的结果
>     0: 55                            pushq   %rbp
>     1: 48 89 e5                      movq    %rsp, %rbp
>     4: 48 8d 35 00 00 00 00          leaq    (%rip), %rsi  # b <_main+0xb>
>     b: 48 8b 05 00 00 00 00          movq    (%rip), %rax  # 12 <_main+0x12>
>     12: 48 89 c7                      movq    %rax, %rdi
>     15: e8 00 00 00 00                callq   0x1a <_main+0x1a>
>     1a: 48 89 c2                      movq    %rax, %rdx
>     1d: 48 8b 05 00 00 00 00          movq    (%rip), %rax  # 24 <_main+0x24>
>     24: 48 89 c6                      movq    %rax, %rsi
>     27: 48 89 d7                      movq    %rdx, %rdi
>     2a: e8 00 00 00 00                callq   0x2f <_main+0x2f>
>     2f: b8 00 00 00 00                movl    $0, %eax
>     34: 5d                            popq    %rbp
>     35: c3                            retq
>     ```
>
> * 链接阶段
>   * main程序调用了**每个C编译器都提供的标准C库中print()函数**
>   * print() 函数存在于一个**print.o**的可重定位目标程序中
>   * 链接器要将**print.o和main.o**两个**可重定位目标程序**合并
>   * 最后得到一个**main.out或main**文件
>   * 这是一个可执行文件
>
> ### 1.4.1系统的硬件组成
>
> * 总线
>   * 在各个部件中传输**字**
>   * 字中的字节数(**字长**)是一个系统的重要参数
>   * 4字长就是32位，8字长就是64位
>
> * IO设备
>   * 是系统与外部连接的通道
>   * 每一个IO设备都通过一个控制器或者适配器与总线相连，适配器或者控制器的作用就是在总线和IO设备之间传递信息
>
> * 主存
>   * 一个线性的字节数组
>
> * CPU
>   * 寄存器的大小就是这个系统**字**的大小，也是**系统总线**传输数据单元的大小
>
> * 指令集架构和微体系架构
>   * 计算机`CPU`的工作模型十分简单，但现代处理器使用了十分复杂的结构来加速程序的运行
>   * `指令集架构`：描述的是每条机器代码执行的效果
>   * `微体系架构`：描述的是处理器实际上是如何实现的
>
> ### 1.4.2运行hello程序
>
> * 键盘的一次次字符输入，通过总线传输到寄存器，寄存器再把输入输到内存
> * 回车输入结束后`shell`程序在磁盘中找到目标程序文件，通过DMA将磁盘上的程序文件不经过处理器仅通过总线直接加载入内存
> * CPU执行程序的机器语言指令，将输出字符串从主存复制到寄存器文件，再从寄存器复制到输出设备
>
> ### 1.5高速缓存至关重要
>
> * 缓存原理——程序的局部性原理
>
> ### 1.7操作系统管理硬件
>
> * 所有应用程序对硬件的访问都必须通过**操作系统**
> * 操作系统防止硬件被失控的应用程序滥用
> * 操作系统向应用程序提供一些简单一致的**接口**来控制复杂而通常各不相同的低级硬件设备
>
> ### 1.7.1 进程
>
> * 进程概念
>   * 进程是对一个**正在运行的程序的一种抽象**
>   * 正是因为有了进程的抽象概念，每个程序才能感觉自己是在**独占**使用 CPU，主存和IO设备
>
> * 单处理器并行
>   * 并发运行指的是一个程序的指令和另一个程序的指令交错执行
>   * 然而实际上任何时刻CPU都只能执行一个程序的指令
>
> * 上下文
>   * 是操作系统保持跟踪进程运行所需的所有状态信息
>   * 比如`PC`和当前寄存器的值
>
> * `shell`进程和`hello`进程
>   * `shell`进程在接受到`./hello.out`请求时，执行一个`系统调用`，将控制权从`shell`程序切换到`操作系统内核`
>   * `操作系统内核`保存`shell`进程的上下文，创建一个新的进程`hello`，将控制权从`操作系统内核`转换到`hello`进程
>   * `hello`进程执行完成后，执行一个返回的`系统调用`，将控制权从`hello`进程切换到`操作系统内核`
>   * `hello`进程已经执行完毕，没有必要保留它的上下文。`操作系统内核`恢复`shell`进程的上下文，并将控制权从`操作系统内核`切换到`shell`进程
>
> * 操作系统内核
>   * 内核是操作系统代码常驻内存的部分
>   * 当涉及到**系统调用**时，将**控制权**转交给内核，内核操作完成后在归还控制权
>   * 内核不是一个独立的进程，内核是系统管理全部进程所有的代码和数据的集合
>
> ### 1.7.2 线程
>
> * 一个进程可以由多个**线程**执行单元组成
> * 有了多个线程，则进程有了多个控制流
> * 线程运行在进程的上下文中
> * 多线程比多进程更容易共享代码和数据，也因此效率更高
>
> ### 1.7.3虚拟内存
>
> * 虚拟内存为进程提供了一个假象 —— 每个进程都在独占地使用主存
> * 每个进程感知不到物理内存的存在，它只能感知到虚拟内存，称为**虚拟地址空间**
> * 每个进程看到的虚拟地址空间的结构是**一模一样**的
> * 虚拟地址空间顶层是**保存的操作系统代码数据**，是不能动的
> * 虚拟空间的底层是**用户进程定义的代码和数据的**
> * 虚拟地址空间结构(从低地址到高地址)
> * 虚拟地址空间
>   * 程序代码和数据
>     * 是直接根据`可执行文件`的内容进行初始化的
>     * 在程序一开始运行它的大小就已经被指定并不可变了
>     * 分为`只读代码和数据`与`读写数据`
>   * 堆——调用malloc或free标准库函数动态扩缩的部分
>   * 共享库——存放C标准库和数学库这种共享代码和数据(实际可能和其他程序映射到同一段物理内存上)
>   * 栈
>     * 位于用户虚拟地址空间的顶部，继续顶部就是操作系统内核代码了
>     * 编译器用栈来实现函数调用
>     * 栈的大小是可变的
>   * 内核虚拟内存——不允许读写，必须通过内核来执行
> * 基本思想：把一个进程的虚拟内存内容存放在磁盘上，然后用物理内存(主存)作为磁盘的高速缓存
>
>
> ### 1.7.4 文件
>
> * **文件就是字节序列**，仅此而已
> * 每个IO设备都是被抽象成文件，比如网卡
> * 系统中所有的输入输出都是通过`IO系统调用`读写文件来实现的
> * 文件最重要的作用是对所有IO都进行了一层抽象，屏蔽了所有的差异而提供了一些统一的接口
>
> ### 1.9.1 Amdahl定律
>
> * 要想提高整个系统的速度，必须提升全系统中相当大部分的速度
> * 就是说单纯提高一部分的速度好几倍，结果它在整个程序中的占比并不大，最后整个系统速度的提升微乎其微
>
> ### 1.9.2 并发和并行
>
> * 总述
>   * 并发(concurrency)指一个同时具有多个活动的系统
>   * 并行(parallelism)指的是通过并发来使一个系统运行得更快
> * 并发由来
>   * 因为有了进程这个抽象，我们能够设计有多个进程执行的系统，这就导致了并发
>   * 单核单线程的处理器实现并发是模拟的，任一时刻只有一个进程的指令在执行
> * 多处理器系统
>  * 一个单`操作系统内核`，多`处理器`的系统
> * 超线程
>   * 是一项允许一个处理器执行多个`控制流`的技术
>  * 这样的处理器有一些硬件是有多份的，比如`PC、寄存器`
>   * 但它有些硬件是只有一份的，如`浮点运算单元`
>   * 超线程处理器可以在`one clock`内决定执行那个线程，即它可以更高效地进行线程切换
>   * 举例：`A`线程正在等待网络回调，那么就没必要等它，处理器可以立刻去执行`B`线程
> * 多处理器优势
>   * 减少了模拟并发的需要，而它是真真正正的并发。真正的两个进程指令在同时执行
>   * 当程序以多线程的方式来运行时，且处理器支持超线程时。这是能够使进程运行得更快
> * 指令级并行
>   * 指同时执行多条指令的属性
>   * 通过流水线方式执行指令
>   * 当执行指令效率超过 1 instruction per clock 时称为超标量处理器
>
>
> * SIMD并行
>   * 一条指令产生多个可以并行执行的操作
>   * `SIMD`并行大多数是为了提高处理影像、声音的能力
>   * 使用编译器支持的`向量`数据类型来写程序，就会自动优化用到`SIMD`的能力
>  * 比如并行地对8对浮点数做加法
>
> ### 1.9.3抽象
>
> * 文件——IO
> * 虚拟内存——IO、主存
> * 进程——IO、主存、处理器
> * 指令集架构——处理器
> * 虚拟机——IO、主存、处理器、操作系统
>
> ******

## 第二章

> ### C版本
>
> * 和`C++`一样，`C`也有不同的版本
> * 如`gnu89、c89、c99、c11`
> * 可以和`C++`一样指定编译的版本，即`gcc -std=c11 main.c -o main.out`
>
> ### 2.1信息存储
>
> * 计算机一般是将`字节`作为最小可寻址的内存单位，而不是访问内存中单独`位`
> * 程序将内存视作一个非常大的字节数组，称为虚拟内存
> * 机器级程序根本是不会包含任何类型信息的，程序只是一个字节序列。所有类型都是高层的定义
>
> ### 2.1.2 字数据大小
>
> * **字长**决定了**指针**的大小，指针的大小决定了最大的寻址范围，因此**字长决定了虚拟地址空间的大小**
> * 32位最大内存是4GB，64位最大内存是16EB
> * 32位和64位程序
>   * `g++ -m64 main.cpp -o main.out`
>   * `g++ -m32 main.cpp -o main.out`
>   * 它们两者的源代码内容是相同的，只不过编译的方式不同
>   * 64位编译只能在64位机器上跑，32位编译就都可以跑
>
> * 为了避免依赖编译方式，**int32_t , int64_t**这种数据类型不随编译方式的不同而产生不同的结果
> * 程序的可移植性性
>   * 假如用`int`来存储指针，则在64位的机器上就跑不起来
>
>
> ### 2.1.3 寻址和字节顺序(大小端)
>
> * 含义：最**低/高**有效字节在最前面的方式称为**小/大**端法
> * 嘤忒尔使用小端法，即最低有效字节在最前面
> * 一般来说操作系统定下来字节顺序就固定下来了，安卓和iOS都使用小端法
> * 大小端影响
>   * 一般来说大小端对程序员来说是完全透明的，平时可以不用管
>   * `case1`：不同端的机器互相传输数据时
>   * `case2`：读汇编时
>     * 汇编指令如下：`4004d3: 01 05 43 0b 20 00    add %eax,0x200b43(%rip)`
>     * 其中`00`是低位，而`01`是高位
>     * 即最后4个倒过来就是`0x200b43`
>
>   * `case3`：当强制类型转换时
>
>
> ### 2.2 整数表示
>
> * Java只支持有符号数，不支持无符号数
> * **uint32_t**的实现原理是使用宏
> * 有符号和无符号的转换——**位不变，解释方法不同**
> * 有符号和无符号参与运算时，有符号数会向**无符号**转换
>
> ### 2.2.6数的扩展
>
> * 无符号整数使用**零扩展**
> * 符号整数使用**符号扩展**
> * 当同时涉及到**扩展和类型转换时**，先扩展再类型转换
>
> ### 2.2.7数的截断
>
> * 直接截断，然后按位根据数据类型解释
>
> ### 2.3 整数运算
>
> * 反码：正数的反码是本身，负数的反码是除了符号位外全部取反
> * 补码：正数的补码是本身，负数的补码是反码 + 1
> * 负数本身加上负数的补码的和是零，即它们在数学意义上的值互为相反数
> * 无符号加法： 舍弃高位，按无符号解释
> * 符号(补码)加法：舍弃高位，按符号补码解释
> * **补码的非： 就是求补码的相反数，最小值的非是它本身**
>
> ### 2.3.4整数乘法
>
> * 无符号乘法：直接乘，舍弃高位按无符号数解释
> * 补码乘法：首先解释成十进制，按十进制乘在转换为二进制，舍高位按照补码解释
> * **特点：无符号乘法和补码乘法最后舍弃后的位表示是一模一样的**
>
> ### 2.3.7 除以二的幂
>
> * **高位要进行符号扩展**
> * 不进行任何处理是**向下舍入**
> * 加上**偏置**后是**向零舍入**，偏置=(1<<k) - 1
>
> ### 2.4.2 IEEE浮点数表示
>
> * 单精度：1 + 8 + 23 
> * 双精度：1 + 11 + 52
> * **Bias值为 (1<<(k-1)-1**
>
> ***

## 第三章

> ### 引言
>
> * 汇编代码是**机器代码的文本表示形式**
> * 编译器基于语言规则、目标机器的指令集架构、操作系统的遵循的惯例，经过一系列阶段生成机器代码
> * GCC调用汇编器和链接器，根据**汇编代码**生成可执行的**机器代码**
> * 汇编代码与CPU指令集耦合，而与高级语言不耦合
> * 现在不要求程序员能够写汇编语言，但至少要能够看懂和理解汇编语言
>
> ### 3.2程序编码
>
> * 机器代码分为两种
>  * 目标代码：由汇编器生成，包含所有指令的二进制表示，但还没有填入全局值的地址
>   * 可执行代码：由链接器生成，是处理器执行的代码格式
>
>
> ### 3.2.1机器级编码
>
> * 两种抽象
>  * 指令集架构ISA抽象
>   * 虚拟内存抽象
>
>
> * 汇编代码就是机器代码可读性更好的文本表示
> * 汇编代码**不区分有符号，无符号，指针类型，甚至不区分整数和指针**
> * x-86的虚拟内存使用64位寻址，但目前**最高16位必须设置为0**，因此最大内存为64TB
> * 操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的**物理地址**
>
> ### 3.2.2代码示例
>
> *  生成汇编的指令
>
> ```bash
> gcc -Og -S test.c
> # -Og 使用level0，不进行优化，不然和源代码差距太大
> # -S 只生成汇编文件，不进行链接生成可执行机器代码
> ```
>
> * 机器执行的程序只是一个**字节序列**，它是对一系列指令的编码。机器对产生这些指令的源代码几乎**一无所知**
> * x-86的指令长度**不统一**，从1-15字节都有，**越常用指令越短**
> * x-86机器码类似于哈夫曼编码，是**连续编码可唯一翻译的**
> * 汇编来源
>   * `g++ -S main.cpp -o main.s`由编译器直接生成
>   * `objdump -d main.out > main.s`由反汇编生成
> * 汇编差异
>   * 由编译器产生的汇编代码**以 '.' 开头**都是指导汇编器和链接器工作的伪指令，对我们阅读来说没有实际作用
>   * 由汇编器生成的代码是没有经过链接的，因此它的`call`都不是真正的虚拟内存地址，而是一个占位符待填充
>   * 由`main.out`而不是`main.o`生成的反汇编代码是经过了链接的，`call`的都是真正的虚拟内存地址
>
>
> ### 3.2.3关于格式的注解
>
> * ATT与Intel汇编代码格式
>   * 两者格式不完全相同
>   * Intel版本代码更简略，省略**%, q, l**等
>   * **两者涉及多个操作数的情况下顺序是反的，很难顶**
>   * 在**英特尔和微软**的官方文档中常用 Intel 格式汇编代码
>   * `gcc`和`objdump`默认使用`ATT`格式
>
> ### C语言中嵌入汇编的两种方式
>
> * 编写完整函数，放入一个独立的汇编代码文件中，让汇编器和链接器把它和用C语言书写的代码合并起来
> * 使用gcc的内联汇编，在C中直接嵌入汇编代码
>
> ### 3.3数据格式
>
> * 由于历史原因，Intel的字大小指**16位2字节**
>
> * 后缀
>
>   ```bash
>   -b # 1字节，0.5字
>   -w # 2字节，一字
>   -l # 4字节，双字
>   -q # 8字节，四字
>   ```
>
> * 浮点数和整数使用的是**一组完全不同的指令和寄存器**
>
> * `b`和`w`会保持高位不动，但`l`会将高32位全部置零
>
> ### 3.4访问信息
>
> * 经过实际代码测试，x-86的指针大小为**64**位
>
> * 寄存器
>
>  ```bash
>  'r'代表64位，'e'代表32位，' '代表16位
>  -rax #返回值
>  -rbx #被调用者保存
>  -rcx #第四个参数
>  -rdx #第三个参数
>  -rsi #第二个参数
>  -rdi #第一个参数
>  -rbp #被调用者保存
>  -rsp #栈指针
>  ```
>
> ### 3.4.1 操作数指示符
>
> * 操作数类型
>   * 立即数
>   * 寄存器
>   * 内存引用
>
> * 操作数种类
>
>  ```bash
>  '$0x123FEDB'       #立即数
>  '0x123FEDB'        #内存地址为立即数值的位置的值
>  '%rsp'             #寄存器值
>  '(%rsp)'           #内存地址为寄存器值的位置的值
>  '0x4(%rsp,%rdi)'   #内存地址为 '4 + %rsp + %rdi' 的位置的值
>  '0x4(%rsp,%rdi,4)' #内存地址为 '4+%rsp+%rdi*4' 的位置的值
>  ```
>
> * 数据传送指令
>
>   ```assembly
>   movzbl 4(%rsp,%rsi,4),%rax # movzbl表示从8位移动到32位，且使用零扩展
>   cltq # 与'movslq %eax,%rax'相同
>   movl # 当只有一个b/w/l/q时是指源的位数是b/w/l/q，与目的地位数无关
>   ```
>
> * 压栈出栈指令
>
>   * 栈结构特点：栈底地址最高，栈顶地址最低，压栈会使%rsp减少
>   * `pushq %rbp` = `subq $8 %rsp; movq %rbp (%rsp);`
>   * `popq %rbp` = `movp (%rsp) %rbp; addq $8 %rsp;`
>
> * 算术指令
>
>   ```assembly
>   subq $0x8, %rsp # '%rsp = %rsp - 0x8'。后者为算术操作的第一个数
>   ```
>
> * 加载有效地址**lea**指令
>
>   * 经常用于`C`中的去地址运算符`&`
>
>   ```assembly
>   movq 7(%rdx,%rdx,4),%rax # 指将内存地址为 '5*%rdx+7' 的值赋值给%rax
>   leap 7(%rdx,%rdx,4),%rax # 指将 '5*%rdx+7' 这个结果赋值给 %rax
>   ```
>
> * 移位指令
>
>   * 逻辑移位：直接移啥都不管
>   * 算数移位：要考虑负数补码符号位
>
>   ```assembly
>   shr $0x4,%rdx # sh-shift, r-right 逻辑右移动
>   sar $0x4,%rdx # s-shift, a-arithmetic,r-right
>   ```
>
> * 乘法指令**128位**
>
>   ```assembly
>   imulq # 补码乘法
>   mulq  # 无符号数乘法
>    imulq %rdx # %rdx和%rax相乘，生成的128位结果高64位在%rdx，低64位在%rax
>   cqto  # 用于将%rdx设置成%rax的符号位，保证被除数符号统一
>   ```
>   
>    * **mulq**指令必须要求一个操作数位于**%rax**，和另一个操作数计算结果高位在`%rdx`，低位在`%rax`
>
>         * **divq**指令将%rdx和%rax作被除数，操作数作除数，商在`%rax`，余数在`%rdi`
>
> 
>### 3.6.1条件码
>
> * 条件码种类
>
>   ```bash
>  -CF # 进位标志。检测无符号数溢出 
>   -ZF # 零标志。最近操作的结果是0
>   -SF # 符号标志。最近操作结果的符号位
> 	-OF # 溢出标志。检测补码溢出
>   ```
> 
> * 特性
>
>   * lea 指令不改变任何条件码，其他操作都要改变条件码
>  * cmp 指令相当于 sub 指令，区别是 cmp 只设置条件码
>   * test 指令相当于 and 指令，区别是 test 只设置条件码
> 
> 
>* set 指令
>  * 操作对象是寄存器的低8位字节，将一个字节设置成0或1
>   * ture和false的确定来源于各个条件码的组合计算
> 
> 
>* 跳转指令
>
> 	* 无条件间接跳转：`jmp *%rsp` 或 `jmp *(%rsp)`
>  * 其他非**jmp**的跳转指令都是条件跳转，且条件跳转**只能是直接跳转**
>   * PC相对寻址的PC值是**跳转指令下一条指令的PC值**而不是跳转指令本身的PC值
>   * **rep**指令：插入在**ret**指令前面，防止直接跳转到ret	
>   * 对于布尔值运算，**je**代表是**false**
> 
> * 条件传送指令
>
>   * 特点：使用条件数据传送代码比条件控制转移代码效率更高，因为现代处理器是基于流水线的
>
>   * 格式：**cmov**
>
>   * 执行过程：处理器只读取数据，检查条件码，最后结果要么更新赋值要么保持不变。因此无论预测的结果如何都能保持流水线充满。等于是提前把所有分支结果都算出来
>
>   * 并不是所有的条件表达式都可以用条件传送来翻译
>
>   * 条件传送是否提高效率取决于用于额外计算浪费的时间和由于分支预测失误导致流水线爆炸浪费的时间谁更长
>
>   * 示例
>
>     ```assembly
>      movq   (%rdi), %rax
>     testq  %rdi, %rdi
>     movl   $0, %edx
>     cmove  %rdx, %rax
>     ret
>     ```
> 
> 
>### 优化的重要性
>
> * 源程序
>
>   ```c++
>  int add(int end){
>     int sum = 0;
>     for(int i = 0;i < end;i++){
>       sum += i;
>     }
>     return sum;
>   }
>   ```
> 
> * `g++ -O0 -c main.cpp -o main.o`的反编译
>
>   ```assembly
>  0000000000000000 <__Z3addi>:
>            0: 55                            pushq   %rbp
>            1: 48 89 e5                      movq    %rsp, %rbp
>            4: 89 7d ec                      movl    %edi, -20(%rbp)
>            7: c7 45 fc 00 00 00 00          movl    $0, -4(%rbp)
>            e: c7 45 f8 00 00 00 00          movl    $0, -8(%rbp)
>           15: 8b 45 f8                      movl    -8(%rbp), %eax
>           18: 3b 45 ec                      cmpl    -20(%rbp), %eax
>           1b: 7d 0c                         jge 0x29 <__Z3addi+0x29>
>           1d: 8b 45 f8                      movl    -8(%rbp), %eax
>           20: 01 45 fc                      addl    %eax, -4(%rbp)
>           23: 83 45 f8 01                   addl    $1, -8(%rbp)
>           27: eb ec                         jmp 0x15 <__Z3addi+0x15>
>           29: 8b 45 fc                      movl    -4(%rbp), %eax
>           2c: 5d                            popq    %rbp
>           2d: c3                            retq
>   ```
> 
> * `g++ -O3 -c main.cpp -o main.o`的反汇编
>
>   ```assembly
>    0000000000000000 <__Z3addi>:
>            0: 85 ff                         testl   %edi, %edi
>            2: 0f 8e 80 00 00 00             jle 0x88 <__Z3addi+0x88>
>            8: 8d 47 ff                      leal    -1(%rdi), %eax
>            b: 83 f8 11                      cmpl    $17, %eax
>            e: 76 7b                         jbe 0x8b <__Z3addi+0x8b>
>           10: 89 fa                         movl    %edi, %edx
>           12: 66 0f 6f 0d 00 00 00 00       movdqa  (%rip), %xmm1  # 1a <__Z3addi+0x1a>
>           1a: 31 c0                         xorl    %eax, %eax
>           1c: 66 0f ef c0                   pxor    %xmm0, %xmm0
>           20: 66 0f 6f 1d 00 00 00 00       movdqa  (%rip), %xmm3  # 28 <__Z3addi+0x28>
>           28: c1 ea 02                      shrl    $2, %edx
>           2b: 0f 1f 44 00 00                nopl    (%rax,%rax)
>           30: 83 c0 01                      addl    $1, %eax
>           33: 66 0f 6f d1                   movdqa  %xmm1, %xmm2
>           37: 66 0f fe cb                   paddd   %xmm3, %xmm1
>           3b: 39 d0                         cmpl    %edx, %eax
>           3d: 66 0f fe c2                   paddd   %xmm2, %xmm0
>           41: 75 ed                         jne 0x30 <__Z3addi+0x30>
>           43: 66 0f 6f c8                   movdqa  %xmm0, %xmm1
>           47: 89 fa                         movl    %edi, %edx
>           49: 66 0f 73 d9 08                psrldq  $8, %xmm1
>           4e: 83 e2 fc                      andl    $-4, %edx
>           51: 40 f6 c7 03                   testb   $3, %dil
>           55: 66 0f fe c1                   paddd   %xmm1, %xmm0
>           59: 66 0f 6f c8                   movdqa  %xmm0, %xmm1
>           5d: 66 0f 73 d9 04                psrldq  $4, %xmm1
>           62: 66 0f fe c1                   paddd   %xmm1, %xmm0
>           66: 66 0f 7e c0                   movd    %xmm0, %eax
>           6a: 74 14                         je  0x80 <__Z3addi+0x80>
>           6c: 0f 1f 40 00                   nopl    (%rax)
>           70: 01 d0                         addl    %edx, %eax
>           72: 83 c2 01                      addl    $1, %edx
>           75: 39 d7                         cmpl    %edx, %edi
>           77: 7f f7                         jg  0x70 <__Z3addi+0x70>
>           79: c3                            retq
>           7a: 66 0f 1f 44 00 00             nopw    (%rax,%rax)
>           80: c3                            retq
>           81: 0f 1f 80 00 00 00 00          nopl    (%rax)
>           88: 31 c0                         xorl    %eax, %eax
>           8a: c3                            retq
>           8b: 31 d2                         xorl    %edx, %edx
>           8d: 31 c0                         xorl    %eax, %eax
>           8f: eb df                         jmp 0x70 <__Z3addi+0x70
>   ```
> 
> ### 3.6.7循环
>
> * while 和 for 循环的两种翻译方法
>  * 跳转到中间策略
>   * guarded-do策略
> 
> 
>* 跳转表
>
>   * 本质是一个数组，数组存放的是每种情况跳转的地址
>
>   * 跳转表执行开关语句的时间与开关数量无关
>
>   * GCC当开关数量比较多，并且值跨度范围小就会使用跳转表
>
>   * 当分支很多很多时，使用跳转表甚至能够只使用一次跳转表引用就成功访问，用空间换时间极大优化了程序
>
>     ```assembly
>      switch 2
>     	addq $1, %rdi
>     	cmpq $8, %rdi
>     	ja .L2
>     	jmp *.L4(, %rdi,8)
> 
> 
>    .L4:
>    	.quad .L9
>     	.quad .L5
>     	.quad .L6
>     	.quad .L7
>     	.quad .L2
>     	.quad .L7
>     	.quad .L8
>     	.quad .L2
>     	.quad .L5
> 
> ### 3.7过程
>
> * 过程是软件中一种很重要的抽象
>* 过程的形式：函数，方法，子例程等
> * P调用Q，Q返回P的过程
>   * 传递控制
>   * 传递数据
>   * 分配和释放内存
> 
> 
>### 3.7.1运行时栈
>
> * 栈帧：一个函数调用的过程占用的栈的所有结构称为栈帧。一个调用就是一个栈帧，且栈顶帧肯定是目前正在执行的函数
>* 假设P调用Q，则栈由高地址到低地址依次是
>   * P帧的参数
>   * P帧的返回地址
>   * Q帧内被保存的寄存器
>   * Q帧的局部变量
>   * Q帧的参数构造区
> 
> * 栈帧结构。由高地址到低地址，由栈底到栈顶分别是
>  * P保存的寄存器
>   * Q要使用的参数
>   * 返回地址
> 
> ### 3.7.2转移控制
>
> * 调用与返回
>
>   ```assembly
>    call # 把 P 过程的下一条指令的地址压入栈，并将 PC 设置成Q过程的起始地址
>   ret  # 从栈中弹出 P 地址，并把 PC 设置成这个地址
>   ```
> 
> ### 过程调用执行过程
>
> * P将参数存入到Q能访问的地方
>* P调用Q，并将P的下一条指令地址压栈
> * Q保存P的现场
> * Q读取参数
> * Q为自己的非静态局部变量分配空间
> * Q执行自己的函数体
> * Q释放自己局部变量空间
> * Q恢复P的现场
> * Q将返回值存在P能访问的地方
> * Q返回，将控制权还给P
> 
> ### 参数传递
>
> * 当参数数量小于等于6时，可以全部用寄存器传递。最大传递位数为64位
>
> * 当参数数量大于6时必须使用栈来传递，且必须8字节64位对齐。即使是char类型也必须占8字节栈
>
> * 参数压栈是最右边参数先压，也就是说栈顶参数是参数1
>
> * 当参数数量为8时，有如下情况
>
>  ```assembly
> (%rsp) = location. 指0-7字节
>  16(%rsp) = argu 1. 指16-23字节
>  8(%rsp) = argu 2. 指8-15字节
>  ```
> 
> ### 3.7.4栈上的局部存储
>
> * 局部数据也必须存放在栈上的情况
>  * 寄存器不足以存放所有的本地数据
>   * 对一个局部变量使用**&**运算符时，必须存放到栈上产生一个地址
>   * 数组或者结构变量
> 
> 
>* 主函数中调用**swap_add(&argu1, &argu2)**过程
>  * 栈指针减少16分配空间
>   * (%rsp) 和 8(%rsp) 存放着两个参数的值
>   * 执行函数调用，函数内的操作会对值产生影响
>   * 执行结束后(%rsp) 和 8(%rsp)的值就是操作后的结果
> 
> 
>* 在栈上存储数量大于6的参数要8字对齐。但存储局部变量不用局部对齐，可以卡字节来节省空间
>
> ### 3.7.5寄存器中的局部存储空间
>
> * 调用者保存： P调用Q时，必须保证调用P的那一刻和Q返回的那一刻规定寄存器中的值不变
>* 常用的调用者保存策略：
>   * 调用前把规定的寄存器值压栈
>   * 压栈后到出栈前的全过程这些寄存器就是自由的
>   * 就可以随便存中间值
>   * 栈帧退出前再恢复寄存器的值
> 
> 
>### 3.7.6递归过程
>
> * 用寄存器存储局部变量
>
> * 源代码
>
>   ```c++
>  int func(long n){
>     if(n == 1) {
>       return n;
>     } else {
>       return n * fib(n - 1);
>     }
>   }
>   ```
> 
> * `g++ -O0 -c main.cpp -o main.o`反汇编
>
>   ```assembly
>  0000000000000000 <__Z4funcl>:
>            0: 55                            pushq   %rbp
>            1: 48 89 e5                      movq    %rsp, %rbp
>            4: 48 83 ec 10                   subq    $16, %rsp
>            8: 48 89 7d f8                   movq    %rdi, -8(%rbp)
>            c: 48 83 7d f8 01                cmpq    $1, -8(%rbp)
>           11: 75 06                         jne 0x19 <__Z4funcl+0x19>
>           13: 48 8b 45 f8                   movq    -8(%rbp), %rax
>           17: eb 19                         jmp 0x32 <__Z4funcl+0x32>
>           19: 48 8b 45 f8                   movq    -8(%rbp), %rax
>           1d: 48 83 e8 01                   subq    $1, %rax
>           21: 48 89 c7                      movq    %rax, %rdi
>           24: e8 d7 ff ff ff                callq   0x0 <__Z4funcl>
>           29: 89 c2                         movl    %eax, %edx
>           2b: 48 8b 45 f8                   movq    -8(%rbp), %rax
>           2f: 0f af c2                      imull   %edx, %eax
>           32: c9                            leave
>           33: c3                            retq
>   ```
> 
>   * 使用`%rbp`来保存`n`的值，使`24`执行后`%rbp`的值还是原来的值
>
> * `g++ -O3 -c main.coo -o main.o`反汇编
>
>   ```assembly
>    0000000000000000 <__Z4funcl>:
>            0: 48 83 ff 01                   cmpq    $1, %rdi
>            4: b8 01 00 00 00                movl    $1, %eax
>            9: 74 12                         je  0x1d <__Z4funcl+0x1d>
>            b: 0f 1f 44 00 00                nopl    (%rax,%rax)
>           10: 0f af c7                      imull   %edi, %eax
>           13: 48 83 ef 01                   subq    $1, %rdi
>           17: 48 83 ff 01                   cmpq    $1, %rdi
>           1b: 75 f3                         jne 0x10 <__Z4funcl+0x10>
>           1d: c3                            retq
>   ```
> 
>   * 直接把递归优化成了迭代展开，真的牛逼
>
> ### 3.8 数组的分配与访问
>
> * 数组访问举例
>
>   * 源代码
>
>     ```c++
>    int func(int *p){
>         p[2] = 3;
>         return p[0];
>     }
>     ```
> 
>   * `O0`优化的反汇编
>
>     ```assembly
>      0000000000000000 <__Z4funcPi>:
>              0: 55                            pushq   %rbp
>              1: 48 89 e5                      movq    %rsp, %rbp
>              4: 48 89 7d f8                   movq    %rdi, -8(%rbp)
>              8: 48 8b 45 f8                   movq    -8(%rbp), %rax
>              c: 48 83 c0 08                   addq    $8, %rax
>             10: c7 00 03 00 00 00             movl    $3, (%rax)
>             16: 48 8b 45 f8                   movq    -8(%rbp), %rax
>             1a: 8b 00                         movl    (%rax), %eax
>             1c: 5d                            popq    %rbp
>             1d: c3                            retq
>     ```
> 
>     * `10`那里直接改内存地址的值
>
> * 嵌套数组
>
>   * `movl (%rax, %rdx, 4), %eax`
>
> ### 结构体和类
>
> * 一个`struct`就是一个`class`，他们只有默认访问级别的区别
>
> * 源代码示例
>
>   ```c++
>  class student {
>   private:
>       int age{10};
>       char *name{0};
>   public:
>       student():age(20),name(0) {}
>       void setAge(int age) { this -> age = age;}
>       int getAge() { return age; }
>   };
> 
>   int func(){
>      student s;
>       s.setAge(10);
>       return s.getAge();
>   }
>   ```
> 
> * 构造函数
>
>   ```assembly
>    0000000000000000 <__ZN7studentC1Ev>: #构造函数
>          0: 55                           	pushq	%rbp
>          1: 48 89 e5                     	movq	%rsp, %rbp
>          4: 48 89 7d f8                  	movq	%rdi, -8(%rbp) # 对象的起始地址是由'%rdi'决定的
>          8: 48 8b 45 f8                  	movq	-8(%rbp), %rax
>          c: c7 00 14 00 00 00            	movl	$20, (%rax) # 初始化'int age'，地址在'%rdi'
>         12: 48 8b 45 f8                  	movq	-8(%rbp), %rax
>         16: 48 c7 40 08 00 00 00 00      	movq	$0, 8(%rax) # 初始化'char* name',地址在'%rdi + 8'
>         1e: 90                           	nop
>         1f: 5d                           	popq	%rbp
>         20: c3                           	retq
>         21: 90                           	nop
>   ```
> 
>   * 但从这个构造函数汇编来看
>  * 对象指针指向的是对象的最低位置，对象的内存分配为`[16 + ptr, ptr]`。因为指针占8字节，而`16`为`8(%rax)`
>   * 对象分配内存的起始地址是由`%rdi`决定的，即由它的上一个函数负责规定对象创建在那里
>   * 越靠前的属性所在的地址越低，越容易访问
> 
> * 成员函数
>
>   ```assembly
>  0000000000000022 <__ZN7student6setAgeEi>:
>         22: 55                           	pushq	%rbp
>         23: 48 89 e5                     	movq	%rsp, %rbp
>         26: 48 89 7d f8                  	movq	%rdi, -8(%rbp) # 第一个参数为'this'指针
>         2a: 89 75 f4                     	movl	%esi, -12(%rbp) # 第二个参数为'age'
>         2d: 48 8b 45 f8                  	movq	-8(%rbp), %rax
>         31: 8b 55 f4                     	movl	-12(%rbp), %edx
>         34: 89 10                        	movl	%edx, (%rax) # 把'age'赋值给'this->age'
>         36: 90                           	nop
>         37: 5d                           	popq	%rbp
>         38: c3                           	retq
>         39: 90                           	nop
> 
>   000000000000003a <__ZN7student6getAgeEv>:
>        3a: 55                           	pushq	%rbp
>         3b: 48 89 e5                     	movq	%rsp, %rbp
>         3e: 48 89 7d f8                  	movq	%rdi, -8(%rbp)
>         42: 48 8b 45 f8                  	movq	-8(%rbp), %rax
>         46: 8b 00                        	movl	(%rax), %eax # 把'this->age'赋值给返回值
>         48: 5d                           	popq	%rbp
>         49: c3                           	retq
>   ```
> 
> * func函数
>
>   ```assembly
>  000000000000004a <__Z4funcv>:
>         4a: 55                           	pushq	%rbp
>         4b: 48 89 e5                     	movq	%rsp, %rbp
>         4e: 48 83 ec 10                  	subq	$16, %rsp
>         52: 48 8d 45 f0                  	leaq	-16(%rbp), %rax # student对象需要16个字节的空间
>         56: 48 89 c7                     	movq	%rax, %rdi # 决定好了创建对象的地址
>         59: e8 00 00 00 00               	callq	0x5e <__Z4funcv+0x14>
>         5e: 48 8d 45 f0                  	leaq	-16(%rbp), %rax # 把创建的对象的地址存起来
>         62: be 0a 00 00 00               	movl	$10, %esi # age 10是第二个参数
>         67: 48 89 c7                     	movq	%rax, %rdi # this地址指针是第一个参数
>         6a: e8 00 00 00 00               	callq	0x6f <__Z4funcv+0x25> # 执行set
>         6f: 48 8d 45 f0                  	leaq	-16(%rbp), %rax # 保存对象的地址
>         73: 48 89 c7                     	movq	%rax, %rdi # 传递'this'指针为第一个参数
>         76: e8 00 00 00 00               	callq	0x7b <__Z4funcv+0x31>
>         7b: c9                           	leave
>         7c: c3                           	retq
>   ```
> 
> * 结论
>  * 在汇编语言中根本没有类的概念，这个概念是人为添加的
>   * 在汇编语言中没有，在机器语言中当然没有
>   * 类在汇编语言中的存在表现为两种方式
>     * `1`：类对象需要一块内存空间，这一块内存空间通常是由对象的属性字段总和决定的
>     * `2`：类的成员函数及各种函数都会被汇编，但汇编后它们脱离了类的关系，而是一个普通的函数。类的关系是由编译器来维持的
> 
> ### 联合体
>
> * 一个`Union`总的大小取决于联合中**最大字段的大小**。即联合数据只能**n选1**
>
> ### 3.9.3数据对齐
>
> * 对齐原则： 任何K字节对象的地址必须是K的倍数
>* x-86最大对齐就是8字节对齐
> * 当前变量最后实际占用多大空间取决于它的下一个变量怎么对齐
> 
> ### 3.10.4对抗缓冲区溢出
>
> * 栈随机化
>  * 实现方式：程序开始时，在栈上分配一段随机的空间
>   * 在Linux系统中，栈随机化已经成了标准的行为
>   * 栈随机化也可能被暴力穷尽破解
> * 栈破坏检测
>   * 思想：在栈帧任何局部缓冲区与栈状态之间插入一个`金丝雀`值
>   * 这个值是在程序运行过程中随机产生的，在恢复寄存器状态和函数返回前，检查这个值，如果改变了则程序直接终止
>   * 这是`gcc`自动加入的代码，可以使用`-fno-stack-protector`来关闭这个功能
> * 限制可执行代码区域
>   * `页`可以标记状态
>   * 将一个内存页标记为`可读可写但不可执行`，就不能通过这个这段内存执行代码了
> 
> ### 3.11浮点数
>
> * 对浮点数的操作原理上来说和操作整数是一样的
>* 但浮点数有它的特殊之处，它所使用的寄存器和指令与整数全部都不一样，但思维是相通的
> * SIMD
>   * SIMD是一种思想，以下都是对它的实现
>   * MMX —— Intel的一个SIMD指令集
>   * SSE(streaming SIMD extensions) —— 也是Intel的一个SIMD指令集
>   * AVX(advanced vector extension) —— 也是Intel的一个SIMD指令集
> 
> ***

## 第五章

> ### 序言
>
> * 编写高效的程序要做到以下几点
>   * 选择一组适当的数据结构和算法
>   * 必须编写出编译器能够有效优化以转换为高效可执行的源代码
>     * 理解优化编译器的能力和局限性是很重要的
>     * C语言的强制类型转换和指针操作，往往使得编译器难以优化
>     * 程序猿要以一种使编译器更容易产生高效代码的方式来编写程序
>
>   * 一个任务分成多部分，分任务可以在`多核和多处理器`的机器上并行执行
>
> 
>
> * 编译器能优化代码，但它不是万能的。我们要尽可能写出容易优化的代码，来帮助编译器
> * 程序优化第一步——消除不必要的工作
>
>   * 不必要的函数调用
>   * 不必要的条件测试
>   * 不必要的内存引用
>
> * 为了使性能最大化——需要指明目标机器模型，指明如何处理指令，以及各个操作的时序性
>
>   * 时序信息能够帮助编译器优化指令选择
>   * 指令实际的执行顺序和程序中的出现顺序并不是一样的
>   * 我们要了解时序关系，这样能帮助编译器更高效的生成代码
>
> * 优化第二步 —— 利用处理器提供的指令并行能力
>
>   * 处理器物理硬件一般是多个加法器或者多个乘法器等多个部件
>   * 处理器硬件或许支持AVX指令能够并行操作
>   * 我们要想办法尽量利用处理器的并行能力
>
> * 研究手段
>
>   * 反复尝试不同的方法修改程序，检查汇编代码执行情况，找出性能瓶颈
>
> * 直接使用汇编的优劣
>
>   * 优势：能从底层对程序进行性能优化
>   * 劣势：可移植性几乎没有
>
> ### 5.1优化编译器的能力和局限性
>
> * 优化的利与弊
>
>   * 利：提高程序的性能
>  * 弊：增大程序的规模，编译时间增加，难以调试
> 
> * 优化的原则
>
>   * 只使用安全的优化，不安全的优化绝对不可能使用
>  * 保证程序执行结果的正确性永远是第一要义
> 
> * 内存别名使用`memory aliasing`
>
>   * 优化前
>
>     ```c++
>    void double_version_one(long *xp, long*yp) {
>       *xp += *yp;
>       *xp += *yp;
>     }
>     ```
> 
>   * 优化后
>
>     ```c++
>    void double_version_two(long *xp, long *yp) {
>       *xp += 2 * *yp;
>     }
>     ```
> 
>   * 优化后好处
>
>     * 读取内存次数减少
>    * 甚至还能使用更高效的移位指令
> 
>   * 不能优化原因
>
>     * 编译器无法保证`xp`和`yp`是不是同一个指针，如果是同一个指针就会与原程序结果不符合
>
>   * 目前情况
>
>     * 当两个指针的类型不同时，编译器会认为它们是不同的指针，会启用内存别名优化
>    * 但如果是程序猿指针强制类型转换，结果真的是同一个指针，那就程序优化后的结果与预期不符
> 
> * 函数调用阻碍优化
>
>   * 优化前
>
>     ```c++
>      long f();
>                                                                                                     
>     long four_f_verison_one() {
>               return f() + f() + f() + f();
>     }
>     ```
> 
> 
>  * 优化后
>
>     ```c++
>    long f();
>                                                                             
>     long four_f_verison_one() {
>               return 4 * f();
>     }
>    ```
> 
> 
>  * 无法优化原因
>
>     * 编译器根本不知道`f()`这个函数干了些啥。万一它除了计算并返回值外还干了其他什么事情，那优化后程序结果就和原程序不符合了
>    * 编译器不知道一个函数是否会有副作用，它就只能默认这个函数有副作用而不进行任何的优化
> 
> * 内联优化
>
>   * 编译器只能在一个编译单元内进行内联
>  * 要多文件内联还是得`LTO`
> 
> ### 5.2表示程序的性能
>
> * **CPE** —— 每元素的周期数
>  * 即每增加处理一个元素需要增加多少个时钟周期
>   * 用时钟周期来度量，表示用了多少个时钟周期而不是一个时钟周期跑得有多快
>  * 因为时钟周期的长度往往是处理器本身的性能指标，而我们这里关心的是程序的性能指标
>   * 这个`CPE`很类似于一次函数的`K`值，但并不是说一定是一次函数
> 
> 
> ### 5.3 程序示例
> 
>* 边界检查降低了程序出错的机会，但是会减慢程序的运行
>
> ### 5.4消除循环的低效率
>
> * 挪到外面去
>
>   * 改进前
>
>     ```c++
>    void func() {
>       for(int i = 0;i < vec_length(v);i++){
>        //...
>       }
>     }
>     ```
> 
>   * 改进后
> 
>     ```c++
>    int length = vec_length(v);
> 
>    void func() {
>       for(int i = 0;i < length;i++){
>         //...
>      }
>     }
>     ```
>                                                 
>   * 分析
>                                                 
>     * 你以为编译器很聪明它会自动给你进行这个优化
>    * 然而虽然编译器很聪明，但是它不知道这个`call`是否会有副作用，因此它就只能默认有副作用而不进行优化
>     * 因此程序的效率就极其的低
>                                                
>   * 效率低
>                                                 
>     * 程序效率不是一般的低，因为`c`字符串是以末尾`\0`结束的。因此求长度实际上要进行遍历，加上循环本省时间复杂度已经朝着`n*n`去了
>    * 常常是一些我们认为理所应该的优化，编译器要百分百保证程序行为正确而不进行优化；而一些我们看不出完全想不到的点，编译器能保证程序执行正确，却做了我们不知道的优化
> 
>
> ### 5.5消除过程调用
> 
>* 尽量消除不必要的函数调用
>
> ### 5.6消除不必要啊的内存引用
>
> * 优化前
>
>   ```c++
>  void combine(data_t *dest) {
>     for(int i = 0;i < length;i++) {
>      *dest += value;
>     }
>   }
>   ```
> 
> * 优化后
> 
>   ```c++
>  void combine(data_t *dest) {
>     data_t sum = *dest
>    for(int i = 0;i < length;i++) {
>       sum += value;
>     }
>     *dest = sum;
>   }
>   ```
> 
> * 优化
> 
>   * 这样就大大减少了读内存的操作
>  * 你以为编译器会做这样的优化，实际上由于内存别名等原因编译器可能不会做，而是没次去读一遍内存
> 
>
> ### 5.7理解现在处理器
> 
>* 优化小总结
>  * 前面的优化我们都仅仅针对程序本身进行优化，只是消除了一些没必要的调用
>   * 如果还想继续优化，就得利用`处理器微体系结构的优化`，也就是要利用处理器执行指令的底层设计
>
> * 现代处理器
>   * 乱序执行
>   * 指令并行
>  * 它采用了极其复杂的微处理器架构，多条指令并行执行，同时又呈现出一种简单顺序执行的表象
> 
> * 界限
>   * 延迟界限
>     * 当一系列操作必须严格按照某顺序执行时，就会有延迟界限
>    * 因为你执行此条指令必须等上一条指令执行完毕
>     * 当代码中数据的时序逻辑限制了处理器利用并行逻辑时，延迟界限会影响程序性能
> 
>   * 吞吐量界限
>     * 描述处理器功能单元的原始计算能力
>     * 这个界限是程序性能的终极限制
>
> 
> ### 5.7.1整体操作
> 
>* 两个单元
>  * 指令控制单元`ICU`:从内存读出指令，并根据这些指令序列生成一组针对程序的基本操作
>   * 执行单元`EU`:执行上述的操作
>* ICU 
>   * 从`指令高速缓存`中取指令
>   * 取出指令后对指令进行译码操作，译码即把一条指令拆分成很小的操作
>   * 将译码后的操作给EU
>   * 如果遇到分支会进行预测，直接进行后续操作，如果预测失败了再回滚
> * EU
>   * 接收操作
>   * 通常每个时钟周期会接收多条操作，然后分派到不同的执行单元进行执行
>   * 分支预测的相关的结果不会写入寄存器和内存，除非能确认到底真正走那条分支
>   * EU执行分支，不是判断确定分支应该走那里，而是确认分支是否预测正确。如果预测错误，要回滚到取指阶段，开销非常大
> * 处理器功能单元
>   * 整数运算单元
>   * 浮点数运算单元
>   * 加载、地址运算单元
>   * 存储单元
>   * 分支单元
>   * ……
> * 退役单元
>   * ICU中有一个退役单元
>   * 比如寄存器文件就是退役单元的一部分
>   * 退役指令定义
>     * 指令的执行操作完成，并且与之相关的分支预测正确
>     * 分支不正确，这条指令需要丢弃
>   * 只有退役指令才能更新寄存器
> * 数据转发
>   * 为了加速数据在寄存器之间的流转，提高运行效率
>   * 寄存器重命名
>     * 维护一张表
>     * 数据可以快速的交互，而不是必须等到写入一个寄存器，然后才从这个寄存器中读出来
> 
> ### 5.7.2功能单元的性能
> 
> * 指标数据
>  * 延迟：表示完成运算所需要的总时间
>   * 发射时间：表示连续两个同类型操作所需要的最小周期数
>  * 容量：表示能够执行该运算功能单元的数量
> * 指标解释
>   * 一个功能单元发射时间为1
>     * 说明每周期都可以开始新的一次计算
>     * 发射时间为1的功能单元称为完全流水线化的
>   * 一个功能单元延迟为3
>     * 说明需要三个处理阶段，比如取数值、相加、舍入
>     * 而且这三个操作是有严格时序逻辑的，不能并行
>   * 一个功能单元发射时间等于延迟
>     * 意味着此功能单元在进行新的计算时，必须完成之前整个操作
>   * 一个功能单元延迟为3，发射为1
>     * 意味着此功能单元在进行新的计算时，不必等上一个操作进行完毕
> * 功能单元取舍
>   * 加法单元很常用，因此设计加法单元时尽量让它低延迟，完全流水线
>   * 除法单元不常用，因此不必浪费大片PCB来让除法单元低延迟，完全流水线
> 
> ### 5.8 循环展开
> 
> * 目的：增加每次循环的计算量，减少循环的次数
>* 性能提升原因：比如有两个加法器，之前每次循环有一个加法器都不能使用。现在循环展开没次做两个加法，因此就可以更大程度地利用硬件
> 
>### 5.9提高并行性
> 
> * 现象：硬件有多个加法器，然而我们不能利用，即使循环展开也不能。因为我们把累加值放在了一个单独的变量中
>* 循环`2 * 2`展开
>   * 每次步长变化为2，且拆分成两个循环并行。最后将这两个循环的结果求和就是最后结果
>  * 这样就能同时利用两个加法器，提高并行能力
> * 向量指令提高并行度
>   * 即`SIMD`
>   * 同时执行一条指令的多个操作
> 
> ### 5.11一些限制的因素
> 
> * 寄存器溢出
>  * 当循环展开过多，或者内联函数内联得太多的时候
>   * 寄存器不够分配了，就只能栈上进行内存分配，就使程序变慢了
>  * 不过好在很多时候寄存器还没溢出时，我们循环展开并行就压榨完了处理器的性能
> * 分支预测失误
>   * 很多时候我们不用关心分支预测失败，因为比如`循环`几乎是只有一次失败，其他全是预测成功
>   * 或者我们可以尽量写代码让编译器能使用`cmove`指令，因为使用条件传送指令没有命中失败的开销
> 
> ### 5.12理解内存性能
> 
> * 目前我们只考虑了读写内存全部从高速缓存上读取的情况
>* 加载的性能
>   * 包含加载操作的程序的性能即依赖流水线性能，也依赖加载单元的`延迟`
>  * 有可能某些操作必须依赖前面的加载完成而导致程序性能下降
> * 存储的性能
>   * 加载和存储可能会相互影响
>   * 即写读之间有依赖也会影响程序的性能
> 
> ### 5.13 应用 - 性能提高技术
> 
> * 高级设计：选择合适的数据结构和算法
>* 基本的编码原则
>   * 减少函数调用
>  * 减少内存引用
> * 低层次的优化
>   * 循环展开
>   * 累计变量，计算结合来提高并行度
>   * 用功能性风格写条件操作，尽可能生成条件转移指令
> 
> ### 5.14 确认和消除性能瓶颈
> 
> * 程序剖析
>  * 原理：在程序中插入工具代码，以确定程序的各个部分需要多少时间
>   * 工具：CPROF
>    * 是什么：Unix系统提供的一个剖析工具
>         * 它计量每个函数消耗了多少CPU时间，每个函数调用的次数
>         * 使用：`g++ -pg main.cpp -o main.out`
>         * 不显示库函数调用，库函数时间被计算在调用它的函数上
>         * 计时原理
>       * 为每个函数维护一个计数器
>       * 程序每隔x中断一次，中断的时候看是正在执行那个函数
>       * 将正在执行的函数的计数器+1
>       * 最后用`计数器次数 * x`就是函数执行的总时间
>       * 因此这用计算方式对于程序本身的运行时间很短时根本不准确，但长时间的程序较准确
> 
> 
> **************

## 第六章

> ### 总述
>
> * 这一章讲存储器层次结构，差不多是已经了解的东西
> * 也没有太多深入理解学习的必要，了解原理即可
> * 这一章对缓存`cache`讲得十分详细，也没有深入了解的必要
>
> ### 访问周期
>
> | 存储类型 | 时钟周期 |
> | -------- | -------- |
> | 寄存器   | 0        |
> | 高速缓存 | 4 - 75   |
> | 主存     | 100+     |
> | 磁盘     | 几千万   |
>
> ### RAM
>
> * 静态随机访问存储器(sattic random access memory)
>   * 有双稳态特性，只要有电，它就能永远保持它的值
>   * 价格更贵，容量更小，一般用作一二级缓存
> * 动态随机访问存储器(dynamic random access memory)
>   * 不稳定，对电压极其敏感，一旦变化值就消失了
>   * DRAM一般在10-100ms内会失去电荷，但这个时间对于时钟周期来说还是太长足够了
>
> ### 局部性小结
>
> * 重复引用相同的变量的程序具有良好的局部性
> * 对于步长为`k`的程序，步长越小，空间局部性越好
> * 对于取指令来说，循环体越小，循环次数越多，局部性越好
>
> ### 存储器层次抽象小结
>
> * 利用时间局部性：同一个数据对象可能被多次利用。即第一次命中被存入缓存后，后面缓存命中的可能性很大
> * 利用空间局部性：块通常包含多个数据对象。即缓存时取周围一块的数据
>
> ***

## 第七章

> ### 定义
>
> * 将多种代码和数据片段收集并组合成一个单一文件的过程，这个文件可被`加载(复制)`到内存执行
>
> ### 可能发生的阶段
> * 编译时——源代码翻译成机器代码时
> * 加载时——被加载器加载到内存并执行时
> * 运行时——由应用程序来执行
>
> ### 分离编译
>
> * 链接的存在才让分离编译成为可能
> * 即单独修改一个文件，单独编译一个文件，最后在整体链接
>
> ### 了解链接的好处
>
> * 帮助构建大型程序 —— 比如依赖找不到。这需要理解链接器如何解析引用、什么是库以及链接器如何使用库来解析引用
> * 避免危险的程序错误 —— 错误定义多个全局变量将通过链接器而不 产生任何报错信息
> * 知道语言作用域是如何实现的
> * 理解共享库
>
> ### 预处理包括内容
>
> * 删除`define`的编译判断指令，展开正确条件下的宏
>
>   ```c++
>   #define PI = 3.14
>   ```
>
> * 处理`#ifdef`、`endif`之类的条件编译，并展开正确条件下的代码
>
>   ```c
>   #ifdef init
>   code part 1
>   #else 
>   code part 2
>   #endif
>   ```
>
> * 递归添加 `#include`
>
> * 删除注释
>
> * 添加行号和文件信息，用于报错
>
> ### 链接操作步骤
>
> * 定义与引用的概念
>   * 子程序(函数)起始地址和变量的起始地址是**符号定义**(definition)
>   * 调用子程序(函数)和使用变量是**符号引用**(reference)
> * 符号解析
>   * 符号：一个函数、一个全局变量或一个静态变量
>   * 将每个符号引用正好和一个符号定义关联起来
> * 重定位
>   * 合并相关的 `.o`文件
>   * 把每个符号定义和一个内存地址关联起来，然后修改所有对这些符号的引用，使它们执向正确的内存地址
>
> ### 链接的好处
>
> * 模块化
> * 效率高
>
> ### gcc链接举例
>
> ```shell
> gcc -O2 -g -o result.out main.c swap.c # -O2 优化等级
> 								    # -g 生成调试信息
> 								    # -o 目标结果文件名
> # 此语句相当于分别将两个'.c' 文件执行预处理、编译、汇编三个过程，在最后一起做重定向
> ```
>
> ### 目标文件
>
> * 目标文件定义
>   * 就是包含二进制机器代码和数据的文件
>
>   * 代码数据地址全都是由零开始的
>   * linux中为 `.o`文件；Windows中为`.obj`文件
>
> * 可执行目标文件
>   * linux中为 `.out`文件；windows中为`.exe`文件
>   * 文件中的代码数据可以直接复制到内存中执行
>   * 代码和数据地址都是虚拟空间的地址
>
> * 共享的目标文件
>   * 是一种特殊的可重定位目标文件，称为共享库文件
>   * 可以在加载时或运行时被动态地加载进内存并链接
>   * 在linux中是`.so`文件；在Windows中为`.dl`文件
>
> * 目标文件格式
>   * linux中为`ELF`格式，指可执行、可链接格式
>   * Windows中为`PE`格式，指可移植、可执行格式
>
> ### 静态链接
>
> * 输入
>   * 一组可重定位目标文件
>   * 命令行参数
> * 输出
>   * 一个**完全链接**、可以加载和运行的可执行目标文件
>
> ### ELF文件格式
>
> * 各个 操作系统中的可执行目标文件格式不同
> * window使用`PE`(Portable Executable)
> * macOS使用`Mach-O`
> * Unix使用`ELF`(Executable Linkable Format)
>
> ### 链接视图结构(可重定位目标文件)
>
> * ELF头
>   * 包含标识信息、文件类型、机器类型、**节头表偏移**等其他信息
>
> * .text节
>   * 编译后的代码部分
>
> * .rodata
>   * 只读部分，如printf里面的内容、swich跳转表
>
> * .data节
>   * 已初始化的全局和静态变量
>   * 注意：局部变量保存在栈中，根本不用管
>
> * .bss节
>   * 只声明但未初始化的全局和静态变量
>   * 注：这个节的存在只是为了提升空间效率
>
> * .symtab
>   * 符号表
>   * 存放程序中定义和引用的函数和全局变量的信息
>
> * .rel.text节(relocation text)
>   * 一个.text节中的位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置
>
> * .rel.data节(relocation data)
>   * 被模块引用或定义的所有全局变量的重定位信息
>
> * 其他各种各样的节
> * 节头表
>   * 是仅次于ELF头的关键信息
>   * 描述节名、在文件中的**偏移**、**大小**、访问属性、对齐方式等信息
>   * 各个节在ELF文件中的存放位置是根据节的**偏移、大小**确定的，且偏移的首地址是0x0
>
> ### 三种符号
>
> * 由本模块定义并能被其他模块引用的全局符号。如本模块定义的非静态的`C`函数和变量
> * 由其他模块定义并能被本模块引用的全部符号。如其他模块定义的非静态`c`函数和变量
> * 只被本模块定义和引用的局部符号。如本模块定义的静态`C`函数和变量
>
> ### .symtab结构
>
> * 查看符号表
>
> ```shell
> gcc -c main.c -o main.o
> readelf -s main.o
> ```
>
> * 结构
>
> | Num  | Value | Size | Type     | Bind   | Vis     | Ndx  | Name        |
> | ---- | ----- | ---- | -------- | ------ | ------- | ---- | ----------- |
> | 16   | 0x0   | 4    | object   | global | default | 4    | int_a       |
> | 17   | 0x0   | 4    | object   | global | default | 3    | int_b_init  |
> | 18   | 0x4   | 1    | object   | global | default | 4    | char_b      |
> | 19   | 0x4   | 1    | object   | global | default | 3    | char_b_init |
> | 20   | 0xb2  | 28   | function | global | default | 1    | main        |
>
> * 表项含义
>   * Num —— 代表符号的顺序索引
>   * value —— 代表此符号**相对于此符号定义的节**的偏移。16,18是.bss节；17,19是.data节；20是.text节
>   * size —— 此符号定义的object占用的大小或者定义的函数占据的大小
>   * ndx —— 不同整数代表不同的节。4代表bss节；3代表data节；1代表text节
>
> ### 执行视图结构(可执行目标文件)
>
> * 执行入口
>   * 链接视图中ELF头的**e_entry**给出了程序执行第一条指令的地址，且地址为**0**
>   * 执行视图中ELF头的**e_entry**同样给出程序执行的第一条指令地址，但**不为0**
>
> * 其他不同之处
>   * 多一个程序头表
>   * 多一个`.init`节
>   * 因为已经是完全链接过的，因此不需要.rel.text和.rel.data节
>
> * 相同之处
>   * 都有节头表
>
>   * 所有的函数和变量都有确定地址(虚拟地址空间的地址)
>   * 符号引用处已被重定位
>
> * 段
>   * 相同属性的节合并成段
>   * 如.init、.text、.rodata合并成只读代码段
>
> * 程序头表
>   * 说明节如何映射成段
>   * 决定在虚拟地址空间各段的位置信息
>
> ### 链接本质
>
> * 合并相同的**节**
>
> ### 可执行文件存储映射
>
> * `.o`文件到`.out`文件地址变化
>   * `.o`文件里面语句的地址都是从零开始
>   * `.out`文件里面语句地址都不是从零开始
>
> * 上面原因
>   * 经过重定位的可执行文件加入到内存时，加入到的一个虚拟地址空间，32位空间最大4G
>   * 在虚拟地址空间中用户段代码就不是从零开始的
>   * 至于从那里开始，是由ELF头表确定的
>
> * ELF文件
>   * 链接后磁盘中会有此可执行文件的ELF文件
>   * ELF文件组成部分
>     * ELF头
>     * 各种节点
>
>   * 虚拟地址空间源代码分为多段
>     * **只读代码段**—— text、init节点
>     * **读写代码段**—— data、bss节点
>
> ### 链接视图和执行视图
>
> * 本质
>   * 两种视图指两类ELF格式
>
> * 链接视图
>   * 用于描述可重定位目标文件
>   * 包含ELF头，程序头表(可选)，各种节
>
> * 执行视图
>   * 用于描述可执行目标文件
>   * 包含ELF头，程序头表(必有)，各种段
>   * 段由多个节映射组成
>
> ### 符号解析
>
> * 核心：将每个引用与它输入的可重定位目标文件的符号表中的一个确定符号关联起来
> * 过程
>   * 程序中有定义和引用的符号
>   * 编译器将定义的符号存放在一个符号表中
>   * 编译器将符号引用存放在重定位中
>   * 链接器将符号引用和符号定义相关联
>
> * 符号类型
>   * 全局符号 —— 非static定义的符号，本模块定义其他模块可以引用
>   * 外部符号 —— extern引入的符号，其他模块定义此模块引用
>   * 局部符号 —— static定义的符号，本模块定义本模块可以引用
>
> * 存储
>   * 存储在**.symtab节**
>   * .symtab节中有符号的各种信息
>
> * 符号表
>   * 只有符号定义才存在符号表
>   * 符号引用不存
>
> ### 多重定义全局符号
>
> * 强弱符号
> * 强符号
>   * 指定义且已经有初始值的符号
>   * 如函数定义或已经初始化的变量
> * 弱符号
>   * 指定义但没有初始值的符号
>   * 如未初始化的变量
> * 解析规则
>   * 强符号只能被定义一次，否则链接出错
>   * 一个符号被定义成一次强符号和多次弱符号，则以强符号为准
>   * 若有多个若符号定义，则任选一个
>
> * 注意事项
>   * 两个模块中重复定义**不同类型**的同一变量时，往往会有意想不到的错误
>   * 因此尽量避免使用全局变量
>
> * 错误举例
>
> ```c
> /*foo5.c*/
> void f(void);
> int y = 15232;
> int x = 15213; //x定义成int
> int main(){
>     f();
>     printf("%x,%y",x,y);
>     return 0;
> }
> 
> /*bar5.c*/
> double x; //x定义成double
> void f(){x = -0.0;}
> ```
>
> ### 重载方法的实现
>
> * C++和Java都允许重载方法，方法名相同但方法参数不同
> * 重整：编译器将每个唯一的方法和参数列表组合编码成一个对链接器来说唯一的名字的过程
> * 恢复：上面过程的反过程
> * 举例：`3Foo、bar__3Fooil`
>
> ### 提供函数的两种方式
>
> * 让编译器认识标准函数的调用，直接生成代码
>   * C标准库函数太多，会极大增加编译器的复杂度
>   * 每次修改标准函数时，就必须发布一个新的编译器版本
> * 静态库
>   * 存储时对磁盘浪费
>   * 执行时对内存浪费
>
> ### 静态库
>
> * 静态库概念
>   * 就是平时所说的标准库、公共库、各种库
>
> * 静态库由来
>   * 将所有相关的可链接目标模块`.0`打包成一个单独的库文件`.a`，称为静态库文件，也称为存档文件(archive)
>
> * 静态库使用
>
>   * 在构建可执行文件时，只需要指定库文件名，链接器自动到库中找用到的目标模块，并且只把用到的模块从库中拷贝出来，链接到可执行文件中
>
> * 创建静态库
>
>   ```bash
>   ar crv libmylib.a my_print.o my_math.o
>   ```
>
>   * 核心就是使用一个归档命令`ar`将多个`.o`文件压缩成一个`.a`文件
>
> * 创建静态库
>
>   ```bash
>   g++ -static -o main.out main.o -L. mystaticlib.a
>   ```
>
>   * `-static`是告诉编译器采取静态链接
>   * `-L.`是告诉链接器在当前目录下查找静态库`mystaticlib.a`
>
> ### 静态库符号解析
>
> * 静态库符号解析
>   * 递归不动点集合解析
>
> * 三个集合
>   * E —— 在最后会被构成可执行文件的文件
>   * U —— 未被解析的符号
>   * D —— 已被解析的符号
>
> * 符号解析算法
>   * 按照顺序扫描`.o`和`.a`文件
>   * `.o`文件直接放入E，`.a`文件则进行判断
>   * 扫描期间将未符号引用匹配的符号放入集合U
>   * 在扫描下一个`.o`或`.a`文件时进行U集合中符号解析匹配
>   * 若符号A匹配成功则将A从集合E中移除，将A加入集合D，将有A完整定义的文件加入E
>
> * 解析注意事项
>   * 层级越高的文件要放最前面
>   * `libc.a`文件默认放最后
>   * 即命令行参数的顺序会影响解析的结果
>
> ### 重定位
>
> * 步骤
>   * 重定位节
>     * 将所有相同类型的节合并为同一类型的新的聚合节
>   * 符号引用
>     * 修改代码节和数据节中对每个符号的引用，使它们指向正确的运行时地址
>
> * 重定位条目
>   * 汇编器在遇到引用时，生成一个重定位条目
>   * 数据引用放在 .rel.data节中
>   * 指令中引用放在 .rel.text节中
>
> * 重定条目结构举例
>   * offset ：偏移
>   * symbol：符号名
>   * type：重定位类型。有PC相对寻址和绝对寻址两种
>
> ### 重定位实战
>
> * 源代码
>
> ```c
> /*main.c*/
> int sum(int *a, int n);
> int array[2] = {1,2};
> void main(){
> 	int val = sum(array,2);
> }
> 
> /*sum.c*/
> int sum(int *a, int n){ return *b+a;}
> ```
>
> * 带重定位信息的反汇编指令
>
> ```shell
> objdumb -dx main.o > main.s
> ```
>
> * 反汇编信息
>
>   ```assembly
>   Disassembly of section .text:
>
>   0000000000000000 <main>:
>   0:   55                      push   %rbp
>   1:   48 89 e5                mov    %rsp,%rbp
>   4:   48 83 ec 10             sub    $0x10,%rsp
>   8:   be 02 00 00 00          mov    $0x2,%esi
>   d:   48 8d 3d 00 00 00 00    lea    0x0(%rip),%rdi        # 14 <main+0x14>
>      10: R_X86_64_PC32       array-0x4  #指出array用PC相对寻址重定位
>   14:   e8 00 00 00 00          callq  19 <main+0x19>
>      15: R_X86_64_PLT32      sum-0x4    #指出sum用PLT寻址重定位
>   19:   89 45 fc                mov    %eax,-0x4(%rbp)
>   1c:   90                      nop
>   1d:   c9                      leaveq
>   1e:   c3                      retq
>   ```
>
>   * 重定位填入的地址信息就是偏移为0x10和0x15的四个字节
>   * 对array来说
>     * offset = 0x10
>     * symbol = array
>     * type = R_X86_64_PC32
>     * append = -0x4
>
> * 寻址方式
>   * PC相对寻址 —— 地址 = 下一条指令的地址(PC的值) + 偏移
>   * 绝对寻址 —— 地址 = 绝对地址
>
> * 相对寻址重定位过程
>   * 符号解析完成后E中肯定有main.o和sum.o两个文件；D中肯定有sum符号
>   * 代码合并后main和sum在同一个.text节中
>   * 在.text节中根据重定位条目信息进行相对寻址重定位 
>
> * 绝对寻址重定位过程
>   * 符号解析完成代码合并后.data节中一定有array的位置信息
>   * 在.text节中根据.data节中array的绝对地址进行绝对地址重定位
>
> ### 可执行文件
>
> * 结构
>   * 只读内存段(代码段)
>     * ELF头
>     * 段头部表
>     * .init(一个小函数，叫做_init)
>     * .text
>     * .rodata
>   * 读写内存段(数据段)
>     * .data
>     * .bbs
>   * 不加载到内存的符号表和调试信息
>     * .systab
>     * .debug
>     * .line
>     * .strtab
>     * 节头部表
> * 查看程序头部表(program header table)
>
> ```shell
> objdump -dx main_sum.out > main_sum.out.s
> ```
>
> * 程序头部表内容
>
>   ```assembly
>   LOAD 	 off  0x0000000000000000  #偏移
>   		vaddr 0x0000000000000000    #内存地址
>   		paddr 0x0000000000000000    #内存地址
>   		align 2**21                 #对齐方式
>   filesz 0x0000000000000830   #目标文件段大小
>   memsz 0x0000000000000830    #内存中段大小
>   flags r-x                   #代码段读写标志位
>   LOAD 	 off  0x0000000000000df0 
>   		vaddr 0x0000000000200df0 
>   		paddr 0x0000000000200df0 
>   		align 2**21
>   filesz 0x0000000000000228 
>   memsz 0x0000000000000230 
>   flags rw-                   #data段读写标志位
>   ```
>
>   * 程序头表描述了可执行文件如何被映射到连续的内存段
>   * .data段包含.data节和.bss节，因为有一些变量未被初始化未分配空间。因此.data段目标文件段大小和内存中段大小不一样
>
> * 查看ELF头表
>
> ```shell
> readelf -h main_sum.out
> ```
>
> * ELF头表内容
>
> ```assembly
> ELF Header:
>   Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
>   Class:                             ELF64
>   Data:                              2's complement, little endian
>   Version:                           1 (current)
>   OS/ABI:                            UNIX - System V
>   ABI Version:                       0
>   Type:                              DYN (Shared object file)
>   Machine:                           Advanced Micro Devices X86-64
>   Version:                           0x1
>   Entry point address:               0x4f0   #程序main()函数的入口
>   Start of program headers:          64 (bytes into file)
>   Start of section headers:          6472 (bytes into file)
>   Flags:                             0x0
>   Size of this header:               64 (bytes)
>   Size of program headers:           56 (bytes)
>   Number of program headers:         9
>   Size of section headers:           64 (bytes)
>   Number of section headers:         28
>   Section header string table index: 27
> ```
>
> * entry point规定了程序的入口
>
> ### 加载可执行文件
>
> * 加载定义
>   * 将程序复制到内存中并运行的过程
>
> * 加载粗过程
>   * 系统调用execve()函数调用加载器
>   * 加载器将可执行文件的代码和数据复制到内存
>   * 跳转到程序的第一条指令入口点执行运行程序(main)
>
> * execv()过程
>   * 在shell命令行输入命令
>   * 命令行解释器对命令行输入做切分，分出调用程序名和参数
>   * 调用fork()函数，几乎百分百赋值一个和父进程一模一样的进程。包括只读代码段、读写代码段、堆、用户栈
>   * 调用execv()函数然后调用加载器，删除新进程现有虚拟内存段。在程序头表引导下创建新的虚拟内存段
>   * 调用进程的main函数
>   * 返回并归还系统控制权
>
> * 虚拟内存
>   * 加载后代码和数据段被映射到虚拟地址空间
>
> ### 共享库
>
> * 特点
>
>   * 每个库包含目标代码文件
>   * 从程序中分离出来，**无论磁盘还是内存**都只有一份
>   * 可以在运行时和加载时动态链接
>
> * 生成动态链接库
>
>   ```bash
>   g++ -shared -fpic -o mydynamic.so main.cpp other.cpp
>   ```
>
>   * `-shared`是说明生成的是动态链接库
>   * `-fpic`是说明生成位置无关代码
>
> * 使用动态链接
>
>   ```bash
>   g++ -o hellp.cpp -o hello.out ./mydynamic.so
>   ```
>
>   * 复制了一些重定位和符号表信息到`hello.out`，使运行时可以解析对`mydynamic.so`的引用
>
> * 执行时
>
>   * 首先重定位`mydynamic.so`的文本和数据段到某个内存段
>   * 接着重定位`hello.out`所有对`mydynamic.so`定义的符号的引用
>   * 将控制权转交给应用程序，从此后共享库位置就固定下来了(虚拟内存中)，并且在此程序运行过程中都不会改变
>
> ### 动态链接
>
> * 动态链接定义
>   * 在加载时或运行时，共享库可以被加载到任意的内存地址，并和一个在内存中的程序链接起来
> * 动态链接运用举例
>   * 分发软件
>     * 让用户下载一个新的一个共享库
>     * 用新的共享库替换旧的
>     * 下次启动引用就会用新的共享库达到软件升级的目的
>   * 个性化web
>     * 之前web服务器是`fork`和`execve`创建子进程来生成动态内容
>     * 而现在只用将动态每个用户不同的内容打包放在共享库中，然后执行就行了
>   * 共享库可以用不同语言开发
>   * 共享库可以作为插件，拓展程序的功能
> * 动态链接好处
>   * 可以动态进行链接，随增随减
>   * 而且可以不在编译的时候链接，而在加载和运行时链接
> * 加载时链接
>   * 使用动态链接器进行链接(Id-linux.so)
> * 运行时链接
>   * 即由应用程序来控制链接
>   * 操作系统提供了接口`void *dlopen(const char *filename, int flag)`和`void *dlsym(void *handle, char *symbol)`来支持运行时链接
>   * 调用操作系统的接口来实现
>   * 可用于构建高性能web服务器
> * 动态链接过程
>   * main.o，libc.so先进行静态链接生成main.out。但此main.out只是部分链接的可执行文件
>   * main.out加载执行时调用execv()系统调用
>   * execv()调用动态链接器Id-linux.so进行动态链接，生成完全链接的可执行目标。但此目标只存在于存储空间而不存在于磁盘空间
> * 程序头表
>   * 可执行文件中的程序头表中有指明动态链接器的路径。此种链接应该是加载时链接而非运行时链接
>
> ### JNI
>
> 将C++函数编译到一个共享库中
>
> * 当执行`JNI`调用时，Java解释器利用`dlopen`接口(或其他类似的接口)动态链接和加载共享库，最后调用共享库中的函数
>
> ### 位置无关代码
>
> * 生成位置无关代码共享库
>
> ```shell
> gcc -shared -fPIC lib.so sum.o sub.o
> ```
>
> * 定义
>   * 可以加载而无需重定位的代码称作位置无关代码
> * 为什么要有PIC
>   * 一个共享库其实也是一个`.o`文件，它也有一些外部符号
>   * 而这些外部符号是定义在其他模块内的，它的实际内存地址要直到加载的时候才知道
>   * 我们不能直接去修改重定位共享库，因为这样不容易达到复用的目的
>   * 因此采取的方式是单独把`访问外部符号地址`这一项单独抽出来，不和共享库耦合
> * 具体实现方法
>   * 访问外部符号分为两个步骤
>   * 首先访问一个表项，表项的地址是在链接时就可以确定下来的
>   * 接着通过表项访问外部符号实际的内存地址，实际地址要在加载时才确定
>   * 即访问是间接的而不是直接的
> * 引入PIC目的
>   * 无需修改程序代码即可将共享库加载到任意位置执行
> * 模块内部函数调用或跳转
>   * 使用PC相对寻址
>   * 寻址的偏移量是补码表示，可以为负数
>   * 此调用无需动态链接器参与，因为根本没有涉及其他模块
> * 模块内部数据引用
>   * 对于模块内部的static变量，它是被存储在.data段中的
>   * 访问它依旧采取PC相对寻址
>   * 但偏移量有变化。偏移=下一条指令到.text段结尾的偏移 + .data段起始位置到变量位置的偏移
>   * 等于偏移等于两段偏移的和
>   * 因为没涉及其他模块，因此也不用动态链接
> * PIC模块外数据引用
>   * 在.data节开始处设置一个指针数组(全局偏移表，GOT)，指针可指向一个非静态全局变量
>   * GOT条目与引用数据的指令之间的距离相对固定。和上面一种情况一样
>   * 汇编器为GOT的每一项生成一个重定位项(在.rel.data中)
>   * 加载时，动态链接器对GOT中的每一项进行重定位，填入所引用的地址(如&b )
>   * 等于是PC相对先找到GOT中的项，GOT项的值就是变量的真实地址，而GOT项的值是动态链接时填入的
> * PIC模块之间进行调用或跳转
>   * 和上一种方式一样
>   * 只不过GOT表项的值为函数的首地址
>   * 可以使用延迟绑定技术 —— 即加载时不绑定而是第一个运行调用时才绑定
> * PIC缺点
>   * 一次访问或跳转使用更多的指令条数和寄存器数量
>
> ### 打桩机制
>
> * 打桩解释
>   * 替换动态链接中的方法或函数实现，类似于动态代理
>
> * 基本思想
>
>   * 给定一个需要打桩的目标函数，创建一个对应的包装函数，它的函数原型和目标函数完全一致
>   * 我们欺骗编译器去调用我们版本的函数而不是本身的函数
>   * 我们版本的函数会执行自己的逻辑，一般最后会调用原本的函数
>
> * 编译时打桩
>
>   ```bash
>   g++ -I. main.cpp mymalloc.o -o main.out 
>   ```
>
>   * 使用 `-I.`参数告诉预处理器前扫描前首先在当前目录寻找.h定义
>
> * 链接时打桩
>   * 使用`--wrap`实现符号的重命名进行打桩
>
> * 运行时打桩
>   * 动态链接器`LD_PRELOAD`环境变量设置一些共享库路径名
>   * 当有未解析的符号时首先就在设置的路径名中找，从而实现打桩
>
> * 打桩核心
>   * 让自己编写的函数体被解析的优先级比原先的优先级高
>
> ***

## 第八章

> ### 异常控制流
>
> * 控制转移
>   * 从一条指令过渡到另一条指令叫做`控制转移`
> * 控制流
>   * 控制转移的序列叫做控制流
> * 突变事件举例
>   * 包到达网络适配器后，必须放入内存中
>   * 程序向磁盘请求数据，然后休眠，直到被通知数据已经就绪
>   * 子进程终止时，父进程必须收到通知
> * 异常控制流
>   * 就是控制流的突变
> * 不同层次的ECF
>   * 硬件层：检测到事件会触发控制突然转移到异常处理程序
>   * 操作系统层：内核通过上下文切换将控制从一个用户进程转移到另一个用户进程
>   * 应用层：一个进程可以发送信号到另一个进程，接受者会将控制权转移到它的一个信号处理程序
> * 理解ECF重要性
>   * 系统IO、进程、虚拟内存机制都有使用到ECF
>   * 通过陷阱或者系统调用形式向内核请求服务
>   * 操作系统提供了强大的ECF机制
>   * 有助于理解并发
>   * 理解高级语言的异常处理机制
>
> ### 异常
>
> * 定义
>   * 异常就是控制流的突变，用来响应处理器状态中的某些变化
> * 状态
>   * 在处理器中，状态被编码成不同的位和信号
>   * 状态的变化称为事件
> * 两种类型的事件
>   * 和当前指令相关：如缺页，算术溢出，除零
>   * 和当前指令无关：如系统定时器产生的信号，一个IO请求完成
> * 异常处理流程
>   * 检测到事件发生
>   * 通过异常表(一个常驻的表)，进行一个间接过程调用
>   * 跳转到专门处理这类事件的操作系统子程序(异常处理程序)
> * 异常处理的可能结果
>   * 控制返回给current指令
>   * 控制返回给next指令
>   * 程序被中断
> * 误区
>   * 异常并不都是错误
>   * 造成控制流突变的都是异常
>   * 高级语言中说到的异常是`应用级ECF`，和我们现在讨论的还不一样
>
> ### 异常处理
>
> * 异常号
>   * 异常号是一些非负整数
>   * 一部分由处理器设计者决定。如缺页、被零、内存访问违例、断点、算术溢出
>   * 一部分由操作系统内核(操作系统常驻内存的部分)设计者决定。如系统调用、外部IO
>
> * 异常表
>   * 插电时由操作系统分配和初始化
>   * 异常表基地址存在一个特殊的异常基址寄存器中
>
> * 与过程调用联系
>   * 两者非常类似，但有很多不同
>   * 比如异常处理是在内核模式下，使用内核栈而不是异常栈，且拥有完全访问权限
>
> ### 异常类别
>
> * 类别表
>
> | 类型 | 原因             | 异/同 | 返回       |
> | ---- | ---------------- | ----- | ---------- |
> | 中断 | 设备IO信号       | 异步  | 下一条指令 |
> | 陷阱 | 有意的异常       | 同步  | 下一条指令 |
> | 故障 | 潜在可恢复的错误 | 同步  | 当前指令   |
> | 终止 | 不可恢复的错误   | 同步  | 不返回     |
>
> * 中断
>   * 中断不是由专门的指令造成的，比如网络适配器是向CPU的一个引脚发送信号，从这个意义上来说它是异步的
>   * 中断处理结束后返回下一条指令，程序继续执行，就好像完全没有中断过一样
> * 陷阱和系统调用
>   * 陷阱最重要的用途就是在用户程序和内核之间提供一个像过程一样的接口 —— 系统调用
>   * `read、fork、execve、exit`都是系统调用
>   * 系统调用和调用过程很类似，但也有很多不同。比如异常处理是在内核模式下，使用内核栈而不是异常栈，且拥有完全访问权限
> * 故障
>   * 故障可能能够被处理程序修正，如果修正就继续执行，如果无法修正就程序结束
>   * 故障举例 —— 虚拟内存缺页
> * 终止
>   * 是指不可能恢复的致命错误，通常是一些硬件错误
>
> ### linux/x86-64 系统中的异常
>
> * 分配
>   * 0-31后由Intel处理器架构师定义，是异常，使用异常跳转表
>   * 32-255由操作系统定义，是中断或者陷阱，使用系统调用跳转表
> * 举例
>
> | 异常号  | 描述         | 类型         |
> | ------- | ------------ | ------------ |
> | 0       | 除法错误     | 故障         |
> | 13      | 一般保护故障 | 故障         |
> | 14      | 缺页         | 故障         |
> | 18      | 机器检查     | 终止         |
> | 32 -255 | 操作系统定义 | 中断或者陷阱 |
>
> * 系统调用
>   * 内核中有一个系统调用跳转表，此跳转表和异常表没有关系
>   * C语言提供了对系统调用包装好的系统级函数
> * 系统调用函数底层
>   * 参数全部通过寄存器传递而不是栈传递(因为栈是用户栈)
>   * 用rax寄存器来传递调用了系统调用整数值
>   * 参数还是依次放在 %rdi、%rsi中
> * 系统调用举例
>
> | 编码 | 名字   | 描述                 |
> | ---- | ------ | -------------------- |
> | 0    | read   | 读文件               |
> | 2    | open   | 打开文件             |
> | 9    | mmap   | 将内存页映射到文件   |
> | 57   | fork   | 创建进程             |
> | 33   | pause  | 挂起进程直到信号到达 |
> | 59   | execve | 执行一个程序         |
> | 60   | _exit  | 终止进程             |
>
> * 举例
>
> ```c
> void main(){
>         write(1,"Hello World\n",13);//参数1代表stdout，参数2是内容，参数3是长度
>         _exit(0);
> }
> ```
>
> ```assembly
> movq $1, %rax # 执行1系统调用
> movq $1, %rdi # stdout
> movq $string, %rsi # 内容
> movq $len, %rdx # 长度
> syscall # 执行系统调用
> ```
>
> ### 进程
>
> * 一个特点——**独占**
> * 给程序独占使用着处理器的假象，只有在精确计算每条指令时间时，会发现指令之间CPU好像会周期性的停顿
> * 给程序独占使用者内存系统的假象
>
> ### 流
>
> * 逻辑控制流
>   * 程序计数器PC值的序列就是逻辑控制流
> * 并发流
>   * 一个逻辑流与另一个逻辑流在时间上重叠就是并发流
>   * 即使运行在同一个处理器下，也算并发
> * 并行流
>   * 并行流是并发流的一个真子集
>   * 两个流运行在不同的处理器核上，就叫并行流
>
>
> ### 用户和内核模式
>
> * 出现原因
>   * 为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一个机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围
> * 实现方式
>   * 使用位模式
>   * 设置位模式就是内核模式，没有设置就是用户模式
> * `/proc`
>   * 是Linux提供的一种聪明机制，它允许用户模式进程访问内核数据结构内容
>   * 它将许多内核数据结构内容输出为一个用户模式可读的文本文件层次结构
>   * 比如`cat /proc/cpuinfo`
>
> ### 上下文切换
>
> * 调度是由内核中的代码完成的
> * 系统调用、中断都可能发生上下文切换
>
> ### 进程控制函数
>
> * `getpid`：获取进程id
> * `exit`：终止进程
> * `fork`：创建新进程
>   * 调用一次，返回两次
>   * 子父进程并发执行
>   * 地址空间内容相同，但是彼此独立
>   * 文件是共享的，即子进程会继承父进程已打开的文件
> * `waitpid`：回收进程，等待进程终止或停止
> * `wait`：是`waitpid`的简单版本
> * `sleep`：让进程挂起一段时间
> * `execve`：加载并运行程序
>
> ### execve和fork的区别
>
> * fork
>   * 创建了一个新的进程，有一个新的pid
> * execve
>   * 只有找不到`filename`这种错误才会返回到调用程序，否则不会返回。即正常情况下`execve`不会返回
>   * 调用`execve`后，之前的进程等于消失了，它唯一留下来的就只有进程号，其他什么都没留下来
>   * 进程的Id是不会改变的，因为根本没有新的进程
>
> ### shell简单实例
>
> ```c++
> void do_command(){
> 	int status;
> 	pid_t wpid;
> 	pid_t pid =fork();
> 	if(pid==0){
> 		char **args=(char**)malloc(sizeof(char *)*32);
> 		//初始化填充args
> 		if(execvp("busybox",args)==-1){ //在子进程中调用execve
> 			cout << "sorry your input is illegal,please enter ctrl C to restart";
> 		}
> 		cout << endl;
> 	}else if(pid>0){
> 		do {
> 			wpid = waitpid(pid, &status, WUNTRACED); //如果先执行到父进程，就等待子进程返回
> 		} while (!WIFEXITED(status) && WIFSIGNALED(status));
> 	}
> }
> 
> int main(){
> 	while(true){
> 		do_command();
> 	}
> 	return 0;
> }
> 、090·
> ```
>
> ### 信号
>
> * 概念
>   * 是一种更高层次的软件形式异常
>   * 它允许进程和内核中断其他进程
> * 信号发送
>   * 发送方
>     * 内核，其中一个进程可以通过内核间接给其他进程或它本身发信号
>   * 发送原因
>     * 内核检测到一个系统事件，如除零
>     * 一个进程调用kill函数，显示要求内核发送一个信号给目的进程，而且这个目的进程可以是本身
> * 信号接收
>   * 接受者
>     * 进程
>   * 处理措施
>     * 忽略不做处理
>     * 执行一个信号处理程序的用户层函数处理捕获这个信号
> * 发出信号的方式
>   * 使用`/bin/kill`命令
>   * 通过键盘`ctrl + D`
>   * 使用用户层函数`kill、alarm`
> * 接收信号处理
>   * 进程从内核模式切换到用户模式时，会检查待处理的信号集合
>   * 会从如果非空的集合中取出信号进行处理
> * 处理的方式
>   * 每个信号类型都有一个预定义的默认行为，比如`SIGKILL`默认行为就是终止进程
>   * 可以通过`signal`函数改变某些类型信号的处理方式，但`SIGKILL`等信号的默认行为不允许修改
> * 编写信号处理程序的问题
>   * 处理程序和主程序是并发的，而且共享全局变量。这就涉及到并发编程了
>
> ### 非本地跳转
>
> * 定义
>   * 从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用-返回流程
>   * 通过`setjmp`和`longjmp`两个用户级函数来实现的
> * 运用举例
>   * 从深层次的嵌套函数中直接返回，而不用破解调用栈
> * C++和Java的软件异常
>   * 其实是C语言`setjmp`和`longjmp`的更加结构化版本
>   * `catch`类似于`setjmp`函数
>   * `throw`类似于`longjmp`函数
>
> ************

## 第九章

> ### 概述
>
> * 概念
>   * 为每个进程提供了一个大的、一致的、私有的地址空间
>   * 是对主存的一种抽象概念
> * 功能
>   * 将主存看作是一个存储在硬盘上的地址空间的高速缓存
>   * 为每个进程提供一致的地址空间
>   * 保护每个进程的地址空间不被其他进程破坏
> * 为什么要学习虚拟内存
>   * 硬件异常、汇编器、链接器、加载器、共享对象、文件、进程的设计中都离不开虚拟内存
>   * 虚拟内存系统可以创建和销毁内存片，将内存片映射到磁盘文件的某个部分，以及与进程共享内存
>   * 虚拟内存想系统是危险的，使用不当容易出错
>
> ### 早期内存管理
>
> * 早期程序员
>   * 需要自己手动管理内存
>   * 此程序占据分配那一段内存是在程序员自己定的
>   * 程序源代码中还包含大量内存换进换出的复杂代码
>
> * 向虚拟演化
>   * 鉴于上面的情况
>   * 开始把程序写在虚拟地址空间，而程序实际跑在物理主存空间
>   * 由此就有一个虚拟到实际的映射
>
> ### 早期分页管理
>
> * 虚拟地址空间
>   * 程序写在此虚拟地址空间上
>   * 又叫做逻辑地址空间
>   * 内存存储在最慢的磁盘上
>   * 假设此虚拟地址空间有16位。即容量为64KB
>
> * 物理地址空间
>   * 就是主存地址空间
>   * 但此主存容量较小，地址空间只有12位。即容量为4KB
>
> * 分页实现准备
>   * 设页大小为4KB
>   * 这样虚拟地址空间总容量为16个页大小
>
> * 0 - 4096-1访问
>   * 此时把逻辑地址空间0 - 4096-1 从硬盘调入主存中
>   * 开始一一对应访问
>
> * 4096- - 8192-1访问
>   * 此时把逻辑地址空间4096 - 8192-1 从硬盘调入主存中
>   * 4096对应物理地址0，8192-1对应物理地址4096-1
>
> * 名词由来
>   * 把此固定的区间称为页
>   * 把主存中存放页的区域称为页框，早期主存只有一个页框，即4KB
>
> ### 现代分页思想
>
> * 分页思想
>   * 主存物理空间被分成页 —— 实页
>   * 进程逻辑空间也被划分成页 ——虚页
>   * 虚页可以装入实页中
>   * 很多个连续的虚页在主存中可以不连续，可以进行离散
>   * 操作系统为每个进程都生成一个页表
>   * 通过这个页表就能实现虚拟地址空间向物理地址空间的映射
>
> * 特点
>   * 无论是虚页还是实页，页内偏移不变。因为它们的页大小及各种特点都是一样的
>
> ### 物理和虚拟寻址
>
> * 物理寻址
>   * CPU直接请求物理地址，在内存数组上取内容
>
> * 虚拟寻址
>   * CPU请求一个虚拟地址
>   * 虚拟地址通过`MMU`(CPU中的内存管理单元硬件)映射翻译成物理地址
>   * 根据翻译而来的物理地址去物理空间寻找
>
> ### 基本思想与实质
>
> * 基本思想
>   * 地址空间区分了数据对象(字节)和它们的属性(地址)
>   * 有不同的地址空间，同一个数据对象就能有多个属性(地址)
>   * 主存中的每个字节都有一个来源于虚拟地址空间的虚拟地址和一个来源于实际物理空间的物理地址
>
> * 实质
>   * 允许程序员在一个很大很大的逻辑虚拟地址空间中进行编程
>   * 实际执行时按需调入页，而不是全部装入
>   * 指令执行时进行两种地址的翻译
>   * 发生缺页时由操作系统来处理
>
> ### 虚拟页的三种状态
>
> * 已缓存：即页已经缓存在主存上，需要时直接去主存读取就行
> * 未缓存：即页还在磁盘上，需要时会触发缺页异常，异常处理结束后就能去主存读取
> * 未分配：即未分配使用的内存
>
> ### 虚拟地址空间
>
> * 实际上就是顶层为内核代码，底层为不可用区域的那个结构
>
> ### 页表结构
>
> * 页表部分项
>   * 装入位 —— 1代表已经装入内存，0代表还在磁盘上未装入内存
>   * 修改位 —— 脏位，代表是否被修改。用于写回判断
>   * 实页号 —— 对应主存的页框号
>
> * 页表属性
>   * 对于32位系统而言，页大小为4KB，则32位地址空间有1MB项个页面
>   * 假定一个页项占4B，则页大小就是4MB。已经很大了
>   * 页表存在虚拟地址空间的内核区，每个进程都有自己的一个页表
>   * 访问页表也需要分页，简直就是套娃
>
> * 页表项状态
>   * 未分配页 —— 就是虚拟地址空间中的空页，啥内容都没有
>   * 已分配的缓存页 —— 主存已装入的页
>   * 已分配未缓存页 —— 主存未装入的页
>
> ### 地址转化
>
> * 准备概念
>   * 页表存放位置 ——**主存**中
>   * 页表的地址 —— 页基址寄存器
>   * 虚拟地址结构 —— 页表索引 + 页内偏移
>   * 物理地址结构 —— 物理页框索引 + 页内偏移
>
> * 访问过程
>   * 页基址寄存器 + 页表索引*页表项大小得到对应的页表项
>   * 检查是否已经装入主存，如果装入则执行下面操作
>   * 将虚拟地址中的页表索引替换成页表项中的物理页框号得到物理地址
>   * 根据物理地址进行实际访问
>
> * 可能出现的问题
>   * 缺页
>   * 页表项中明确此页禁止写入但执行写入操作发生保护违例
>
> * 缺页处理
>   * 触发缺页异常，调用内核中的异常处理程序
>   * 异常处理程序返回，重新启动导致缺页的指令
>   * 正常执行
>
> * 保护违例成处理
>   * 直接终止进程
>
> ### 局部性
>
> * 缺页不影响整体情况是因为局部性
> * 但是如果程序性能慢得像乌龟在爬一样，就可以考虑是不是出现了抖动
>
> ### 虚拟内存优势
>
> * 简化链接
>
>   * 虚拟地址空间结构是一致的，是独立于物理内存的
>   * 因此一致的虚拟地址结构可以简化链接
>
> * 简化加载
>
>   * 加载的时候从来不会从磁盘复制内容到内存
>   * 都是初始化页表，把页表全标记为未缓存
>   * 这样程序执行时会自动因为页表不命中而加载
>
> * 简化共享
>
>   * 不同进程的页表的项指向同一个物理页就实现了共享
>
> * 简化内存分配
>
>   * 内存分配就是在虚拟地址空间中无效根本未用的连续分配虚拟页
>   * 分配连续的k个页面，但实际物理内存上这些页可以不连续
>
> * 保护内存
>
>   * 通过在页表项中添加属性就能实现保护内存读写
>
>     | name  | function             |
>     | ----- | -------------------- |
>     | SUP   | 是否只有内核才能访问 |
>     | READ  | 是否可读             |
>     | WRITE | 是否可写             |
>
> ### 无TLB访问过程
>
> * 通过虚拟页号`VPN` + 页表基址寄存器就可以知道页表项
> * 页表项直接有或者缺页处理后从页表项中获取物理页号
> * 物理页号 + 虚拟页偏移量就是最后的物理地址
>
> ### TLB
>
> * 产生原因
>   * 为了减少访问主存的次数，因为访问页表实际上就是访问主存 
>   * 相当于是主存中整个4M大的页表的一个子集
> * TLB结构
>   * Tag —— 标记
>   * 页框号 —— 主存中的页框号
> * TLB下虚拟页号结构
>   * VPN = TLB tag + TLB index
>   * 如果TLB不命中就整个VPN去访问页表
> * 全相联TLB访问过程
>   * 首先将虚拟地址的tag和TLB所有tag比较
>   * 如果有一样的就直接取出页框号拼出物理地址
>   * 如果没有就去主存中的页表找
>
> ### 整个存储访问过程
>
> * 最好情况
>   * CPU请求一个虚拟地址
>   * 去TLB中查，命中，得到物理地址
>   * 根据物理地址去Cache中找，命中，得到实际内容
> * 次好情况
>   * CPU请求一个虚拟地址
>   * 去TLB中查，失败
>   * 去页表中查，命中，得到物理地址
>   * 根据物理地址去Cache中找，命中，得到实际内容
> * 最坏情况
>   * CPU请求一个虚拟地址
>   * 去TLB中查，失败
>   * 去页表中查，失败
>   * 缺页
> * 注意
>   * 上述情况未讨论cache缺失未命中的情况
> * TLB组相联虚拟地址结构
>   * tag
>   * index
>   * bias
>   * 其中tag + index肯定等于20位，bias是12位。index由组数决定
>
> ### 多级页表
>
> * 作用
>   * 32位系统页表就有4M大，更不要说64位的系统
>   * 每个进程都有一个页表常驻内存，内存开销太大
>
> * 实现
>   * 使用多级页表
>   * 首先一级页表每个项代表很大的空间
>   * 当一级页表某一项根本没被访问时，对应的低级页表根本不会出现
>
> * 结果
>   * 只有一级页表常驻内存，其他页表需要时才载入
>   * 一级页表为null未命中，那么二级页表根本不会存在
>
> ### 目前访问缓存结构
>
> * CPU —— 32位虚拟地址
> * TLB —— tag + index 相加肯定20位，index取决于组数
> * n级页表 —— 20位VPN
> * 主存 —— 一般小于32位物理地址
> * cache —— cache是主存的缓存，但这与虚拟内存系统无关的。它只负责如何在知道物理地址的前提下更快访问到主存内容
>
> ### Linux虚拟内存结构
>
> * 内核虚拟内存
>   * 每个进程不同 —— 页表，task，mm结构，内核栈
>   * 每个进程相同
>     * 物理内存
>     * 内核代码和数据
> * 进程虚拟内存
>   * 用户栈
>   * 共享库内存映射区域
>   * 运行时堆
>   * .bss
>   * .data
>   * .text
>
> ### linux虚拟内存系统
>
> * 内核区
>   * 包含内核代码和内核数据结构
>   * 通过所有进程虚拟内存映射到主存同一区域实现共享
> * 组织虚拟内存
>   * 通过一个数据结构：task_struct -> mm_struct -> vm_area_struct
>   * 其中vm_area_struct是一个链
>   * 链的每一个节点都代表虚拟内存的一个段
>   * 这样的组织方式就可以不用管那些根本没有用的虚拟内存以及段之间的空隙
> * 缺页异常处理步骤
>   * 虚拟地址是否合法？查找上面那一个链，但由于效率低，往往是建了一颗树来查
>   * 访问是否合法？判断读写权限
>   * 都没问题，就正常缺页处理
>
> ### 内存映射
>
> * 概述
>   * linux通过将虚拟内存的一个区域与磁盘上的一个对象关联起来，以初始化这个虚拟内存区域的内容，这个过程叫作内存映射
>
> * 核心
>   * 实质上是第一次访问缺页(已分配未缓存)时，该把硬盘那个位置的换入内存
>
> * 映射的两种对象
>   * linux普通文件的连续部分。比如可执行文件的某个区，它就是连续的
>   * linux匿名文件
>     * 匿名文件由内核创建，包含内容全是二进制零
>
> * 结果
>   * 一旦一个虚拟页被初始化了，它就在一个由内核维护的专门的交换文件中换来换去
>
> ### 再看共享对象
>
> * 共享对象是什么
>   * 虚拟内存系统提供的一种机制，能够简单高效的把程序和数据加载到内存中去
>   * 一个对象可以被映射到虚拟内存的一个区域，要么作为共享对象，要么作为私有对象
> * 共享对象
>   * 对对象进行的任何操作，在其他进程和磁盘上原始对象来说，都是可见的
>   * 不同进程虚拟内存映射到相同物理内存，物理内存上存放这共享对象
> * 私有对象
>   * 对对象的任何操作，对其他进程来说都是不可见的，而且不会反映在磁盘上的文件对象上
>   * 只不过在写操作时会触发写时赋值保护程序
> * 内核
>   * 共享文件的实现需要内核的参与和协作
>
> ### 写时复制
>
> * 如果一个对象至始至终都不会改变不会写，那么它是共享的还是私有的就无所谓
> * 最开始一个私有对象的全部页都标记为不可写
> * 当某一页需要写时，它会在物理内存中复制一模一样的页，然后让页表项指向这个新的页
> * 在把新的页标记成可写的，就可以做任何的修改了
> * 核心思想是写时复制+分页，即不用整个对象全部拷贝，而只需要拷贝需要写的页
>
> ### 在看fork函数
>
> * 执行过程
>   * 拷贝mm_struct、区域结构、页表的原样副本
>   * 将两个进程共享的页面设置成只可读
>   * 将区域结构标记设置成写时复制
>
> * 写时赋值核心思想
>   * 写前
>     * 两个进程虚拟内存的两个区域映射到物理内存的相同区域
>     * 区域结构被标记为写时复制
>   * 写时
>     * 假设进程2执行写操作
>     * 进程2所写的物理页面进行复制，复制一个副本到物理内存的其他区域
>     * 进程2的页表发生改变，进程1的页表不变
>     * 进程2执行写操作
>   * 写后
>     * 进程1虚拟内存映射的物理内存内容和原来是一样的
>     * 进程2虚拟内存映射的物理内存内容和原来不一样了
>
> * 核心
>   * fork完后子和父进程的虚拟空间，页表是完全一样的
>   * 正是因此写时赋值的机制才能让子进程发生改变，而父进程不变
>   * 写时复制为每个进程保持了私有地址空间的抽象概念
>
> ### 在看execv函数
>
> * 目的
>   * 用新进程替换当前进程
>
> * 删除用户区域
>   * 将虚拟地址空间中的用户栈、堆空间请求二进制零
>
> * 映射私有区域
>   * 代码、初始化数据映射成新进程可执行文件的代码数据部分
>   * 未初始化数据部分虚拟页面请求二进制零
>
> * 映射共享区域
>   * 映射动态链接的对象到共享区域
>
> * 设置PC
>   * 将PC设置成程序入口
>
> ### 管理虚拟内存函数
>
> * mmap函数
>   * 用户自己创建新的虚拟内存区域，并将自定义对象映射到新创建的虚拟内存区域中
>   * 它是`malloc`的底层实现，即可以用它来操控虚拟内存
> * munmap函数
>   * 删除虚拟内存的区域
>   * 它是`free`的底层实现
>
> ### 动态内存分配
>
> * 出现原因
>   * 封装`mmap`和`munmap`，使用更方便，移植性更高
> * 分配位置
>   * 进程虚拟空间的堆中
> * 管理者
>   * 动态内存分配器
> * 堆
>   * 初始化是请求二进制零
>   * 内核维护一个brk变量指向堆顶
> * 分配器工作
>   * 将堆视作一组大小不同的块集合
>   * 对这些块集合进行管理
> * 分配器种类
>   * 显式分配器 —— 类似maloc函数和free函数
>   * 隐式分配器 —— 类似gc
> * 使用动态分配原因
>   * 直到程序运行时，才知道某些数据结构的大小
>
> ### malloc函数和free函数
>
> * molloc实现方式
>   * 通过mmap和munmap函数
>   * 通过sbrk函数
>
> * sbrk实现原理
>   * 通过改变指向堆顶的指针变量brk的值来分配内存
>
> ### 分配器要求和目标
>
> * 要求
>   * 处理任意请求。只要满足时序关系，应用可以有任意的分配请求和释放请求序列
>   * 立即响应请求。不允许请求时做重新排列和缓冲请求
>   * 只使用堆。分配内存的地方只能使用堆，因为这样更利于拓展
>   * 对齐块。这样可以保存任何类型的数据对象
>   * 不修改已经分配的块。分配器只能操作空闲块，不允许使用压缩等手段操作已分配的块
> * 目标
>   * 吞吐率
>     * 指单位时间进行分配和释放操作的能力
>   * 内存利用率
>     * 指虚拟内存的空间利用率
>   * 关系
>     * 两者成常常是反比关系
>
> ### 垃圾收集机制
>
> * 可达图实现原理
>   * 将内存视作一个可达图
>   * 可达图的边由各种引用、全局声明等其他信息表明
>   * 图的一个结点就是一个已分配的内存块
>   * 当可达时不是垃圾，不可达时是垃圾
>
> * 不同语言区别
>   * java这种语言能够精确表达可达，因而垃圾回收机制强
>   * 而c、c++原因不能精确表示，因而垃圾回收机制弱
>
> * Mark & Sweep实现原理
>   * 标记过程从根节点递归标记所有可达已分配的后继
>   * 清楚过程就清除未被标记的垃圾块
>
> ### 常见内存错误
>
> * 引用坏指针
>   * 引用到虚拟地址空间中没有映射到任何物理内存的页
>   * 引用到只读页但进行写操作
>   * 举例 —— scanf函数传整数的地址结果传成了整数而导致引用坏指针
>
> * 读未初始化内存
>   * 堆内存分配后未进行初始化，不能默认堆内存初始化为0，要手动进行初始化
>
> * 假设指针和它指向对象是相同大小
>
> ```c
> int**a = (int**)malloc(n*sizeof(int)); //此写法错误，应改成下面写法
> int**a = (int**)malloc(n*sizeof(int *));
> ```
>
> * 误解指针运算
>   * 指针运算的大小是它指向的对象而不是字节
>
> * 引用不存在的变量
>   * 变量未被初始化未分配内存就引用它的地址
>
> * 内存泄漏
>   * malloc了内存过后却不释放，导致堆空间溢出
>
> ***

## 第十章

> ### 什么是IO
>
> * I
>   * 代表输入，从IO设备复制数据到主存
>
> * O
>   * 代表输出，从主存复制数据到IO设备
>
> ### 为什么要学习IO
>
> * 了解IO能更好了解其他系统概念
> * 有时除了UnixIO外别无选择，比如或许文件元数据
>
> ### 一致性的IO方式
>
> * 打开文件
>   * 内核返回一个小的非负整数，称为文件描述符
>   * 内核记录有关这个打开文件的信息
>   * 应用程序只需要记住描述符
> * 每个进程都有3个打开的文件
>   * 0 —— 标准输入
>   * 1 —— 标准输出
>   * 2 —— 标准错误
>
> * 改变文件位置
>   * 内核保持着每个文件的位置k，相当于光标
>   * k初始为0
>   * 应用程序通过seek操作显示改变文件位置k
>
> * 读写文件
>   * 从当前位置k开始复制出或者复制入主存
>   * 读文件会触发EOF
>
> * 关闭文件
>   * 内核释放打开文件而创建的数据结构
>   * 把文件描述符归还到文件描述符成池
>   * 无论进程因何终止，最终都会释放关闭所有文件
>
> ### 文件
>
> * 普通文件
>   * 分为文本文件和二进制文件，但内核不区分这两种文件
>   * 文本文件的换行符是`\n`，一个ASCII码
>
> * 目录文件
>   * 目录文件实际上是包含一组链接的文件
>   * 每个链接都将一个文件名映射到一个文件或者文件夹
>   * `.`是目录到自身的链接
>   * `.`.是目录到父目录的链接
>
> * 套接字文件
>   * 用来与另一个进程进行跨网络通信的文件
>
> * 其他文件
>   * 如通道、链接、字符、块设备等
>
> ### 打开和关闭文件
>
> * 打开文件
>
>   ```c
>   int open(char *filename, int flags, mode_t mode)
>   ```
>
>   * 打开一个已存在的文件，或者创建一个新的文件
>   * 将filename转换为文件描述符并返回文件描述符。返回的文件描述符总是在进程没有打开的最小描述符
>
> * 关闭文件
>
>   ```c
>   int close(int fd)
>   ```
>
>   * 关闭一个已经关闭的文件会出错
>
> * 读文件
>
>   ```c
>   ssize_t read(int fd, void *buf, size_t n);
>   ```
>
>   * 从文件描述符为fd的文件当前位置复制**最多**n个字节内容到内存buf位置	
>
> * 写文件
>
>   ```c
>   ssize_t write(int fd, const void *buf, size_t n)
>   ```
>
>   * 从内存buf处复制**最多**n个字节内容到文件描述符为fd的文件的当前位置
>
> * 检索文件元数据
>
>   ```c
>   int stat(const char *filename, struct stat *buf);
>   int fstat(int fd,struct *buf);
>   ```
>
>   * 返回的元数据是`state`，它是一个比较复杂的数据结构
>
> * 文件夹
>
>   * 打开文件夹
>
>   ```c
>   DIR *opendir(const char *name);
>   ```
>
>   * 读取文件夹
>
>   ```c
>   struct dirent *readdir(DIR *dirp);
>   ```
>
>   * 关闭文件夹
>
>   ```c
>   int closedir(DIR *dirp);
>   ```
>
> ### 三个数据结构
>
> * 描述符表
>   * 每个进程都有自己的描述符表，即进程独有
> * 文件表
>   * 所有文件共享
>   * 表项包括
>     * 当前文件位置
>     * 引用计数器
>     * 指向`v-node`表的对应指针
> * v-node表
>   * 所有进程共享
>   * 包括`stat`结构中的大部分信息
>
> ### 共享文件
>
> * 一进程两次open相同文件
>   * 会有两个文件描述符
>   * 文件表会创建两项，如果没有其他引用则它们的引用计数都是1
>   * 文件表项的`文件位置`可以不同，通过不同的文件描述符操作不同的文件位置
>   * 但`v-node`节点只有一个
> * `fork`共享文件
>   * 子进程拷贝了一份一模一样的描述符表，这个表中所有表项指向的文件表项和父进程完全相同
>   * 等于就是把指针复制了一份
>
> ### 重定向
>
> * 允许用户将磁盘文件和标准输入输出联系起来
> * 可以通过`dup2`函数来实现
>
> ### IO选择使用
>
> * 只要有可能就用封装好的标准IO，不要用Unix IO
> * 不要用`scanf`这些函数来读二进制文件
> * 对网络套接字要使用`RIO`函数
>
> ***

## 第十一章

> ### 概述
>
> * 所有的网路应用都是基于相同的基本编程模式，有着相似的整体逻辑结构，并且依赖相同的编程接口
> * 一个应用都是由一个服务器进程和一个或者多个客户端进程组成的。注意核心单位是**进程**
>
> ### 网络
>
> * 对主机而言，网络只是一种IO设备，是数据源和数据的接收方。数据在网络和内存之间来回进行复制
>
> ### 协议
>
> * 原因
>   * 如何让采用完全不同和不兼容技术的各种局域网联系起来？
> * 协议的两种能力
>   * 命名机制 —— 定义一种一致的主机地址来消除地址定位方面的差异
>   * 传送机制 —— 定义一种把数据位捆扎成不连续的片的同一方式来消除编码差异
>
> ### 主机层次，由高到低
>
> * 客户端 —— 即用户代码
> * 套接字接口 —— 一类系统调用
> * TCP/IP实现 —— 内核，即操作系统
> * 硬件接口 —— 中断
> * 网络适配器 —— 硬件
> * 网络
>
> ### 因特网连接
>
> * 特点
>   * 点对点 —— 连接是一进程到一进程
>   * 全双工 —— 数据可以双向流动
>   * 可靠的 —— 发出基本都能接收
> * 连接的端点
>   * 一个套接字
>   * 每个套接字有对应的地址，由`地址:端口`组成
>   * 一个连接是由它两端的套接字唯一确定的，叫做`套接字对`
>
> ### 套接字
>
> * 是一套编程接口，具体实现由操作系统完成，我们只管调用
> * 从内核来看，一个套接字是通信的一个断点；从程序角度看，套接字是一个具有相应描述符的打开文件
>
> ### 套接字接口
>
> * socket函数
>
>   ```c
>   int socket(int domain, int type, int protocol)
>   ```
>
>   * 作用
>     * 客户端和服务端使用此函数创建一个套接字描述符
>   * 特点
>     * 此时返回的描述符套接字仅仅是部分打开，还不能进行读写。如何完成打开的全部工作，取决于我们是客户端还是服务端
>
> * connect函数
>
>   ```c
>   int connect(int clientfd, const struct socketaddr *addr, socklen_t addrlen);
>   ```
>
>   * 客户端通过调用`connect`函数来建立和服务器的连接
>   * 特点
>     * 尝试与套接字地址为`addr`的服务器建立连接
>     * 会阻塞，直到连接成功
>     * 如果成功，`clientfd`就可以进行读写了。因为创建好套接字时是不能进行读写的
>
> * bind函数
>
>   ```c
>   int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
>   ```
>
>   * 告诉内核将addr中的服务器套接字地址和套接字描述符sockfd联系起来
>
> * listen函数
>
>   ```c
>   int listen(int sockfd, int backlog);
>   ```
>
>   * 将sockfd从一个主动套接字转换成一个监听套接字，从此该套接字可以接受来自客户端的连接请求
>
> * accept函数
>
>   ```c
>   int accept(int listenfd, struct sockaddr *addr, int *addrlen);
>   ```
>
>   * 等待来自客户端的连接请求到达监听描述符listenfd，然后再addr中填写客户端的套接字地址，返回一个已连接的套接字描述符，这个描述符可被用来利用Unix IO函数与客户端通信
>   * 监听描述符
>     * 是作为客户端连接请求的一个端点
>     * 被创建一次
>     * 存在于服务器的整个生命周期
>   * 已连接描述符
>     * 已经建立起来的连接的一个端点
>     * 每次请求连接成功时服务器都会创建一个
>     * 只存在于这一次的连接
>
> ### 主机和服务的转换
>
> * `getaddrinfo, getnameinfo`实现二进制套接字地址结构的主机名、主机地址、服务名和端口号的字符串表示之间的互相转化
>
> ### 套接字接口辅助函数
>
> * 概述
>   * 上面的那些函数看起来有点复杂和可怕
>   * 但没有关系，有高级的封装函数
>   
> * open_clientfd
>
>   ```c
>   int open_clientfd(char *hostname, char *port)
>   ```
>
> * open_listenfd
>
>   ```c
>   int open_listenfd(char *port)
>   ```
>
> ### EOF
>
> * 当一个进程关闭连接它的那一断时，会发生EOF
> * 当连接另一端的进程尝试读取流中最后一个字节时，会检测到EOF
>
> ### Web Server程序实战
>
> * 太复杂了，下次一定看
>
> ***

## 作业

> ### 2.55
>
> ```c
> #include<stdio.h>
> 
> typedef unsigned char* byte_pointer; //typedef不用加#，且末尾必须要加分号
> 
> void main(){
> int x=0x00323130;
> show_int(x);
> }
> 
> /*要打印每个字节只能使用char指针，因为只有它每偏移一位是一个字节*/
> void show_bytes(const char *s,size_t length){
> size_t i=0;
> for(i;i<length;i++){
> 	//'%.2x'表示输出十六进制且高位为0保留
> printf("%.2x ",s[i]);
> }
> printf("\n");
> 	/*字符串结尾字节以0结束，0x00323130的位表示可以解释成字符串，恰好是012*/
> printf("output by char*:  %s\n",s); 
> }
> 
> void show_int(int x){
> 	//转换成char*指针就可以按照字节读取
> show_bytes((const char *)(&x),sizeof(int));
> }
> 
> ```
>
> ### 2.58
>
> ```c
> #include<stdio.h>
> 
> void main(){
> is_little_end();
> }
> 
> void is_little_end(){
> int x=1;
> const char first_byte=*((const char *)(&x));
> //C语言不支持bool类型，C++才支持，就离谱
> if(first_byte!=0)
> printf("is little end: true");
> else
> printf("is little end: false");
> printf("\n");
> }
> ```
>
> ### 2.59
>
> ```c
> #include<stdio.h>
> 
> void main(){
> int x=0x89ABCDEF;
> int y=0x76543210;
> printf("%x",swap((const char *)&x,(char *)&y));
> printf("\n");
> }
> 
> //因为要在函数内部修改指针指向的值，因此y不能是const
> int swap(const char *x,char *y){
> *y=*x;
> return *((const int *)y);
> }
> ```
>
>************

## 上课

> ### 一些反常的现象
>
> * `x*x`当发生越界时有可能会小于零
> * **1e20+(-1e20+3.14)**=0
>
> ### 内存溢出错误案例
>
> * 当对struct_s的a[2]进行赋值时会影响b的正确值
>
> * 但当对a[4]及以上赋值时不会错误，因为双精度的double占8字节
>
>   ```c++
>   typedef struct{
>       int a[2];
>       double b;
>   } struct_s
>   ```
>
> ### 练习中的各种意想不到的错误
>
> * for循环不能使用**unsigned**作为迭代值，当unsigned为0时减1会变最大
>
> * 字符串末尾有**\0**，因此字符串的内存占用比**char c[strlen(str)]**大
>
> * 在函数体内声明的**内存指针**不能作为返回值的内存指针，因为函数结束后会进行回收。
>
> * 进行宏定义容易出现注入问题
>
>   ```c++
>   #define IS_GREATER(a,b) a>b
>   ```
>
> ### 实用写法
>
> ```c++
> p && *p  //可以防止p空指针
> a && 5/a  //可以防止除数为零
> ```
>
> ### signed和unsigned的最大最小值
>
> |          | 最大值            | 最小值            |
> | -------- | ----------------- | ----------------- |
> | unsigned | 11111111 11111111 | 00000000 00000000 |
> | signed   | 01111111 11111111 | 10000000 0000000  |
>
> ### 转换规则
>
> * signed会隐试转化为unsigned
>
> ***

## 代码bug和笔记

> ### 指针使用
>
> ```c
> #include<stdio.h>
> void main(){
> 	//指针必须分配内存后才能使用，指针的声明是不知道它指向那里的
> int *x=(int *)malloc(4);
> *x=3;
> printf("%d\n",*x);
> }
> ```
>
> ### 引入.h文件
>
> ```c++
> #include<stdio.h>
> int main(){
> printf("Hello World");
> }
> ```
>
> * 必须引入 stdio.h 头文件有printf的定义才能进行重定向绑定
>
>***************

