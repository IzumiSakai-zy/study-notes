# 系统级程序设计

## 1第一次课

### 1.1 一些反常的现象

* x*x当发生越界时有可能会小于零
* **1e20+(-1e20+3.14)**=0

### 1.2 内存溢出错误案例

* 当对struct_s的a[2]进行赋值时会影响b的正确值
* 但当对a[4]及以上赋值时不会错误，因为双精度的double占8字节

```c
typedef struct{
    int a[2];
    double b;
} struct_s
```

### 1.3 练习中的各种意想不到的错误

* for循环不能使用 **unsigned** 作为迭代值，当unsigned为0时减1会变最大

* 字符串末尾有 **\0** ，因此字符串的内存占用比 **char c[strlen(str)]** 大

* 在函数体内声明的 **内存指针** 不能作为返回值的内存指针，因为函数结束后会进行回收。

* 进行宏定义容易出现注入问题

  ```C
  #define IS_GREATER(a,b) a>b
  ```

### 1.4 实用写法

```C
p && *p  //可以防止p空指针
a && 5/a  //可以防止除数为零
```

### 1.5 signed和unsigned的最大最小值

|          | 最大值            | 最小值            |
| -------- | ----------------- | ----------------- |
| unsigned | 11111111 11111111 | 00000000 00000000 |
| signed   | 01111111 11111111 | 10000000 0000000  |

### 1.6 转换规则

* signed会隐试转化为unsigned

*************************



## 第一章

> ### 1.1 信息就是位+上下文
>
> * 只由ASCII码组成的文件称为 **文本文件** ，其他所有文件都称为 **二进制文件** 。 hello.c就是一个文本文件
>
> ***************
>
> ### 1.2  程序被其他程序翻译成不同的格式
>
> * 预处理阶段
>
> > * 引入 **#<incloude>** 库
> > * 让hello.c文本文件变成另一个文本文件 **hello.i**
>
> * 编译阶段
>
> > * 将hello.i翻译成文本文件hello.s
> > * hello.s 是 **汇编** 文本文件
>
> * 汇编阶段
>
> > * 汇编器将hello.s翻译成机器语言指令，把这些指令打包成 **relocatable object program** ,把结果保存在hello.o中
> > * hello.o是一个二进制文件不是一个文本文件，用文本编辑器打开会乱码
>
> * 链接阶段
>
> > * hello程序调用了 **每个C编译器都提供的标准C库中print()函数**
> > * print() 函数存在于一个 **print.o** 的可重定位目标程序中
> > * 链接器要将 **print.o和hello.o** 两个 **可重定位目标程序** 合并
> > * 最后得到一个 **hello.out或hello** 文件
> > * 这是一个可执行文件
>
> *****************
>
> ### 1.4.1系统的硬件组成
>
> * 总线
>
> > * 在各个部件中传输 **字**
> > * 字中的位数( **字长** )是一个系统的重要参数
> > * 4字长就是32位，8字长就是64位
>
> * CPU
>
> > * 寄存器的大小就是这个系统 **字** 的大小，也是 **系统总线** 传输数据单元的大小
>
> *******************
>
> ### 1.4.2运行hello程序
>
> * 键盘输入通过总线传输到寄存器，寄存器把输入传输内存总线传输到内存
> * 回车输入结束后通过DMA将磁盘上的程序文件通过总线直接加载入内存
> * CPU执行程序的机器语言指令，将输出字符串从主存复制到寄存器文件，在从寄存器复制到输出设备
>
> ****************
>
> ### 1.5高速缓存至关重要
>
> * 缓存原理——程序的局部性原理
>
> *****************
>
> ### 1.7操作系统管理硬件
>
> > * 所有应用程序对硬件的访问都必须通过 **操作系统**
> > * 操作系统通过向应用程序提供一些简单一致的 **接口** 来控制复杂而通常各不相同的低级硬件设备
> >
> > ***************
>
> > * 文件——**IO** 的抽象
> > * 虚拟内存 —— **主存和IO** 的抽象
> > * 进程 —— **处理器，主存，IO** 的抽象
> >
> > ****************
>
> ****************
>
> ### 1.7.1 进程
>
> * 进程是对一个 **正在运行的程序的一种抽象**
> * 正是因为有了进程的概念，每个程序才能感觉自己是在 **独占** 使用 CPU，主存和IO设备
> * 操作系统切换进程称为 **上下文切换**
> * **上下文** —— 保持跟踪进程运行所需的所有状态信息
> * shell程序执行hello程序涉及到两个进程，涉及进程的切换和控制权的转移
> * 操作系统内核
>
> > * 内核是操作系统代码常驻内存的部分
> > * 当涉及到 **系统调用** 时，将 **控制权** 转交给内核，内核操作完成后在归还控制权
> > * 内核不是一个独立的进程
> > * 内核是系统管理全部进程所有的代码和数据的集合
>
> *******************
>
> ### 1.7.2 线程
>
> * 一个进程可以由多个 **线程** 执行单元组成
> * 线程运行在进程的上下文中
> * 线程共享进程同样的代码和全局数据
> * 多线程比多进程更容易共享数据，也因此效率更高
>
> *******************
>
> ### 1.7.3虚拟内存
>
> * 虚拟内存为进程提供了一个假象 —— 每个进程都在独占地使用主存
> * 每个进程看到的主存都是一致的，称为 **虚拟地址空间**
> * 虚拟地址空间
>
> > * 每个进程看到的虚拟地址空间的结构是 **一模一样** 的
> > * 虚拟地址空间顶层是 **保存的操作系统代码数据** ，是不能动的
> > * 虚拟空间的底层是 **用户进程定义的代码和数据的**
> > * 虚拟地址空间结构(从低地址到高地址)
> >
> > > * 程序代码和数据——就是存放 **可执行目标文件**，示例就是 **hello.out或hello**
> > > * 堆——调用malloc或free标准库函数动态扩缩的部分
> > > * 共享库——存放C标准库和数学库这种共享代码和数据
> > > * 栈——位于用户虚拟地址空间的顶部，在顶部就是操作系统内核代码了，编译器用栈来实现函数调用
> > > * 内核虚拟内存——不允许读写，必须通过内核来执行
>
> ### 1.7.4 文件
>
> * **文件就是字节序列**
> * 每个IO设备都是文件
> * 文件最重要的作用是对所有IO都进行了一层抽象，屏蔽了所有的差异而提供了一些统一的接口
>
> ***************
>
> ### 1.9.1 Amdahl定律
>
> * 要想提高整个系统的速度，必须提升全系统中相当大部分的速度
> * 就是说单纯提高一部分的速度好几倍，结果它在整个程序中的占比并不大，最后整个系统速度的提升微乎其微
>
> ***************
>
> ### 1.9.2 并发和并行
>
> * 并发(concurrency)指一个同时具有多个活动的系统
> * 并行(parallelism)指的是通过并发来使一个系统运行得更快
> * 线程级并发
>
> > * 通常所说的一个 **核** 就是指一个CPU，八核就是指有8个CPU
> > * 多处理器系统——一个由 **单操作系统内核** 控制的多处理器组成的系统
> > * 高速缓存可以一个核(CPU)独占，也可以所有CPU共享
> > * 超线程(同时多线程)——一项允许一个CPU同时执行多个控制流的技术
> > * 超线程的CPU某些硬件有多个备份，比如PC和register，但其他硬件只有一份
> > * 超线程处理器可以在时钟周期时间内决定执行那个线程，线程切换几乎无感
>
> * 指令级并行
>
> > * 指同时执行多条指令
> > * 通过流水线方式执行指令
> > * 当执行指令效率超过 1 instruction per clock 时称为超标量处理器
>
> * 单指令，多数据并行
>
> > * 一条指令产生多个可以并行执行的操作
> > * 比如并行地对8对浮点数做加法
>
> *********************
>
> ### 1.9.3抽象
>
> * 文件——IO
> * 虚拟内存——IO、主存
> * 进程——IO、主存、处理器
> * 指令集架构——处理器
> * 虚拟机——IO、主存、处理器、**操作系统**

*********************



## 第二章

> ### 2.1.2 字数据大小
>
> * **字长** 决定了 **指针** 的大小，指针的大小决定了最大的寻址范围，因此 **字长决定了虚拟地址空间的大小**
> * 32位最大内存是4GB，64位最大内存是16EB
> * 32位和64位程序的区别——它们两者编译的方式不同。64位编译只能在64位机器上跑，32位编译就都可以跑
> * 在数据类型上，32位编译方式和64位编译方式的区别在 **long, double, char * ** 数据类型大小不同，其他类型数据大小都是相同的
> * 为了避免依赖编译方式，**int32_t , int64_t** 这种数据类型不随编译方式的不同而产生不同的结果
>
> *****************
>
> 
>
> ### 2.1.3 寻址和字节顺序(大小端)
>
> * 最 **低/高** 有效字节在最前面的方式成为 **小/大** 端法
> * 嘤忒尔使用小端法，即最低有效字节在最前面
> * 一般来说操作系统定下来字节顺序就固定下来了，安卓和iOS都使用小端法
>
> *******************
>
> 
>
> ### 2.2 整数表示
>
> * Java只支持有符号数，不支持无符号数
> * **uint32_t** 的实现原理是使用宏
> * 有符号和无符号的转换——**位不变，解释方法不同**
> * 有符号和无符号参与运算时，有符号数会向无符号转换
>
> ***************
>
> 
>
> ### 2.2.6数的扩展
>
> * 无符号整数使用 **零扩展**
> * 符号整数使用 **符号扩展**
> * 当同时涉及到 **扩展和类型转换时**，先扩展再类型转换
>
> **********************
>
> 
>
> ### 2.2.7数的截断
>
> * 直接截断，然后按位根据数据类型解释
>
> **************
>
> 
>
> ### 2.3 整数运算
>
> * 无符号加法： 舍弃高位，按无符号解释
> * 符号(补码)加法：舍弃高位，按符号补码解释
> * **补码的非： 就是求补码的相反数，最小值的非是它本身**
>
> ***************
>
> 
>
> ### 2.3.4整数乘法
>
> * 无符号乘法：直接乘，舍弃高位按无符号数解释
> * 补码乘法：首先解释成十进制，按十进制乘在转换为二进制，舍高位按照补码解释
> * **特点：无符号乘法和补码乘法最后舍弃后的位表示是一模一样的**
>
> **************************************
>
> 
>
> ### 2.3.7 除以二的幂
>
> * **高位要进行符号扩展**
> * 不进行任何处理是 **向下舍入**
> * 加上 **偏置** 后是 **向零舍入**，偏置=(1<<k) - 1
>
> **********************
>
> 
>
> ### 2.4.2 IEEE浮点数表示
>
> * 尾数 **23位** 和 **52** 位
> * **Bias值为 (1<<k-1)-1**
>
> ****************







## 第三章

> ### 引言
>
> * 汇编代码是 **机器代码的文本表示形式**
> * GCC调用汇编器和链接器，根据 **汇编代码** 生成可执行的 **机器代码**
> * 汇编代码与CPU指令集耦合，而高级语言不耦合
>
> ****************
>
> 
>
> ### 3.2程序编码
>
> * 机器代码分为两种
>
> > * 目标代码：由汇编器生成，包含所有指令的二进制表示，但还没有填入全局值的地址
> > * 可执行代码：由链接器生成，是处理器执行的代码格式
>
> ******************
>
> 
>
> ### 3.2.1机器级编码
>
> * 两种抽象
>
> > * 指令集架构ISA抽象
> > * 虚拟内存抽象
>
> * 汇编代码就是机器代码可读性更好的文本表示
> * 汇编代码 **不区分有符号，无符号，指针类型，甚至不区分整数和指针**
> * x-86的虚拟内存使用64位寻址，但目前 **最高16位必须设置为0**，因此最大内存为64TB
> * 操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的 **物理地址**
>
> *****************
>
> 
>
> ### 3.2.2代码示例
>
> *  生成汇编的指令
>
> ```bash
> gcc -Og -S test.c
> # -Og 使用level0，不进行优化，不然和源代码差距太大
> # -S 只生成汇编文件，不进行链接生成可执行机器代码
> ```
>
> * 机器执行的程序只是一个 **字节序列** ，它是对一系列指令的编码。机器对产生这些指令的源代码几乎 **一无所知**
> * x-86的指令长度 **不统一** ，从1-15字节都有，**越常用指令越短**
> * x-86机器码类似于哈夫曼编码，是 **连续编码可唯一翻译的**
>
> *******************
>
> 
>
> ### 编译指令
>
> * 预处理
>
>   ```bash
>   gcc -E hello.c -o hello.i
>   ```
>
> * 编译
>
>   ```bash
>   gcc -S hello.c -o hello.s
>   ```
>
> * 汇编
>
>   ```bash
>   gcc -c hello.c -o hello.o
>   ```
>
> * 链接
>
>   ```bash
>   gcc hello.c -o hello.out
>   ```
>
> **************
>
> 
>
> ### 3.2.3关于格式的注解
>
> * 编译产生的汇编代码 **以 '.' 开头** 都是知道汇编器和链接器工作的伪指令
> * ATT与Intel汇编代码格式
>
> > * 两者格式不完全相同
> > * Intel版本代码更简略，省略 **%, q, l** 等
> > * **两者涉及多个操作数的情况下顺序是反的，很难顶**
> > * 在 **英特尔和微软** 的官方文档中常用 Intel 格式汇编代码
>
> ***********
>
> 
>
> ### C语言中嵌入汇编的两种方式
>
> * 编写完整函数，放入一个独立的汇编代码文件中，让汇编器和链接器把它和用C语言书写的代码合并起来
> * 使用gcc的内联汇编，在C中直接嵌入汇编代码
>
> **************
>
> 
>
> ### 3.3数据格式
>
> * 由于历史原因，Intel的字大小指 **16位2字节**
>
> * 后缀
>
>   ```bash
>   -b # 1字节，0.5字
>   -l # 4字节，双字
>   -q # 8字节，四字
>   -w # 2字节，一字
>   ```
>
> * 浮点数和整数使用的是 **一组完全不同的指令和寄存器**
>
> *********************
>
> 
>
> ### 3.4访问信息
>
> * 经过实际代码测试，x-86的指针大小为 **64** 位
>
> * 寄存器
>
>   ```bash
>   # 'r'代表64位，'e'代表32位，' '代表16位
>   -rax #返回值
>   -rbx #被调用者保存
>   -rcx #第四个参数
>   -rdx #第三个参数
>   -rsi #第二个参数
>   -rdi #第一个参数
>   -rbp #被调用者保存
>   -rsp #栈指针
>   ```
>
> ******************
>
> 
>
> ### 3.4.1 操作数指示符
>
> * 操作数种类
>
>   ```bash
>   '$0x123FEDB'     #立即数
>   '0x123FEDB'      #内存地址为立即数值的位置的值
>   '%rsp'           #寄存器值
>   '(%rsp)'         #内存地址为寄存器值的位置的值
>   '4(%rsp,%rdi,4)' #内存地址为 '4+%rsp+%rdi*4' 的位置的值
>   ```
>
>
>   ```
> 
> * 数据传送指令
> 
>   ```assembly
>   movzbl 4(%rsp,%rsi,4),%rax # movzbl表示从8位移动到32位，且使用零扩展
>   cltq # 与'movslq %eax,%rax'相同
>   ```
>
> * 压栈出栈指令
>
>   ```bash
>   # 栈结构特点：栈底地址最高，栈顶地址最低，压栈会使%rsp减少
>   ```
>
> * 算术指令
>
>   ```assembly
>   subq $0x8,%rsp # '%rsp = %rsp - 0x8'。后者为算术操作的第一个数
>   ```
>
> * 加载有效地址 **lea** 指令
>
>   ```assembly
>   movq 7(%rdx,%rdx,4),%rax # 指将内存地址为 '5*%rdx+7' 的值赋值给%rax
>   leap 7(%rdx,%rdx,4),%rax # 指将 '5*%rdx+7' 这个结果赋值给 %rax
>   ```
>
> * 移位指令
>
>   ```assembly
>   shr $0x4,%rdx # sh-shift, r-right 逻辑右移动
>   sar $0x4,%rdx # s-shift, a-arithmetic,r-right
>   ```
>
>   * 逻辑移位：直接移啥都不管
>   * 算数移位：要考虑负数补码符号位
>
> * 乘法指令 **128位**
>
>   ```assembly
>   imulq # 补码乘法
>   mulq  # 无符号数乘法
>
>   imulq %rdx # %rdx和%rax相乘，生成的128位结果高64位在%rdx，低64位在%rax
>   cqto  # 用于将%rdx设置成%rax的符号位，保证被除数符号统一
>   ```
>
>   * **mulq** 指令必须要求一个操作数位于 **%rax** ，和另一个操作数计算结果高位在%rdx，低位在%rax
>   * **divq** 指令将%rdx和%rax作被除数，操作数作除数，商在%rax，余数在%rdi
>
> ****************
>
> 
>
> ### 3.6.1条件码
>
> * 条件码种类
>
>   ```bash
>   -CF # 进位标志。检测无符号数溢出 
>   -ZF # 零标志。最近操作的结果是0
>   -SF # 符号标志。最近操作结果的符号位
>   -OF # 溢出标志。检测补码溢出
>   ```
>
> * 特性
>
> > * lea 指令不改变任何条件码，其他操作都要改变条件码
> > * cmp 指令相当于 sub 指令，区别是 cmp 只设置条件码
> > * test 指令相当于 and 指令，区别是 test 只设置条件码
>
> * set 指令
>
> > * 操作对象是寄存器的低8位字节，将一个字节设置成0或1
> > * ture和false的确定来源于各个条件码的组合计算
>
> * 跳转指令
>
> > * 无条件直接跳转：给出一个标志，如 'jmp L1'
> > * 无条件间接跳转：'jmp *%rsp' 或 'jmp *(%rsp)'
> > * 其他非 **jmp** 的跳转指令都是条件跳转，且条件跳转 **只能是直接跳转**
> > * PC相对寻址的PC值是 **跳转指令下一条指令的PC值** 而不是跳转指令本身的PC值
> > * **rep** 指令：插入在 **ret** 指令前面，防止直接跳转到ret
> > * 对于布尔值运算，**je** 代表是 **false**
>
> * 条件传送指令
>
> > * 特点：使用条件数据传送代码比条件控制转移代码效率更高，因为现代处理器是基于流水线的
> > * 格式：**cmov**
> > * 执行过程：处理器只读取数据，检查条件码，最后结果要么更新赋值要么保持不变。因此无论预测的结果如何都能保持流水线充满。等于是提前把所有分支结果都算出来
> > * 并不是所有的条件表达式都可以用条件传送来翻译
> > * 条件传送是否提高效率取决于用于额外计算浪费的时间和由于分支预测失误导致流水线爆炸浪费的时间谁更长
>
> *******************
>
> 
>
> ### 3.6.7循环
>
> * while 和 for 循环的两种翻译方法
>
> > * 跳转到中间策略
> > * guarded-do策略
>
> * switch 语句
>
> > * 跳转表
> >   * 本质是一个数组，数组存放的是每种情况跳转的地址
> >   * 跳转表执行开关语句的时间与开关数量无关
> >   * GCC当开关数量比较多，并且值跨度范围小就会使用跳转表

## 作业

> ### 2.55
>
> ```c
> #include<stdio.h>
> 
> typedef unsigned char* byte_pointer; //typedef不用加#，且末尾必须要加分号
> 
> void main(){
>      int x=0x00323130;
>      show_int(x);
> }
> 
> /*要打印每个字节只能使用char指针，因为只有它每偏移一位是一个字节*/
> void show_bytes(const char *s,size_t length){
>      size_t i=0;
>      for(i;i<length;i++){
>          	//'%.2x'表示输出十六进制且高位为0保留
>              printf("%.2x ",s[i]);
>      }
>      printf("\n");
>  	/*字符串结尾字节以0结束，0x00323130的位表示可以解释成字符串，恰好是012*/
>      printf("output by char*:  %s\n",s); 
> }
> 
> void show_int(int x){
>  	//转换成char*指针就可以按照字节读取
>      show_bytes((const char *)(&x),sizeof(int));
> }
> 
> ```
>
> ### 2.58
>
> ```c
> #include<stdio.h>
> 
> void main(){
>         is_little_end();
> }
> 
> void is_little_end(){
>         int x=1;
>         const char first_byte=*((const char *)(&x));
>         //C语言不支持bool类型，C++才支持，就离谱
>         if(first_byte!=0)
>                 printf("is little end: true");
>         else
>                 printf("is little end: false");
>         printf("\n");
> }
> ```
>
> ### 2.59
>
> ```c
> #include<stdio.h>
>   
> void main(){
>         int x=0x89ABCDEF;
>         int y=0x76543210;
>         printf("%x",swap((const char *)&x,(char *)&y));
>         printf("\n");
> }
> 
> //因为要在函数内部修改指针指向的值，因此y不能是const
> int swap(const char *x,char *y){
>         *y=*x;
>         return *((const int *)y);
> }
> ```

******************

## 代码bug和笔记

> ### 指针使用
>
> ```c
> #include<stdio.h>
> void main(){
>     	//指针必须分配内存后才能使用，指针的声明是不知道它指向那里的
>         int *x=(int *)malloc(4);
>         *x=3;
>         printf("%d\n",*x);
> }
> ```
>
> 