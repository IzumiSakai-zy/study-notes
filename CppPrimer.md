# Cpp Primer 笔记

## 第一章

> ### 1.1 编写一个简单的C++程序
>
> * int 类型是一种built-in类型
> * main函数的返回值一般被用来表示状态，0表示成功，非零返回值的含义由系统定义，通常用来指出错误类型
>
> *****
>
> ### 1.2 初识输入输出
>
> * 4个IO对象
>
> > * cin
> > * cout
> > * cerr
> > * clog
>
> * 输入输出运算符
>
> > * **<<** 和 **>>** 都是运算符；其中 **<<** 的左侧必须是一个 **ostream** 对象, **>>** 的左侧必须是一个 **istream** 对象
> > * 其中 **<<** 的运算结果是 **ostream** , **>>** 的运算结果是 **istream**
> > * `std::cout << "Hello World" << std::endl;` == `(std::cout << "Hello World") << std::endl;`
>
> * endl，内存缓冲区，物理屏幕
>
> > * **endl**是一个被称为 **操纵符** 的特殊值
> > * 未写入 **enl** 时内从全在缓冲区，写入 **endl** 时才刷新到屏幕物理设备
> > * 调试时debug日志应该实时刷新到屏幕，不然可能在缓冲区不显示出来影响问题定位
>
> ***
>
> ### 1.4 控制流
>
> * while
>
>   ```c++
>   int a = 0;
>   while (a <= 10) {
>     a++;
>   }
>   ```
>
> * for
>
>   ```c++
>   for (int i = 0;i <= 10;i++) {
>     
>   }
>   ```
>
> * if
>
>   ```c++
>   if (i > 0) {
>     
>   }
>   ```
>
> * 流作为判断条件
>
> > * `int value = 0; while (std::cin >> value)`
> >
> > * 当输入流有效时为true，当遇到文件结束符或者非整数时会返回false
>
> * 测试cin 和 cout
>
>   ```c++
>   int value = 0;
>   std::cin >> value;
>   std::cout << value << " ";
>             
>   // when the input is "1 2 3 4 5", the output is "1 "
>   ```
>
>   ```c++
>   int value = 0;
>   while (std::cin >> value) {
>   	std::cout << value << " ";  
>   }
>             
>   // when the input is "1 2 3 4 5", the output is "1 2 3 4 5 "
>   ```
>
>   * 即`cin`会自动去匹配输入
>
> ### 术语
>
> * **头文件**：使类或其他名字的定义可以被多个程序使用的一种机制。程序通过#incude指令使用头文件
> * **库类型**：标准库定义的类型，如 **istream**
> * **操作符对象**：如 std::endl, 在读写流的时候用来 "操纵" 流本身
> * **标准库**：一个类型和函数的集合，每个C++编译器都必须支持
> * **类类型**：为了与C++内置类型区分开来，程序员自己定义的类被称为类类型
>
> ***

***

## 第二章

> ### 前序
>
> * 编程语言补充其基本特征的两种方式
>
> > * 赋予程序员自定义数据类型的权利
> > * 将一些有用的功能封装成库函数提供给程序员
> >
> > ***
>
> * 简单与复杂
>
> > * C++本身是一门简单的语言。它提供了一组内置基本类型，相应的运算符，几种程序控制流语句
> > * C++本身也复杂，程序员可以自定义各种复杂的数据结构
> >
> > ***
>
> ### 2.1基本内置类型
>
> * 类型位数：C++设计准则之一是尽可能贴近硬件。C++的算术类型必须尽可能满足各种硬件特质。因此C++内置算术类型在不同的硬件上有不同的解释。具体多少位往往也是不能确定，不像Java一样可以确定
>
> * 算术类型
>
> > * bool类型:**bool**
> >
> > * char类型：**char**, **wchar_t**, **char16_t**, **char32_t**
> >
> > * 整数类型：**short**, **int**, **long**, **long long**
> >
> > * 浮点类型: **float**, **double**, **long double**
> >
> > ***
>
> * 是否带符号
>
> > * **int, long, short** 默认带符号
> > * **char** 是否带类型由机器硬件决定
> >
> > ***
>
> * 查看位数代码
>
> ```c++
> #include<iostream>
> int main(){
>         int value = 1;
>         int length = sizeof(value);
>         int realShiftLength = 0;
>         for (int i = length - 1;i >= 0;i--) {
>                 for (int j = 7; j >= 0;j--) {
>                         realShiftLength = (i << 3) + j;
>                         if(((value >> realShiftLength) & 0x01) == 1){
>                                 std::cout << "1 ";
>                         } else {
>                                 std::cout << "0 ";
>                         }
>                 }
>                 std::cout << "\n";
>         }
>         return 0;
> }
> ```
>
> * x86-64硬件平台实际测试位长结果
>
> | 类型        | X86-64平台长度 |
> | ----------- | -------------- |
> | bool        | 8              |
> | char        | 8              |
> | wchar_t     | 32             |
> | char16_t    | 16             |
> | char32_t    | 16             |
> | short       | 16             |
> | int         | 32             |
> | long        | 64             |
> | long long   | 64             |
> | float       | 32             |
> | double      | 64             |
> | long double | 128            |
>
> * 移植性：如果默认 **int** 是固定位数的话，就可能换到其他硬件无法兼容运行
>
> * 数字的字面值
>
> > * 定义：`24`, `024`,`0x24` `3.14159`这样的值被称为字面值
> > * 十进制字面值的类型是`int, long, long long`中能容纳最小的那一个
> > * 八进制，十六进制的字面值类型是`int, unsigned int, long, unsigned long, long long, unsigned long long`中能够容纳最小的那一个
> > * 小数的字面值类型是`double`
> >
> > ***
>
> * 字符与字符串字面值
>
> > * `sizeof('a') = 1`
> > * `sizeof("a") = 2`
> >
> > ***
>
> * 其他字面值
>
> > * `true, false` 的字面值类型是`bool`
> > * `nullptr`的字面值类型是`指针`
> >
> > ***
>
> ### 2.2 变量
>
> * 初始化与赋值
>
> > * C++中，初始化不等于赋值。虽然这两者的区别微乎其微
> > * 初始化的含义是创建变量是赋予一个初始值
> > * 赋值的含义是将原来的值擦除，用一个新值代替
> >
> > ***
>
> * 列表初始化
>
> > * C++ 11标准的新特性
> > * 使用花括号来进行初始化：`unsigned int value{100};`
> >
> > ***
>
> * 默认初始化
>
> > * 内置类型如果在函数外未初始化，则默认初始化未0
> > * 内置类型如果在函数体内未初始化，则 **不被初始化**，它的值是未定义的，对它访问可能出错。因此建议尽量初始化每个内置类型的值
> > * 类类型对象如果没有初始化，则其值有类定义决定
> >
> > ***
>
> * 声明与定义
>
> > * 声明：规定变量的名字和类型
> > * 定义：创建于名字相关联的实体
> > * 声明作用：让C++支持 **分离式编译** ，将声明与定义区分开来
> > * 声明可以多处声明，定义只能一次定义
> > * 声明语法：`extern int i;`
> > * 声明语句不能给声明的变量赋初始值，否则将抵消`extern`的作用而将声明变成定义
> >
> > ***
>
> ### 2.3指针
>
> * 引用
>
> > * 引用是对象的一个别名
> > * 引用一旦创建就和它的初始值牢牢绑定在一起了，因此引用必须有初始值，引用无法重新绑定到另一个对象
>
> * 指针字面值：空指针最好都赋值为`nullptr`，`int* p{nullptr};`
> * 指针判断：任何为0指针都是false，任何非0指针都是true。`int* p = nullptr; if(p) {}`
> * 指针比较：两个类型相同的指针可以做`==, !=`运算，指向的地址完全相同就返回true
> * `void*`指针：是一种特殊类型的指针，可以指向任何对象。但不能对对象做操作，因为不知道对象的类型
> * 数据类型和声明符
>
> > * `int`是数据类型，`*, &`是声明符
> > * 变量的定义包括了一个基本数据类型和一组声明符
> > * 正确写法：`int *p;`， 错误写法`int* p；`。 因为`*`仅仅是修饰了`p`而与`int`无关
> > * **从右往左读**：`int *&p;` `p` 是一个引用，一个指针的引用
> >
> > ***
>
> * const
>
> > * 声明：`const int i = 8;`
> > * 编译时：编译时会把常量直接做替换，因此编译时必须知道常量的值，即常量定义的值。
> > * 文件单独编译：但C++支持文件单独编译，如果一个常量在其他文件需要访问，则必须在那个文件进行定义，但这与一个变量只能定义一次的设定冲突。
> > * 默认文件内：因此C++默认常量的作用范围是文件内。如果多个文件同名的常量会被看作是不同的常量
> > * 手动修改：只需要在声明和定义的地方统统加上`extern`关键字。就能多文件使用常量了。
> > * 使用：A文件`extern const double d = 3.14`，B文件`extern const double d;`
> >
> > ***
>
> * 初始化和对const的引用
>
> > * 引用的类型必须和其所引用对象的类型一致。但在初始化常量引用的时候有例外
> > * `double value = 3.14; const int &i = value;` 合法。因为中途编译器会生成一个`const int temp = value;`，一般称为`临时量`
> >
> > ***
>
> * 对const的引用可能引用一个并非const的对象
>
> ```c++
> int i = 10;
> const int &p = i;
> std::cout << p << std::endl; // 输出10
> i = 0;
> std::cout << p << std::endl; // 输出0
> return 0;
> ```
>
> * 指针和const
>
> > * 指向常量的指针：`const int *p;`，指向的内容(内存地址存的值)是常量不可变，指针内容(内存地址)可以变
> >
> > ```c++
> > const int i = 10;
> > const int j = 20;
> > const int *p = &i;
> > std::cout << *p << std::endl; // 输出 10
> > p = &j;
> > std::cout << *p << std::endl; // 输出 20
> > ```
> >
> > * 常量指针：`int *const p;`,  指向的内容(内存地址存的值)是普通变量可以变，指针内容(内存地址)是常量不能变
> >
> > ```c++
> > int i = 10;
> > int j = 20;
> > int *const p = &i;
> > std::cout << *p << std::endl; // 输出 10
> > i = 0;
> > std::cout << *p << std::endl; // 输出 0
> > p = &j; // 编译报错
> > ```
> >
> > * 指向常量的常量指针：`const int *int p;`，指向的内容(内存地址存的值)是常量不能变，指针内容(内存地址)是常量不能变
> > * 怎么看：**从右往左读**
> > * 有无常量是有区别的：`const int *p; int *p1;`,其中`p, p1`是不同的类型，不能互相赋值。
> >
> > ```c++
> > int i = 20;
> > const int *p = &i; // 正确，可以把 int* 赋值给 const int*
> > const int j = 30;
> > p = &j; // 正确， const int* 当然可以赋值给 const int*
> > 
> > int k = 40;
> > int *p1 = &k; // 正确， int* 当然可以赋值给 int*
> > const int l = 50;
> > p1 = &l; // 编译错误， const int* 不能赋值给 int*
> > return 0;
> > ```
> >
> > ***
>
> * 常量表达式
>
> > * 定义：值不会改变，在编译期就能计算出值的表达式。
> >
> > * 举例：`const int i = get_size();`不是常量表达式，虽然它的值只赋值一次不会改变，但值到底是多少要到运行时才知道
> >
> > * `constexpr`关键字：一个表达式是不是常量表达式太难分辨了。用这个关键字告诉编译器这是一个常量表达式，如`constexpr const int i = 0;`
> >
> > * `constexpr`函数：这个关键字可以修饰函数，前提是函数的返回值能够在编译期算出来。举例如下：
> >
> >   ```c++
> >   //声明了一个constexpt函数
> >   constexpr int get_size() 
> >   {
> >           return 100;
> >   }
> >
> >   int main()
> >   {       
> >           constexpr const int i = get_size(); // 声明了一个constexpr变量
> >           std::cout << i << std::endl;
> >           return 0;
> >   }
> >   ```
> >
> > * 一般来说，只要认为想把某个表达式定义为常量表达式，就应该加上`constexpr`
> >
> > * `constexpr`与指针：指针必须是`nullptr, 0, 某个固定对象的固定地址`。比如定义在函数体之外的对象的地址是不变的
> >
> > ***
>
> ### 2.4 顶底const
>
> * 顶层const：表示这个变量本身是否是个常量
>
> ```c++
> const int i = 0;//这是一个顶层const
> int * const p = &j;//这是一个顶层const
> ```
>
> * 底层const：表示这个变量(一般是指针和引用)指向的内容是否是一个常量
>
> ```c++
> const int *p = &j;//这是一个底层const
> const int &i = k;
> ```
>
> ### 2.5 处理类型
>
> * 类型别名
>
> > * `typedef`
> >   * `typedef double d`，`d`是`double`的同义词
> >   * `typedef char *c`, `c`是 `char*`的同义词
> > * 意义理解不能错
> >
> > ```c++
> > typedef char *cp;
> > const cp ptr; // ptr是一个常量指针，指向 char。即 const (char *) ptr;
> > ```
> >
> > ***
>
> * auto
>
> > * 由编译器去分析表达式所属的类型
> > * `auto`定义的变量必须有初始值
> > * 顶层const常被忽略，因此要手动加顶层const。`const auto i = j;`
> >
> > ***
>
> * decltype
>
> > * 作用：选择并返回操作数的数据类型
> > * 返回类型包含顶层const
> > * `decltype(s.size()) count = 0;`。此时`count`的类型是`std::size_type`
>
> ### 2.6 自定义数据结构
>
> * 定义struct
>
>   ```c++
>   struct Book_info {
>     std::string name = "";
>     int publish_year{0};
>   };
>   ```
>
> * 头文件
>
> > * 头文件一般包含那些只能被定义一次的实体，如类，const和constexpr变量
> > * 头文件一旦改变，相关的源文件必须重新编译以获得更新后的声明
> >
> > ***
>
> * 预处理器
>
> > * 是程序在编译前执行的一段程序
> >
> > ```c++
> > #ifndef SALES_DATA_H  //一旦未真，则一直执行到#endif为止。一旦为假，立即跳过
> > #define SALES_DATA_H
> > #include<string>
> > struct Sales_data {
> > 	//...  
> > };
> > #endif
> > ```
> >
> > * 预处理变量如`SALES_DATA_H`无视C++语言中关于作用域的规则
> >
> > ***
>
> ### 小结
>
> * C++的基础内置类型是与实现它的硬件密切相关的
>
> ***

## 第三章

> ### 前言
>
> * 内置数组是一种更基础的类型，string和vector都是对它的某种抽象
>
> ### 3.1 using
>
> > * `using namespace std;`或者`using std::cout`
> > * 头文件不应该包含using声明，因为头文件会被复制拷贝到include它的文件中去。
> >
> > ***
>
> ### 3.2 string
>
> * 使用string
>
>   ```c++
>   #include<string>
>   using std::string;
>   ```
>
> * 拷贝初始化与直接初始化
>   * 拷贝：`std::string a = "Hello";`
>   * 直接：`std::string a("Hello");`
> * string操作
>
> > * `getline`: `while(getline(std::cin, a)){ std::count << a << std::endl;}`
> >
> > ***
>
> * std::size_type
>
> > * 是`a.size()`的返回值类型
> > * 是`string`库的配套类型。体现了标准库类型与机器无关的特性
> > * 实际上是`long unsinged int`
> > * 因此不要和`int`混着用， 不然有风险
> >
> > ***
>
> * 字面值和string相加
>
> > * 标准库允许把字符字面值和字符串字面值转化为string对象
> > * 为了兼容C，C++中的字符字面值并不是标准库类型string的对象
> >
> > ***
>
> * 使用C++版本的C标准头文件
>
> > * C++标准库除了定义C++语言自身的特有功能外，还兼容C语言的标准库
> > * C语言中`name.h`的头文件，在C++中是`cname`。因此`cctype`和`ctype.h`的内容是一样的
> > * C++语言应该使用`cctype`而不是`ctype.h`
> >
> > ***
>
> * 处理每个字符
>
> > * `for (const char s : "hello world") { std::cout << s << std::endl; }`
> > * 使用引用处理每个字符：`for (char &s : str) { s = '1'; };std::cout << str << std::endl;`。想要改变遍历的值必须设置为引用类型
> > * 下标运算符`[]`：接受的输入类型是`std::size_type`
> >
> > ***
>
> ### 3.3 vector
>
> * 标准库类型vector
>
> > * vector是一个类模版
> > * 使用：`vector<int> ivec = {1, 2, 3};  vector<int> ivec2(20);`
> > * `vector`是模版而非类型，`vector<int>`才是类型
> >
> > ***
>
> * 添加元素
>
> > * C++标准规定运行时向`vector`添加元素应该是很高效的
> > * 因此我们没有必要一开始指定`vector`的大小，这样做反而还可能使性能降低
> > * `vector<int> v; for (std::vector<int>::size_type i = 0; i < 100; i++) { v.push_back(i); }`
> > * 追加函数:`push_back()`
> > * 范围for循环语句不应该改变其遍历序列的大小
> > * 大小类型是：`std::vector<int>::size_type`
> > * `vector`和`string`只能通过下标访问已存在的元素，而不能使用下标来添加元素
> >
> > ***
>
> ### 3.4迭代器
>
> * 前言：C++标准库容器都支持迭代器，但不是所有的容器都支持下标运算符`[]`
>
> * 使用迭代器
>
> > * 有迭代器的类型同时拥有返回迭代器的成员
> > * `begin`：负责返回指向第一个元素的迭代器
> > * `end`：负责返回最后元素的下一个元素的迭代器，无实际作用，只是一个标记
> > * 如果容器为空，`begin`和`end`返回的迭代器相等
> >
> > ***
>
> * 运算符
>
> > * `*iter`：返回所指元素的引用
> > * `iter -> item`：相当于`(*item).item`
> > * `++item`：指向下一个元素
> > * `item1 == item2`：判断两个迭代器是否相等
> > * 迭代器实质：就只**指针**
> > * Java程序员for循环喜欢使用`<`，而C++程序员使用`!=`。本质原因是Java使用下标访问而C++使用迭代器访问，而且C++很多标准库容器压根不支持下标访问。
> > * `for (std::string::const_iterator iter = str.begin(); iter != str.end(); iter++){ std::cout << *iter << std::endl;}`
> >
> > ***
>
> * 迭代器类型
>
> > * 我们没必要知道迭代器的真正类型
> > * `std::string::iterator`是`string`的迭代器类型；`std::vector<int>::iterator`是`vector`的迭代器类型
> > * 迭代器分为可变和不可变。`std::string::iterator`可变，`std::string::const_iterator`不可变，相当于指向常量的指针
> >
> > ***
>
> * 迭代器含义
>
> > * 可能指迭代器这个概念本身
> > * 可能指某个容器定义的自身的迭代器类型
> > * 也可能指实际的某个迭代器对象
> >
> > ***
>
> * begin和end
>
> > * 如果是常量，`begin()`返回的是`const_iterator`类型；如果不是常量，`begin()`返回`iterator`类型
> > * `cbeing()`则永远返回`const_iterator`类型
> >
> > ***
>
> * 谨记
>
> > * 但凡使用了迭代器的循环，都不要向它里面添加元素。因为极有可能把迭代器整炸
> >
> > ***
>
> * 迭代器运算
>
> > * 就和指针运算差不多
> > * 迭代器相减：返回一个`difference_type`类型，每个容器都定义了这个类型
> > * 二分搜索
> >
> > ```c++
> > std::vector<int> vc;
> > auto begin = vc.begin(), end = vc.end();
> > auto mid = vc.begin() + (end - begin)/2;
> > int gold;
> > while (mid != end)
> > {
> >   if (gold == *mid)
> >   {
> >     break;
> >   } else if (gold < *mid)
> >   {
> >     end = mid;
> >   } else
> >   {
> >     begin = mid;
> >   }
> > 
> >   mid = begin + (end - begin) /2; 
> > }
> > ```
> >
> > ***
>
> ### 3.5数组
>
> * 前言
>
> > * 数组的大小固定不变，不能随意向数组中添加元素
> > * 如果不清楚数组的大小，请不要使用。转去使用`vector`
> >
> > ***
>
> * 定义和初始化内置数组
>
> > * 数组是一种复合类型，数组的大小也属于数组类型的一部分
> > * 数组的长度必须在编译时已知
> > * 数组的类型必须明确定义，不能`auto`
> >
> > ***
>
> * 字符数组特殊性
>
> > * `const char a[6] = "abcdef";` 错误写法，无空间来存放`\0`
> >
> > ***
>
> * 数组不允许拷贝和赋值
> * 复杂数组声明
>
> > * `int (*p)[10] = &arr`,`p`是一个指针，指向一个含有10个整数的数组
> > * `int (&r)[10] = arr`，`r`是一个引用，引用一个含有10个整数的数组
> > * `int *(&array)[10] = ptrs`, `array`是一个引用，引用一个数组，这个数组存放着10个指针
> > * 顺序：先括号里面，在右边数组符号，在从右到左。因为数组的维度是紧紧跟着被声明的名字的
> >
> > ***
>
> * 数组使用
>
> > * 数组除了大小固定外，其他用法和vector类似
> >
> > ***
>
> * 指针和数组和迭代器
>
> > * 使用数组的时候编译器会将其转换为指针
> > * `auto`数组的类型是指针；但`decltype`数组的类型是数组；
> > * 指针也是迭代器，但一个容量为10的数组手动执行`array[10]`获取尾迭代器很危险
> > * 在`iterator`中定义了两个函数来获取数组的迭代器。`begin(array), end(array)`
> >
> > ***
>
> * 指针运算
>
> > * 两个指针相减少，返回的是一个标准库类型`ptrdiff_t`，也是一种机器相关的类型
> >
> > ***
>
> * c风格字符串
>
> > * c和c++这两个语言就离谱。一个最基本的字符串都能搞出那么多名堂
> > * 使用C++就不推荐使用C风格的字符串，容易出问题和程序漏洞
> > * `strlen(str), strcmp(str, str), strcpy(str, str)`都是C风格字符串的函数，尽量不要用，除非是适配老程序
> >
> > ***
>
> * 两个语言字符串的区别
>
> > * c语言根本没有字符串这种类型，它全部使用字符数组，即`char*`类型，然后在末尾加一个`\0`作为结束符。而且c语言必须声明字符串的长度
> > * 而C++是一门面向对象的语言。字符串抽象封装成了`string`，它的长度是它的一个成员。因此按照道理来说它的字符串末尾可以不用加`\0`
> > * 但C++并未强制规定字段串的末尾是否需要加`\0`，这取决于编译器厂商的实现。一般编译器都加`\0`
> >
> > ***
>
> * 与旧代码的接口
>
> > * 允许使用c风格字符串来初始化string对象或为string对象负责
> > * 在string对象的加法运算中允许使用c风格字符串作为其中一个运算对象(不能两个都是)
> > * `c_str()`：将string对象转换为`const char*`，如`const char* str_ptr = str.c_str();`
> > * 现代C++程序员应多使用`vector, iterator, string`，少使用`c风格字符串, 内置数组, 指针`
> >
> > ***
>
> ### 3.6 多维数组
>
> * 初始化
>
>   ```c++
>   int array[3][4] = {
>     {1, 2, 3, 4},
>     {5, 6, 7, 8},
>     {9, 10, 11, 12}
>   };
>   ```
>
> * 遍历
>
> > ```c++
> > for(auto &row : ia) {
> >   for(auto &col : row) {
> >     //...
> >   }
> > }
> > ```
> >
> > * 范围for循环遍历除了最内层外都要将变量修改成引用。不然`auto`数组类型返回的是指针，无法进行下一层遍历
> >
> > ***

## 第四章

> ### 前言
>
> * C++允许用户自定义类类型运算符的含义，即运算符重载。如io库中`<<, >>`运算符，迭代器中操作的运算符等
>
> ### 4.1 基础
>
> * 左值右值
>
> > * 右值：用的是对象的值(对象的内容)
> > * 左值：用的是对象的身份(对象在内存中的地址)
> > * 赋值预算符左边需要一个左值，右边需要一个右值。返回结果是一个左值
> > * 取地址符`&`运算对象是一个左值，返回值是一个右值
> >
> > ***
>
> * 求值顺序
>
> > * `int i = f1() * f2();`。在这个表达式中`f1()`和`f2()`的执行顺序是不确定的
> > * `cout << i << "hello" << ++i << endl;`这条语句中`<<`运算符未规定如何求值。返回值是什么取决于编译器定义
> > * 规定了求值顺序的运算符：`&&、 ||、 ?:、 ,`
> > * 因此拿不准顺序的时候可以考虑加括号；或者如果改变了某个对象的值，在表达式其他地方就尽量不要使用到这个对象
> >
> > ***
>
> ### 4.2 算术运算符
>
> * `bool`转成`int`：`bool b = true; bool b2 = -b;`。首先将`b`从`bool`的`true`转成`int`的`1`，然后结果为`-1`，因为不等于`0`，所以从`int`的`-1`转换成`bool`的`true`
>
> ### 4.4 赋值运算符
>
> * 类类型的赋值运算符细节由类来决定，因为可以使用运算符重载
> * 右结合律：`i = j = 0;`，先算右边返回一个左值，在用这个左值赋值给`i`
>
> ### 4.5 ++和--
>
> * 除非必须，建议使用前置版本。因为后置版本编译器会临时存一个值，以便于返回这个未修改的内容，然而很多时候这个步骤都是多余的影响性能
> * `*ptr++`实际后置`++`运算符的顺序比`*`高。实际是先运算`ptr++`，但返回的却是原来的值，然后在对原来的这个值做解引用操作。
>
> ### 4.9 sizeof
>
> * 即使指针是无效的，也可以进行`sizeof()`运算，因为它不会实际运算指针的值
> * `sizeof`是右结合的
> * 对引用执行得到引用对象所占空间的大小
> * 对指针执行得到指针所占空间大小，一般是`8`
> * 对解引用指针得到的大小是指针指向对象所占的空间大小
> * 对数组执行是整个数组的大小，数组不会被转换成指针来处理
>
> ### 4.11 类型转换
>
> * 隐式类类型转换：类类型能够定义由编译器自动执行的转换。如字符串字面值转成`string`对象，`cin >> i`转换成`bool`
> * 显式转换
>
> > * 强制类型转换十分危险，它破坏了原本编译器的类型检查系统，每次使用都询问自己是否真有必要使用
> > * c++强转：`cast-name<type>(expresion)`.
> > * `static_cast`: 任何具有明确定义的类型转换，只要不包含底层const，都可以用。常用于高精度算术类型向低精度类型转换
> > * `const_cast`: 只能改变运算对象的底层const属性。常用于函数重载
> > * `reinterpret_cast`: 通常为运算对象的位模式提供较低层次的重新解释。最好不要用，很危险
> > * `dynamic_cast`: 运行时多态转换
> > * 旧风格转换：`type(expression)`,`(type)expression`。不推荐使用，如果这个转换能用`static_cast`和`const_cast`代替，就进行相应代替；否则就执行最危险的`reinterpet_cast`
> >
> > ***

## 第五章

> ### 5.1 简单语句
>
> * 单独一个分号也是一句语句，如`;`, 因此我们不能随意添加引号
>
> ### 5.4for语句
>
> * 范围for: 实际上是使用了迭代器`begin, end`
>
> ### 5.6 try-catch语句
>
> * 抛出异常：`throw std::runtime_error("error exception");`
> * 如果抛到最顶层都没有异常处理，就会执行`std::terminate()`来终止程序
> * `stdexception.h`定义的异常类：`exception, runtime_error, range_error, overflow_error, underflow_error, logic_error, domain_error, invalid_error, length_error, out_of_range`
> * `exception`类定义
>
> ```c++
> class exception
> {
>   public:
>   exception() _GLIBCXX_NOTHROW { }
>   virtual ~exception() _GLIBCXX_TXN_SAFE_DYN _GLIBCXX_NOTHROW;
> 
>   /** Returns a C-style character string describing the general cause
>      *  of the current error.  */
>   virtual const char*
>     what() const _GLIBCXX_TXN_SAFE_DYN _GLIBCXX_NOTHROW;
> };
> ```
>
> ***

## 第六章

> ### 6.1函数基础
>
> * 调用运算符：用于调用函数，即一对括号`()`
> * 函数调用的两项工作
>
> > * 用实参初始化形参
> > * 将控制权由主调函数切换到被调函数
> >
> > ***
>
> * 函数return返回两项工作
>
> > * 返回return语句中的值(如果有的话)
> > * 将控制权由被调函数切换到主调函数
> >
> > ***
>
> * 返回类型：返回类型不能是数组，但可以是指向数组的指针
> * 局部变量：局部变量会隐藏外层作用域中其他所有同名声明
> * 自动对象：只存在于块执行期间的对象。如形式参数就是自动对象
> * 局部静态对象
>
> > * 程序第一次执行到它时初始化，直到程序结束才销毁
> > * 定义：`static int i = 0;`
> >
> > ```c++
> > std::size_t count_calls()
> > {
> >   	//第一次执行到这里时会初始化为0， 后面就不会每次赋为零而是取已有的值
> >     static std::size_t i = 0;
> >     return ++i;
> > }
> > ```
> >
> > ***
>
> * 函数声明
>
> > * 举例: `void print(vector<int>::const_iterator beg, vector<int>::const_iterator end);`
> > * 定义必须在声明前，不然找不到声明
> > * 可以多次声明但只能一次定义
> > * 定义最好放在头文件中
> >
> > ***
>
> * 分离式编译
>
> > * main.cpp
> >
> > ```c++
> > #ifndef MAIN_CPP
> > #define MAIN_CPP 1
> > #include<iostream>
> > #include "countCall.h"
> > #endif
> > 
> > int main()
> > {
> >     for (size_t i = 0; i < 10; i++)
> >     {
> >         std::cout << count_calls() << std::endl;
> >     }
> >     return 0;
> > }
> > ```
> >
> > * countCall.h
> >
> > ```c++
> > #include<bits/c++config.h>
> > 
> > std::size_t count_calls();
> > ```
> >
> > * countCall.cpp
> >
> > ```c++
> > #ifndef COUNT_CALL_CPP
> > #define COUNT_CALL_CPP
> > #include "countCall.h"
> > #include<bits/c++config.h>
> > #endif
> > 
> > std::size_t count_calls()
> > {
> >     static int i = 0;
> >     return ++i;
> > }
> > ```
> >
> > * 编译命令
> >
> > ```bash
> > g++ main.cpp countCall.cpp -o main.out
> > ```
> >
> > ***
>
> ### 6.2 参数传递
>
> * 值传递：将实参拷贝一份，赋值给形参
> * 引用传递：形参是实参的一个别名
> * 指针形参：实际上是值传递，只不过指向的对象相同
> * 与C的习惯差别：C程序员常常通过指针类型的形参来访问外部的对象，而C++语言建议使用引用来代替指针传递
> * 使用引用避免拷贝
>
> > * 有些对象不能拷贝，如`io`对象。这种时候就只能传递引用
> > * 有些对象拷贝十分费时，比如很长的字符串，这是也可以传递引用
> >
> > ```c++
> > bool isShorter(const string &str1, const string &str2);
> > ```
> >
> > * 如果函数无须修改引用形参的值，最好将其设置为常量引用
> >
> > ***
>
> * 返回多个值：通过引用形参可以让一个函数实际上可以返回多个值
> * const形参与实参
>
> > * 和其他初始化过程一样，用实参初始化形参时会忽略掉形式参数的const。即`int fun(const int);`函数既可以穿入`int i = 0`做参数，也可以传入`const int j = 0`做参数
> > * 重复定义错误
> >
> > ```c++
> > int fun(const int);
> > int fun(int);//重复定义
> > ```
> >
> > * 形参尽量使用常量引用
> >   * 当形参为常量引用时，既可以接受常量实参也可以接受普通实参；而如果形参为普通引用时，则函数不能接受常量实参
> >   * 不遵循此规则还可能连环出错
> >
> > ***
>
> * 数组形参
>
> > * 数组不允许拷贝，但允许传数组指针
> > * 等价性
> >   * 下面三种形式的函数是一模一样的
> >   * 编译器只会检查穿入的实参类型是否为`int *`，其他的它不管
> >   * 即数组的大小对数组的调用没有影响
> >
> > ```c++
> > void print(const int*);
> > void print(const int[]);
> > void print(const int[10]);
> > ```
> >
> > * 明确数组长度的方式
> >   * 类似于C风格字符串，末尾有一个特殊的结束符`\0`
> >   * 传递首元素指针和尾后指针，类似于迭代器
> >   * 显示地传入一个形参用于表示数组的大小
> >
> > * 数组引用形参
> >   * `print(int (&arr)[10])`
> >   * 但此时只能传入大小为10的数组，其实参类型严格限制成`int [10]`，不是10就不行
> > * `main`处理命令行选项
> >   * `int main(int argc, char *argv[])`
> >   * `int main(int argc, char **argv)`
> >   * 参数从`argv[1]`开始，因为`argv[0]`一般都是`a.out`
> >
> > ***
>
> * 可变形参的函数
>
> > * `initializer_list`
> >   * 定义在`initializer_list`文件中
> >   * 定义：`void error_msg(initializer_list<string> args)`
> >   * 调用：`error_msg({"str1", "str2", "str3"})`
> >
> > * 省略符形参`...`
> >   * 一般用于访问C代码，因为这种C代码使用了C标准库的`varargs`功能
> >   * 出上一种情况外不建议使用
> >   * 省略形参只能存在于最后一个参数
> >
> > ***
>
> ### 6.3 返回类型和return语句
>
> * 无返回值函数：不用`return`，但编译器会隐式地加上`return`语句
> * 有返回值的函数
>
> > * 编译器并不是能检测到所有case是否都有返回值。如果运行时有未返回的情况会直接崩
> > * 值是如何返回的
> >   * 返回值用于初始化调用处的一个临界量，该临界量就是函数调用的结果
> >   * 返回非引用类型会进行一次拷贝，而返回引用则不会进行拷贝
> > * 不要返回局部引用和局部指针
> > * 调用运算符
> >   * 调用运算符和`.`与`->`运算符优先级相同，且满足左结合率
> >   * 因此可以连续调用
> >
> > ***
>
> * 预处理变量
>
> > * 由预处理器处理而不是由编译器处理
> > * 因此不用加`std`，而是随便直接用
> > * 预处理宏其实也就是预处理变量
> > * 由于预处理变量必须在程序内保持唯一，因此其他地方绝对不要在定义同名的变量
> >
> > ***
>
> * 返回数组指针：`auto get_array() -> int (*)[10];` 或者 `auto get_array() -> decltype(a)*`
>
> ### 6.4 函数重载
>
> * 不允许两个函数除了返回类型外其他所有的要素都相同，即函数的返回类型不会参与重载
> * 重载和const
>
> > * 形参有无顶层`const`不是函数区分的依据
> > * `fun(const int &i); fun(int &i)`是可以的，因为此时是底层const
> > * 编译器会区分底层const选择最优函数进行调用
> >
> > ***
>
> * `const_cast`和重载
>
> > ```c++
> > const string &get_shorter(const str &str1, const string &str2)
> > {
> >   return str1.size() <= str2.size() ? str1 : str2;
> > }
> > 
> > string &get_shorter(str &str1, string &str2)
> > {
> >   auto &r = get_shorter(const_cast<const string&>(str1), const_cast<const str&>(str2));
> >   return const_cast<sting &>(r);
> > }
> > ```
> >
> > ***
>
> * 函数匹配
>
> > * 找一个最优的进行匹配。能不进行类型转换就不进行
> > * 如果函数有默认实参，则实际穿入的参数可以比实际的数量少
> > * 小算术值会一步到位转为`int`，而不会中间转为`short`慢慢升级
> > * 如果没有最优，而是旗鼓相当。则发生错误，称为`二义性错误`
> >
> > ***
>
> * 局部作用域与重载：局部作用域类函数不能重载。`C++的名字查找发生在类型检查之前`
> * 默认实参
>
> > * 使用：`int fun(int j = 10);`
> > * 不允许多次声明修改同一个参数的实参
> > * 默认实参要么在最后一个，否则它后面的所有形参都有默认值
> > * 默认实参可以是表达式或者函数，前提是能够在这个函数声明的作用域内进行解析
> >
> > ***
>
> * 内联函数
>
> > * `inline const string &get_shorter(const str &str1, const string &str2);`
> > * `inline`只是给编译器发出一个请求，而编译器可以忽略这个请求
> >
> > ***
>
> * constexpr函数：编译器能求出值进行替换
> * 调试局部变量
>
> > * `__func__`:编译器定义的局部静态变量，用于存放函数的名字
> > * `__FILE__`:存放文件名
> > * `__LINE__`:存放行号
> > * ……
> >
> > ***
>
> ### 6.7 函数指针
>
> * 函数类型决定因素
>
> > * 返回类型
> > * 形参数量
> > * 形参类型
> >
> > ***
>
> * 实际例子
>
> > * 函数声明：`const string &get_shorter(const str &str1, const string &str2);`
> > * 函数类型：`const string& (const str&, const string&);`
> > * 定义指针: `const string& (*fun_ptr)(const str&, const string&);`
> >
> > ***
>
> * 使用函数指针
>
> > * 函数名可以直接当作指针使用，不用使用取地址符`&`
> > * 函数指针可以直接调用，不用使用解地址符`*`
> >
> > ***
>
> * 函数指针作形参
>
> > * `void func(const string &ptr(const str&, const string&))`
> > * `void func(const string& (*ptr)(const str&, const string&))`
> > * 这两种是一样的
> >
> > ***
>
> * 函数指针作为返回值
>
> > * `auto func() -> const string& (*)(const str&, const string&)`
> > * 此时必须显示声明返回的是指向函数的指针而不是函数
> > * 因为不能返回函数
> >
> > ***
>
> ***

