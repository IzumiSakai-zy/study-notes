# Cpp Primer 笔记

## 第一章

> ### 1.1 编写一个简单的C++程序
>
> * int 类型是一种built-in类型
> * main函数的返回值一般被用来表示状态，0表示成功，非零返回值的含义由系统定义，通常用来指出错误类型
>
> *****
>
> ### 1.2 初识输入输出
>
> * 4个IO对象
>
> > * cin
> > * cout
> > * cerr
> > * clog
>
> * 输入输出运算符
>
> > * **<<** 和 **>>** 都是运算符；其中 **<<** 的左侧必须是一个 **ostream** 对象, **>>** 的左侧必须是一个 **istream** 对象
> > * 其中 **<<** 的运算结果是 **ostream** , **>>** 的运算结果是 **istream**
> > * `std::cout << "Hello World" << std::endl;` == `(std::cout << "Hello World") << std::endl;`
>
> * endl，内存缓冲区，物理屏幕
>
> > * **endl**是一个被称为 **操纵符** 的特殊值
> > * 未写入 **enl** 时内从全在缓冲区，写入 **endl** 时才刷新到屏幕物理设备
> > * 调试时debug日志应该实时刷新到屏幕，不然可能在缓冲区不显示出来影响问题定位
>
> ***
>
> ### 1.4 控制流
>
> * while
>
>   ```c++
>   int a = 0;
>   while (a <= 10) {
>     a++;
>   }
>   ```
>
> * for
>
>   ```c++
>   for (int i = 0;i <= 10;i++) {
>     
>   }
>   ```
>
> * if
>
>   ```c++
>   if (i > 0) {
>     
>   }
>   ```
>
> * 流作为判断条件
>
> > * `int value = 0; while (std::cin >> value)`
> >
> > * 当输入流有效时为true，当遇到文件结束符或者非整数时会返回false
>
> * 测试cin 和 cout
>
>   ```c++
>   int value = 0;
>   std::cin >> value;
>   std::cout << value << " ";
>       
>   // when the input is "1 2 3 4 5", the output is "1 "
>   ```
>
>   ```c++
>   int value = 0;
>   while (std::cin >> value) {
>   	std::cout << value << " ";  
>   }
>       
>   // when the input is "1 2 3 4 5", the output is "1 2 3 4 5 "
>   ```
>
>   * 即`cin`会自动去匹配输入
>
> ### 术语
>
> * **头文件**：使类或其他名字的定义可以被多个程序使用的一种机制。程序通过#incude指令使用头文件
> * **库类型**：标准库定义的类型，如 **istream**
> * **操作符对象**：如 std::endl, 在读写流的时候用来 "操纵" 流本身
> * **标准库**：一个类型和函数的集合，每个C++编译器都必须支持
> * **类类型**：为了与C++内置类型区分开来，程序员自己定义的类被称为类类型
>
> ***

***

## 第二章

> ### 前序
>
> * 编程语言补充其基本特征的两种方式
>
> > * 赋予程序员自定义数据类型的权利
> > * 将一些有用的功能封装成库函数提供给程序员
> >
> > ***
>
> * 简单与复杂
>
> > * C++本身是一门简单的语言。它提供了一组内置基本类型，相应的运算符，几种程序控制流语句
> > * C++本身也复杂，程序员可以自定义各种复杂的数据结构
> >
> > ***
>
> ### 2.1基本内置类型
>
> * 类型位数：C++设计准则之一是尽可能贴近硬件。C++的算术类型必须尽可能满足各种硬件特质。因此C++内置算术类型在不同的硬件上有不同的解释。具体多少位往往也是不能确定，不像Java一样可以确定
>
> * 算术类型
>
> > * bool类型:**bool**
> >
> > * char类型：**char**, **wchar_t**, **char16_t**, **char32_t**
> >
> > * 整数类型：**short**, **int**, **long**, **long long**
> >
> > * 浮点类型: **float**, **double**, **long double**
> >
> > ***
>
> * 是否带符号
>
> > * **int, long, short** 默认带符号
> > * **char** 是否带类型由机器硬件决定
> >
> > ***
>
> * 查看位数代码
>
> ```c++
> #include<iostream>
> int main(){
>         int value = 1;
>         int length = sizeof(value);
>         int realShiftLength = 0;
>         for (int i = length - 1;i >= 0;i--) {
>                 for (int j = 7; j >= 0;j--) {
>                         realShiftLength = (i << 3) + j;
>                         if(((value >> realShiftLength) & 0x01) == 1){
>                                 std::cout << "1 ";
>                         } else {
>                                 std::cout << "0 ";
>                         }
>                 }
>                 std::cout << "\n";
>         }
>         return 0;
> }
> ```
>
> * x86-64硬件平台实际测试位长结果
>
> | 类型        | X86-64平台长度 |
> | ----------- | -------------- |
> | bool        | 8              |
> | char        | 8              |
> | wchar_t     | 32             |
> | char16_t    | 16             |
> | char32_t    | 16             |
> | short       | 16             |
> | int         | 32             |
> | long        | 64             |
> | long long   | 64             |
> | float       | 32             |
> | double      | 64             |
> | long double | 128            |
>
> * 移植性：如果默认 **int** 是固定位数的话，就可能换到其他硬件无法兼容运行
>
> * 数字的字面值
>
> > * 定义：`24`, `024`,`0x24` `3.14159`这样的值被称为字面值
> > * 十进制字面值的类型是`int, long, long long`中能容纳最小的那一个
> > * 八进制，十六进制的字面值类型是`int, unsigned int, long, unsigned long, long long, unsigned long long`中能够容纳最小的那一个
> > * 小数的字面值类型是`double`
> >
> > ***
>
> * 字符与字符串字面值
>
> > * `sizeof('a') = 1`
> > * `sizeof("a") = 2`
> >
> > ***
>
> * 其他字面值
>
> > * `true, false` 的字面值类型是`bool`
> > * `nullptr`的字面值类型是`指针`
> >
> > ***
>
> ### 2.2 变量
>
> * 初始化与赋值
>
> > * C++中，初始化不等于赋值。虽然这两者的区别微乎其微
> > * 初始化的含义是创建变量是赋予一个初始值
> > * 赋值的含义是将原来的值擦除，用一个新值代替
> >
> > ***
>
> * 列表初始化
>
> > * C++ 11标准的新特性
> > * 使用花括号来进行初始化：`unsigned int value{100};`
> >
> > ***
>
> * 默认初始化
>
> > * 内置类型如果在函数外未初始化，则默认初始化未0
> > * 内置类型如果在函数体内未初始化，则 **不被初始化**，它的值是未定义的，对它访问可能出错。因此建议尽量初始化每个内置类型的值
> > * 类类型对象如果没有初始化，则其值有类定义决定
> >
> > ***
>
> * 声明与定义
>
> > * 声明：规定变量的名字和类型
> > * 定义：创建于名字相关联的实体
> > * 声明作用：让C++支持 **分离式编译** ，将声明与定义区分开来
> > * 声明可以多处声明，定义只能一次定义
> > * 声明语法：`extern int i;`
> > * 声明语句不能给声明的变量赋初始值，否则将抵消`extern`的作用而将声明变成定义
> >
> > ***
>
> ### 2.3指针
>
> * 引用
>
> > * 引用是对象的一个别名
> > * 引用一旦创建就和它的初始值牢牢绑定在一起了，因此引用必须有初始值，引用无法重新绑定到另一个对象
>
> * 指针字面值：空指针最好都赋值为`nullptr`，`int* p{nullptr};`
> * 指针判断：任何为0指针都是false，任何非0指针都是true。`int* p = nullptr; if(p) {}`
> * 指针比较：两个类型相同的指针可以做`==, !=`运算，指向的地址完全相同就返回true
> * `void*`指针：是一种特殊类型的指针，可以指向任何对象。但不能对对象做操作，因为不知道对象的类型
> * 数据类型和声明符
>
> > * `int`是数据类型，`*, &`是声明符
> > * 变量的定义包括了一个基本数据类型和一组声明符
> > * 正确写法：`int *p;`， 错误写法`int* p；`。 因为`*`仅仅是修饰了`p`而与`int`无关
> > * **从右往左读**：`int *&p;` `p` 是一个引用，一个指针的引用
> >
> > ***
>
> * const
>
> > * 声明：`const int i = 8;`
> > * 编译时：编译时会把常量直接做替换，因此编译时必须知道常量的值，即常量定义的值。
> > * 文件单独编译：但C++支持文件单独编译，如果一个常量在其他文件需要访问，则必须在那个文件进行定义，但这与一个变量只能定义一次的设定冲突。
> > * 默认文件内：因此C++默认常量的作用范围是文件内。如果多个文件同名的常量会被看作是不同的常量
> > * 手动修改：只需要在声明和定义的地方统统加上`extern`关键字。就能多文件使用常量了。
> > * 使用：A文件`extern const double d = 3.14`，B文件`extern const double d;`
> >
> > ***
>
> * 初始化和对const的引用
>
> > * 引用的类型必须和其所引用对象的类型一致。但在初始化常量引用的时候有例外
> > * `double value = 3.14; const int &i = value;` 合法。因为中途编译器会生成一个`const int temp = value;`，一般称为`临时量`
> >
> > ***
>
> * 对const的引用可能引用一个并非const的对象
>
> ```c++
> int i = 10;
> const int &p = i;
> std::cout << p << std::endl; // 输出10
> i = 0;
> std::cout << p << std::endl; // 输出0
> return 0;
> ```
>
> * 指针和const
>
> > * 指向常量的指针：`const int *p;`，指向的内容(内存地址存的值)是常量不可变，指针内容(内存地址)可以变
> >
> > ```c++
> > const int i = 10;
> > const int j = 20;
> > const int *p = &i;
> > std::cout << *p << std::endl; // 输出 10
> > p = &j;
> > std::cout << *p << std::endl; // 输出 20
> > ```
> >
> > * 常量指针：`int *const p;`,  指向的内容(内存地址存的值)是普通变量可以变，指针内容(内存地址)是常量不能变
> >
> > ```c++
> > int i = 10;
> > int j = 20;
> > int *const p = &i;
> > std::cout << *p << std::endl; // 输出 10
> > i = 0;
> > std::cout << *p << std::endl; // 输出 0
> > p = &j; // 编译报错
> > ```
> >
> > * 指向常量的常量指针：`const int *int p;`，指向的内容(内存地址存的值)是常量不能变，指针内容(内存地址)是常量不能变
> > * 怎么看：**从右往左读**
> > * 有无常量是有区别的：`const int *p; int *p1;`,其中`p, p1`是不同的类型，不能互相赋值。
> >
> > ```c++
> > int i = 20;
> > const int *p = &i; // 正确，可以把 int* 赋值给 const int*
> > const int j = 30;
> > p = &j; // 正确， const int* 当然可以赋值给 const int*
> > 
> > int k = 40;
> > int *p1 = &k; // 正确， int* 当然可以赋值给 int*
> > const int l = 50;
> > p1 = &l; // 编译错误， const int* 不能赋值给 int*
> > return 0;
> > ```
> >
> > ***
>
> * 常量表达式
>
> > * 定义：值不会改变，在编译期就能计算出值的表达式。
> >
> > * 举例：`const int i = get_size();`不是常量表达式，虽然它的值只赋值一次不会改变，但值到底是多少要到运行时才知道
> >
> > * `constexpr`关键字：一个表达式是不是常量表达式太难分辨了。用这个关键字告诉编译器这是一个常量表达式，如`constexpr const int i = 0;`
> >
> > * `constexpr`函数：这个关键字可以修饰函数，前提是函数的返回值能够在编译期算出来。举例如下：
> >
> >   ```c++
> >   //声明了一个constexpt函数
> >   constexpr int get_size() 
> >   {
> >           return 100;
> >   }
> >
> >   int main()
> >   {       
> >           constexpr const int i = get_size(); // 声明了一个constexpr变量
> >           std::cout << i << std::endl;
> >           return 0;
> >   }
> >   ```
> >
> > * 一般来说，只要认为想把某个表达式定义为常量表达式，就应该加上`constexpr`
> >
> > * `constexpr`与指针：指针必须是`nullptr, 0, 某个固定对象的固定地址`。比如定义在函数体之外的对象的地址是不变的
> >
> > ***
>
> ### 2.5 处理类型
>
> * 类型别名
>
> > * `typedef`
> >   * `typedef double d`，`d`是`double`的同义词
> >   * `typedef char *c`, `c`是 `char*`的同义词
> > * 意义理解不能错
> >
> > ```c++
> > typedef char *cp;
> > const cp ptr; // ptr是一个常量指针，指向 char。即 const (char *) ptr;
> > ```
> >
> > ***
>
> * auto
>
> > * 由编译器去分析表达式所属的类型
> > * `auto`定义的变量必须有初始值
> > * 顶层const常被忽略，因此要手动加顶层const。`const auto i = j;`
> >
> > ***
>
> * decltype
>
> > * 作用：选择并返回操作数的数据类型
> > * 返回类型包含顶层const
> > * `decltype(s.size()) count = 0;`。此时`count`的类型是`std::size_type`
>
> ### 2.6 自定义数据结构
>
> * 定义struct
>
>   ```c++
>   struct Book_info {
>     std::string name = "";
>     int publish_year{0};
>   };
>   ```
>
> * 头文件
>
> > * 头文件一般包含那些只能被定义一次的实体，如类，const和constexpr变量
> > * 头文件一旦改变，相关的源文件必须重新编译以获得更新后的声明
> >
> > ***
>
> * 预处理器
>
> > * 是程序在编译前执行的一段程序
> >
> > ```c++
> > #ifndef SALES_DATA_H  //一旦未真，则一直执行到#endif为止。一旦为假，立即跳过
> > #define SALES_DATA_H
> > #include<string>
> > struct Sales_data {
> > 	//...  
> > };
> > #endif
> > ```
> >
> > * 预处理变量如`SALES_DATA_H`无视C++语言中关于作用域的规则
> >
> > ***
>
> ### 小结
>
> * C++的基础内置类型是与实现它的硬件密切相关的
>
> ***

## 第三章

> ### 前言
>
> * 内置数组是一种更基础的类型，string和vector都是对它的某种抽象
>
> ### 3.1 using
>
> > * `using namespace std;`或者`using std::cout`
> > * 头文件不应该包含using声明，因为头文件会被复制拷贝到include它的文件中去。
> >
> > ***
>
> ### 3.2 string
>
> * 使用string
>
>   ```c++
>   #include<string>
>   using std::string;
>   ```
>
> * 拷贝初始化与直接初始化
>   * 拷贝：`std::string a = "Hello";`
>   * 直接：`std::string a("Hello");`
> * string操作
>
> > * `getline`: `while(getline(std::cin, a)){ std::count << a << std::endl;}`
> >
> > ***
>
> * std::size_type
>
> > * 是`a.size()`的返回值类型
> > * 是`string`库的配套类型。体现了标准库类型与机器无关的特性
> > * 实际上是`long unsinged int`
> > * 因此不要和`int`混着用， 不然有风险
> >
> > ***
>
> * 字面值和string相加
>
> > * 标准库允许把字符字面值和字符串字面值转化为string对象
> > * 为了兼容C，C++中的字符字面值并不是标准库类型string的对象
> >
> > ***
>
> * 使用C++版本的C标准头文件
>
> > * C++标准库除了定义C++语言自身的特有功能外，还兼容C语言的标准库
> > * C语言中`name.h`的头文件，在C++中是`cname`。因此`cctype`和`ctype.h`的内容是一样的
> > * C++语言应该使用`cctype`而不是`ctype.h`
> >
> > ***
>
> * 处理每个字符
>
> > * `for (const char s : "hello world") { std::cout << s << std::endl; }`
> > * 使用引用处理每个字符：`for (char &s : str) { s = '1'; };std::cout << str << std::endl;`。想要改变遍历的值必须设置为引用类型
> > * 下标运算符`[]`：接受的输入类型是`std::size_type`
> >
> > ***
>
> ### 3.3 vector

