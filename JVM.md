# 深入理解JVM

## 第一章 走进java

> ### 为什么学习java虚拟机
>
> > * JVM为达到平台无关性而牺牲了一部分性能特性
> > * 开发人员不了解JVM特性和原理，无法为写出高效目标代码
> >
> > *********
>
> ### java技术体系
>
> > #### java技术体系组成部分
> >
> > * java程序设计语言
> > * 运行在各种硬件平台上的JVM实现
> > * .class文件格式
> > * java类库api
> >
> > #### JRE
> >
> > * java类库api的一个子集
> > * JVM
> >
> > #### Java SE
> >
> > * API核心包是 **java.*** 
> >
> > #### Java EE
> >
> > * API拓展包多是 **javax.***
> >
> > **********
>
> ### 热点代码探测
>
> > * 通过执行计数器找出最具有编译价值的代码
> > * 然后通知即时编译器以方法为单位进行编译
> >
> > *********
>
> ### Graal虚拟机
>
> > #### 特点
> >
> > * 无语言倾向
> > * 不同语言可以互相混合调用对方接口和对象
> > * 支持每种语言已经编写好的本地库
> >
> > #### 支持语言
> >
> > * 本身运行在JVM上的java、kotlin等语言
> > * 基于llvm的C、C++、RUST语言
> >
> > #### 工作原理
> >
> > * 将语言的源代码或者源代码编译后的中间形式通过解释器转换成GraalVM识别的中间格式(IR)
> > * 如 C -> LLVM IR -> Graal IR -> VM执行 -> 结果
> >
> > #### 高级特点
> >
> > * 和指令集一样只与机器物理特性相关而与某种特定高级语言无关
> >
> > ************
>
> ### HotSpot内的编译器
>
> > #### 客户端编译器
> >
> > * 编译时间短但优化程度低
> >
> > #### 服务端编译器
> >
> > * 编译时间长但优化程度高
> >
> > **********
>
> ### 提前编译
>
> > #### 优势
> >
> > * 提前编译好直接用，不用等即时编译
> > * 减少java第一次运行慢的特点
> >
> > #### 劣势
> >
> > * 必须为每个硬件、操作系统去编译对应的发行包
> > * 降低了动态性，要求链接在编译前全部已知
> >
> > **********
>
> **************

## 第二章 内存区域和内存溢出

> ### 概述
>
> > #### c和c++
> >
> > * 关于内存管理。外面的人想进去，里面的人想出来
> >
> > #### 自动管理缺点
> >
> > * 一旦java发生内存泄漏。如果对JVM是如何使用内存不了解，那排查错误将异常费劲
> >
> > ***********
>
> ### 程序计数器
>
> > #### 实质
> >
> > * 是一块较小的内存空间
> >
> > #### 作用
> >
> > * 和C语言的PC寄存器一样
> >
> > #### 特点
> >
> > * 线程私有，每一个线程有自己的程序计数器
> >
> > #### 执行区别
> >
> > * 当执行一个java方法时指向正在执行的虚拟机字节码指令地址
> > * 当执行一个native方法，计数器值为空
> >
> > ************
>
> ### java虚拟机栈
>
> >#### 特点
> >
> >* 线程私有
> >* 就是程序员常说的"堆"、"栈"内存中的"栈内存"
> >
> >#### 作用
> >
> >* 线程执行方法时压入和弹出方法栈帧
> >
> >#### 栈帧包含内容
> >
> >* 存储局部变量表
> >* 操作数栈
> >* 动态链接
> >* 方法出口
> >* ……
> >* 注意：不包含返回地址，和C语言不同
> >
> >#### 局部变量表内容
> >
> >* 基本数据类型
> >* 对象引用(即对象在堆中的地址)
> >* **函数返回地址** (java的函数返回地址不放在栈结尾)
> >
> >#### 局部变量槽
> >
> >* 用于存放局部变量表中的三种数据
> >
> >#### 局部变量表大小
> >
> >* 在编译期间就完全知道局部变量表有多大
> >* 编译期完成分配
> >
> >#### 内存异常
> >
> >* StackOverFlowError —— 请求栈深度大于虚拟机允许最大深度
> >
> >**********
>
> ### 本地方法栈
>
> > #### 实质
> >
> > * 和虚拟机栈几乎一样
> > * 只不过本地方法栈执行本地native方法
> >
> > #### 特点
> >
> > * 是线程隔离的
> >
> > #### HotSpot
> >
> > * 此虚拟机甚至本地方法栈和虚拟机栈合二为一
> >
> > ***********
>
> ### java堆
>
> > #### 特点
> >
> > * 所有线程共享
> > * 虚拟机启动时即创建堆
> >
> > #### 作用
> >
> > * 存放java对象的实例
> > * 注：由于逃逸分析技术发展，出现了栈上分配技术，因此对象全在栈上说法不能太绝对
> >
> > #### 堆空间分类
> >
> > * java堆空间不进行分类，因为它的作用只有一个就是存放对象实例
> > * 如果进行分类也是为了更好地进行垃圾回收
> >
> > #### 空间连续性
> >
> > * java虚拟机规范允许java堆在物理内存上不连续，但它们在逻辑上应该是连续的
> >
> > *********
>
> ### 方法区
>
> > #### 特点
> >
> > * 所有线程共享
> >
> > #### 存放内容
> >
> > * 已被虚拟机加载的类型信息
> > * 已被虚拟机加载的常量
> > * 已被虚拟机加载的静态变量
> > * 即使编译器编译后的代码缓存数据
> >
> > #### 存放内容的特点
> >
> > * 几乎不需要修改
> > * 几乎都需要常驻内存
> > * 由上方法区曾被称作 **永久代**
> >
> > #### 方法区实现
> >
> > * JDK8使用本地内存(native memory)技术实现方法区
> >
> > ************
>
> ### 运行时常量池
>
> > #### 实质
> >
> > * 是方法区的一部分
> >
> > ### 特点
> >
> > * 所有线程共有
> >
> > #### 存放内容
> >
> > * 编译期生成的各种字面量
> > * 编译期生成的各种符号引用
> > * 运行时产生的新的常量(j具有动态性)
> >
> > *********
>
> ### 直接内存
>
> > #### 实质
> >
> > * 不是运行时数据区的一部分
> > * 而是堆外的一部分内存
> >
> > #### 作用
> >
> > * 使用此内存区域来避免java堆和native堆频繁交换数据，提高效率
> >
> > *********
>
> ### 对象的创建
>
> > #### 对象界定
> >
> > * 此处对象指java普通对象，而非数组和类对象
> >
> > #### A - 检查类的符号引用
> >
> > * 检查常量池中是否有此类的符号引用
> > * 有引用并检查类是否已加载、解析、初始化
> >
> > #### B - 分配内存
> >
> > * 内存大小在类加载完成时就可以确定
> > * 在内存中分配此对象规定大小的内存
> >
> > #### 分配内存方式
> >
> > * 指针碰撞式
> >   * 内存绝对完整
> >   * 仅仅移动指针就能完成内存分配
> >   * 适合带空间压缩整理的GC
> > * 空闲列表式
> >   * 维护一个空闲和占用表
> >   * 分配完内存就改表
> >   * 适合不带空间整理的GC
> >
> > #### 防分配内存线程不安全
> >
> > * 方法一：把分配空间动作同步处理
> > * 方法二：使用TLAB
> >
> > #### TLAB原理
> >
> > * 在堆中为每个线程分配一小块内存
> > * 对于每个线程来说这块内存是私有的
> > * 分配空间时先在TLAB内分配
> > * 当TLAB用完重新分配缓存区时才同步锁定
> >
> > #### C - 赋值0
> >
> > * 分配完后除了对象头外全部赋值为0
> > * 这样能保证全部都可用有值
> >
> > #### D - 设置对象头
> >
> > * 对象头是对象内存区域的一部分
> > * 对象头内容
> >   * 所属类
> >   * 如何找到类元数据信息
> >   * 哈希码
> >   * GC年代信息
> >
> > E - 执行构造函数
> >
> > *******
>
> ### 对象内存布局
>
> > 

