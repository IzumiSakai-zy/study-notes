# 深入理解JVM

## 第一章 走进java

> ### 为什么学习java虚拟机
>
> > * JVM为达到平台无关性而牺牲了一部分性能特性
> > * 开发人员不了解JVM特性和原理，无法为写出高效目标代码
> >
> > *********
>
> ### java技术体系
>
> > #### java技术体系组成部分
> >
> > * java程序设计语言
> > * 运行在各种硬件平台上的JVM实现
> > * .class文件格式
> > * java类库api
> >
> > #### JRE
> >
> > * java类库api的一个子集
> > * JVM
> >
> > #### Java SE
> >
> > * API核心包是 **java.*** 
> >
> > #### Java EE
> >
> > * API拓展包多是 **javax.***
> >
> > **********
>
> ### 热点代码探测
>
> > * 通过执行计数器找出最具有编译价值的代码
> > * 然后通知即时编译器以方法为单位进行编译
> >
> > *********
>
> ### Graal虚拟机
>
> > #### 特点
> >
> > * 无语言倾向
> > * 不同语言可以互相混合调用对方接口和对象
> > * 支持每种语言已经编写好的本地库
> >
> > #### 支持语言
> >
> > * 本身运行在JVM上的java、kotlin等语言
> > * 基于llvm的C、C++、RUST语言
> >
> > #### 工作原理
> >
> > * 将语言的源代码或者源代码编译后的中间形式通过解释器转换成GraalVM识别的中间格式(IR)
> > * 如 C -> LLVM IR -> Graal IR -> VM执行 -> 结果
> >
> > #### 高级特点
> >
> > * 和指令集一样只与机器物理特性相关而与某种特定高级语言无关
> >
> > ************
>
> ### HotSpot内的编译器
>
> > #### 客户端编译器
> >
> > * 编译时间短但优化程度低
> >
> > #### 服务端编译器
> >
> > * 编译时间长但优化程度高
> >
> > **********
>
> ### 提前编译
>
> > #### 优势
> >
> > * 提前编译好直接用，不用等即时编译
> > * 减少java第一次运行慢的特点
> >
> > #### 劣势
> >
> > * 必须为每个硬件、操作系统去编译对应的发行包
> > * 降低了动态性，要求链接在编译前全部已知
> >
> > **********
>
> **************

## 第二章 内存区域和内存溢出

> ### 概述
>
> > #### c和c++
> >
> > * 关于内存管理。外面的人想进去，里面的人想出来
> >
> > #### 自动管理缺点
> >
> > * 一旦java发生内存泄漏。如果对JVM是如何使用内存不了解，那排查错误将异常费劲
> >
> > ***********
>
> ### 程序计数器
>
> > #### 实质
> >
> > * 是一块较小的内存空间
> >
> > #### 作用
> >
> > * 和C语言的PC寄存器一样
> >
> > #### 特点
> >
> > * 线程私有，每一个线程有自己的程序计数器
> >
> > #### 执行区别
> >
> > * 当执行一个java方法时指向正在执行的虚拟机字节码指令地址
> > * 当执行一个native方法，计数器值为空
> >
> > ************
>
> ### java虚拟机栈
>
> >#### 特点
> >
> >* 线程私有
> >* 就是程序员常说的"堆"、"栈"内存中的"栈内存"
> >
> >#### 作用
> >
> >* 线程执行方法时压入和弹出方法栈帧
> >
> >#### 栈帧包含内容
> >
> >* 存储局部变量表
> >* 操作数栈
> >* 动态链接
> >* 方法出口
> >* ……
> >* 注意：不包含返回地址，和C语言不同
> >
> >#### 局部变量表内容
> >
> >* 基本数据类型
> >* 对象引用(即对象在堆中的地址)
> >* **函数返回地址** (java的函数返回地址不放在栈结尾)
> >
> >#### 局部变量槽
> >
> >* 用于存放局部变量表中的三种数据
> >
> >#### 局部变量表大小
> >
> >* 在编译期间就完全知道局部变量表有多大
> >* 编译期完成分配
> >
> >#### 内存异常
> >
> >* StackOverFlowError —— 请求栈深度大于虚拟机允许最大深度
> >
> >**********
>
> ### 本地方法栈
>
> > #### 实质
> >
> > * 和虚拟机栈几乎一样
> > * 只不过本地方法栈执行本地native方法
> >
> > #### 特点
> >
> > * 是线程隔离的
> >
> > #### HotSpot
> >
> > * 此虚拟机甚至本地方法栈和虚拟机栈合二为一
> >
> > ***********
>
> ### java堆
>
> > #### 特点
> >
> > * 所有线程共享
> > * 虚拟机启动时即创建堆
> >
> > #### 作用
> >
> > * 存放java对象的实例
> > * 注：由于逃逸分析技术发展，出现了栈上分配技术，因此对象全在栈上说法不能太绝对
> >
> > #### 堆空间分类
> >
> > * java堆空间不进行分类，因为它的作用只有一个就是存放对象实例
> > * 如果进行分类也是为了更好地进行垃圾回收
> >
> > #### 空间连续性
> >
> > * java虚拟机规范允许java堆在物理内存上不连续，但它们在逻辑上应该是连续的
> >
> > *********
>
> ### 方法区
>
> > #### 特点
> >
> > * 所有线程共享
> >
> > #### 存放内容
> >
> > * 已被虚拟机加载的类型信息
> > * 已被虚拟机加载的常量
> > * 已被虚拟机加载的静态变量
> > * 即使编译器编译后的代码缓存数据
> >
> > #### 存放内容的特点
> >
> > * 几乎不需要修改
> > * 几乎都需要常驻内存
> > * 由上方法区曾被称作 **永久代**
> >
> > #### 方法区实现
> >
> > * JDK8使用本地内存(native memory)技术实现方法区
> >
> > ************
>
> ### 运行时常量池
>
> > #### 实质
> >
> > * 是方法区的一部分
> >
> > ### 特点
> >
> > * 所有线程共有
> > * JDK8之后常量池被分配到堆当中
> >
> > #### 存放内容
> >
> > * 编译期生成的各种字面量
> > * 编译期生成的各种符号引用
> > * 运行时产生的新的常量(具有动态性)
> >
> > *********
>
> ### 直接内存
>
> > #### 实质
> >
> > * 不是运行时数据区的一部分
> > * 而是堆外的一部分内存
> >
> > #### 作用
> >
> > * 使用此内存区域来避免java堆和native堆频繁交换数据，提高效率
> >
> > *********
>
> ### 对象的创建
>
> > #### 对象界定
> >
> > * 此处对象指java普通对象，而非数组和类对象
> >
> > #### A - 检查类的符号引用
> >
> > * 检查常量池中是否有此类的符号引用
> > * 有引用并检查类是否已加载、解析、初始化
> >
> > #### B - 分配内存
> >
> > * 内存大小在类加载完成时就可以确定
> > * 在内存中分配此对象规定大小的内存
> >
> > #### 分配内存方式
> >
> > * 指针碰撞式
> >   * 内存绝对完整
> >   * 仅仅移动指针就能完成内存分配
> >   * 适合带空间压缩整理的GC
> > * 空闲列表式
> >   * 维护一个空闲和占用表
> >   * 分配完内存就改表
> >   * 适合不带空间整理的GC
> >
> > #### 防分配内存线程不安全
> >
> > * 方法一：把分配空间动作同步处理
> > * 方法二：使用TLAB
> >
> > #### TLAB原理
> >
> > * 在堆中为每个线程分配一小块内存
> > * 对于每个线程来说这块内存是私有的
> > * 分配空间时先在TLAB内分配
> > * 当TLAB用完重新分配缓存区时才同步锁定
> >
> > #### C - 赋值0
> >
> > * 分配完后除了对象头外全部赋值为0
> > * 这样能保证全部都可用有值
> >
> > #### D - 设置对象头
> >
> > * 对象头是对象内存区域的一部分
> > * 对象头内容
> >   * 所属类
> >   * 如何找到类元数据信息
> >   * 哈希码
> >   * GC年代信息
> >
> > #### E - 执行构造函数
> >
> > *******
>
> ### 对象内存布局
>
> > ####  内存部分
> >
> > * 对象头
> > * 实例数据
> > * 对齐填充
> >
> > #### 对象头数据
> >
> > * 存储对象自身的运行时数据(尽可能节约空间多存放信息内容)
> > * 存储类型指针
> >
> > #### 实例数据
> >
> > * 参数顺序有变，尽量节约内存
> >
> > #### 对齐
> >
> > * 必须要求8字节对齐
> >
> > ************
>
> #### 对象访问定位
>
> > #### 句柄访问
> >
> > * 在java堆内存中划分一部分作为句柄池
> > * 虚拟机栈中的reference指向句柄池中的一个句柄
> > * 一个句柄两个指针分别指向java堆中的实例数据和方法区中的类型信息
> >
> > #### 直接访问
> >
> > * 虚拟机栈中的reference直接指向java堆中的实例对象数据
> > * 实例数据中有一个指针指向方法区的类型信息
> >
> > #### HotSpot
> >
> > * HotSpot虚拟机使用直接访问
> >
> > *******
>
> ### 实战OOM异常
>
> > #### 指令
> >
> > ```shell
> > java -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError HeapOOM
> > ```
> >
> > * 这些参数都是虚拟机启动参数，用于控制虚拟机启动
> > * **Xms20m** —— 堆内存大小是20M
> > * **Xmx20m** —— 最大堆内存可以扩展到20M
> > * **-XX:+HeapDumpOnOutOfMemoryError** —— 出现堆内存异常时dump出信息，会生成hprof文件供分析使用
> >
> > #### 代码
> >
> > ```java
> > import java.util.ArrayList;
> > public class HeapOOM{
> >     	//声明一个对象待会儿来占用堆内存
> >         static class OOMObject{}
> >         public static void main(String[] args){
> >                 //创建一个数组保持引用不要被GC回收
> >                 ArrayList<OOMObject> list = new ArrayList<OOMObject>();
> >                 //一直创建占用堆内存
> >                 while(true){list.add(new OOMObject());}
> >         }
> > }
> > 
> > ```
> >
> > #### 堆溢出常见原因
> >
> > * 循环创建对象存储在堆内存中
> >
> > *********
>
> ### 实战SOF异常
>
> > #### 指令
> >
> > ```shell
> > java -Xss228k StackSOF 
> > ```
> >
> > * **Xss228k** —— 栈大小是228k(栈不可拓展，因此无Xsx)
> >
> > #### 代码
> >
> > ```java
> > public class StackSOF{
> >     	//创建一个循环无限递归函数来压栈帧
> >         static void increase(){
> >                 int i = 0;
> >                 increase();
> >         }
> >         public static void main(String[] args){
> >                 //调用函数
> >                 increase();
> >         }
> > }
> > ```
> >
> > #### 栈溢出原因
> >
> > * 递归调用函数使栈帧循环压栈
> > * 多线程由于栈空间私有而使虚拟机 **进程** 本身内存耗尽
> >
> > #### 调优注意
> >
> > * 对于低位的操作系统如32位，一个进程的最大内存很有限
> > * 此系统如果想要程序有尽可能多的线程的话
> > * 通常采用减少最大堆，减少栈容量来解决
> > * 此条调优比较隐蔽
> >
> > *****
>
> ### 方法区/常量池溢出
>
> > #### String::intern()方法
> >
> > * 首先在常量池中找有没有这个字符串
> > * 如果有就直接返回这个字符串的引用
> > * 当常量池中没有时就在常量池中创建一个字符串并返回此字符串的引用
> > * 当常量池溢出时会抛出OOM异常
> >
> > #### 代码
> >
> > ```java
> > import java.util.HashSet;
> > public class RuntimeConstPoolOOM{
> >         public static void main(String[] args){
> >                 //用来存引用防止GC
> >                 HashSet<String> set = new HashSet<String>();
> >                 int i = 0;
> >                 //循环创建字符串
> >                 while(true){set.add(String.valueOf(++i).intern());}
> >         }
> > }
> > 
> > ```
> >
> > #### 注意
> >
> > * JDK8及以后常量池在堆中
> >
> > #### 常量池有意思举例
> >
> > ```java
> > String str1 = new StringBuilder("jahhhhhhhhhh").append("va").toString();
> > System.out.println(str1.intern() == str1);
> > 
> > String str = new StringBuilder("ja").append("va").toString();
> > System.out.println(str2.intern() == str2);
> > ```
> >
> > * 第一个输出true。 因为StringBuilder对象肯定在堆中，堆中最开始无此字符串。str1.intern()就是这个字符串
> > * 第二个输出false。因为StringBuilder对象肯定在堆中，堆中一开始就有了java这个字符串。因此str2.intern()首先去常量池中就找到了之前的，自然与新创建的不同
> >
> > #### 溢出原因
> >
> > * 常量创建得太多如String使常量池堆溢出
> > * 创建得类太多，类型信息使内存溢出(如动态创建大量类)
> >
> > ***********
>
> ### 本机内存直接溢出
>
> > #### 直接内存大小
> >
> > * 默认与java堆内存一样大，即 -Xmx声明大小
> >
> > ***********
>
> ************

## 第三章 垃圾回收与内存分配机制

> 
>
> ### 概述
>
> > #### 学习原因
> >
> > * 当排除内存泄漏或泄漏原因时，GC称为限制程序高并发时就必须了解GC
> >
> > #### PC、虚拟机栈、方法栈
> >
> > * 这几个内存区域比较简单
> > * 内存大小几乎都可以在编译期就知道
> > * 特别是栈就是方法栈帧压栈出栈，不用内存回收
> >
> > #### 堆、方法区
> >
> > * 这部分内存有着很强的不确定性
> > * 一个接口不同的实现类需要分配的内存大小是不一样的
> > * 一个方法执行不同分支需要的内存大小也是不一样的
> > * 只有处于运行期间才知道到底要创建多少个对象
> >
> > #### 内存回收含义
> >
> > * 以下内存回收的内存就是指的堆和方法区内存
> >
> > **********
>
> ### 引用计数法
>
> > #### 原理
> >
> > * 有引用就计数器加一
> > * 引用减少一个就减一
> > * 为0代表是垃圾
> >
> > #### 缺点
> >
> > * 有很多例外情况需要考虑，如两个对象互相引用对方
> >
> > #### 打印内存回收日志参数
> >
> > ```shell
> > java -XX:+PrintGCDetails GCTest
> > ```
> >
> > ********
>
> ### 可达性分析
>
> > #### 原理
> >
> > * 通过一系列 GC Root根对象作为起始节点集(即根节点不只一个)
> > * 然后根据是否可达来判断对象是否是垃圾
> >
> > #### GC Root种类
> >
> > * 虚拟机栈中引用的对象
> > * 方法区中的静态属性引用的变量
> > * 方法区中常量引用的对象
> > * 本地栈(通常和虚拟机栈一样)引用的对象
> > * JVM内部的引用，如基本数据类型对应的Class对象，一些常驻内存对象等
> > * 所有被同步锁持有的对象
> >
> > **********
>
> ### 在谈引用
>
> > #### 传统引用的狭隘性
> >
> > * 有些对象当内存够的时候就可以保留，内存不够就不想保留它。对于这样情况传统的引用定义不能区分
> >
> > #### 强引用
> >
> > * 就是传统的引用
> > * 只有有强引用就不会被GC
> >
> > #### 软引用
> >
> > * 引用一些还有用但非必须的对象
> > * 当系统快OOM时进行GC
> >
> > #### 弱引用
> >
> > * 声明周期只有到下一次GC为止的引用
> >
> > #### 虚引用
> >
> > * 根本不是引用
> > * 不能通过虚引用定位到对象
> > * 唯一作用是当GC时收到一个系统通知
> >
> > ***********
>
> ###  回收方法区
>
> > #### 回收的低效率
> >
> > * 对堆进行一次内存回收通常可以释放百分之七十的内存空间
> > * 而对方法区进行垃圾回收通常内存释放效率较低
> >
> > #### 方法区垃圾分类
> >
> > * 不在使用的常量
> > * 不在使用的类型信息
> >
> > #### 常量垃圾回收
> >
> > * 和对象的回收非常类似
> > * 即整个系统中没有在对这个常量的引用
> >
> > #### 类型垃圾回收条件
> >
> > * 该类的所有实例都已经被回收
> > * 加载该类的类加载器被回收(这个条件通常很难达到)
> > * 该类对应的java.lang.Class对象没有在任何地方被引用，即不能在通过反射创建对象
> >
> > #### 方法区高负载情况
> >
> > * 大量使用反射创建对象
> > * 动态代理
> > * CGLib字节码框架等
> >
> > **********
>
> ### 垃圾回收算法
>
> > #### 从如何判定对象消亡角度分类
> >
> > * reference counting GC —— Direct GC
> > * tracing GC —— indirect GC
> >
> > *******
>
> ### 分代收集理论
>
> > #### 理论假说
> >
> > * 弱分代假说 —— 绝大多数对象是朝生夕灭的
> > * 强分代假说 —— 熬过越多次垃圾回收的对象越难被回收
> > * 跨代引用假说 —— 跨代引用相对于同代引用来说仅仅占少数
> >
> > #### 设计原则
> >
> > * GC器应该对内存做划分
> > * 根据对象年龄将不同的对象划分到不同的代
> > * 对不同的区域采取不同的收集策略，兼顾时间和空间
> >
> > #### 回收类型划分
> >
> > * Minor GC = Young GC
> > * Major GC = Old GC
> > * Full GC
> >
> > #### 收集简介
> >
> > * 新生代收集： 关注存活对象把它放到老年代，其他内存释放
> > * 老年代收集：关注被收集对象将其释放收集
> >
> > #### 跨代引用策略
> >
> > * 跨代引用比较少
> > * 在新生代维护一个全局数据结构(Remembered Set)
> > * 这个数据结构标记老年代那一部分的内存存在对新生代的跨代引用
> > * 新生代收集时只对老年代被标记部分内存的GC roots进行遍历扫描
> >
> > *********
>
> ### 标记清除算法
>
> > #### 算法思想
> >
> > * 标记所有将回收的，不标记不回收的。标记完成后GC，然后清楚标记
> > * 反过来标记不回收的，不标记要回收的
> >
> > #### 算法缺点
> >
> > * 效率不稳定 —— 当存放大量对象时标记和清除太费时间
> > * 内存碎片太多 —— 标记和清出去造成了大量的内部碎片
> >
> > ************
>
> ### 标记复制算法
>
> > #### 适用情况
> >
> > * 新生代
> > * 存活对象相对很少
> >
> > #### 算法思想
> >
> > * 将新生代划分为8:1:1
> > * 每次内存分派只使用8和其中一个1
> > * 每次进行GC就将还存活的对象复制进另外一个1，然后把8和本身的1清除掉
> > * 重复上述操作
> >
> > #### 缺点
> >
> > * 内存空间有浪费，永远最多只能使用百分之九十的空间
> > * 对存放率大的情况效果很差
> > * 当存活对象大于百分之十时会触发老年代分配担保机制
> >
> > *******
>
> ### 标记整理算法
>
> > #### 适用对象
> >
> > * 老年代
> >
> > #### 算法思想
> >
> > * 还是首先行标记
> > * 然后将不收集对象进行移位
> > * 然后直接将后面的全部清除掉
> >
> > #### 缺点
> >
> > * 老年代存活对象那么多，移动效率太低，而且移动必须同步锁
> >
> > #### 回收与收集的冲突
> >
> > * 不整理方便收集但不利于回收
> > * 整理方便回收但不利于收集
> > * (内存分配频率比内存回收频率高得多)
> >
> > #### 解决方式
> >
> > * 看中吞吐量老年代就标记整理
> > * 看中延迟老年代就标记清除
> >
> > #### 折中方式
> >
> > * 先进行标记清除
> > * 当内存碎片严重到已经无法进行内存分配时在进行标记整理
> >
> > ***********
>
> #### 两类算法区分
>
> > #### 对象判定算法
> >
> > * 计数法
> > * 可达法
> >
> > #### 垃圾收集算法
> >
> > * 标记清除法
> > * 标记复制法
> > * 标记整理法
> >
> > ***********
>
> ###  根节点枚举
>
> > #### 现状待解决问题
> >
> > * 根节点一般位于虚拟机栈和方法区中
> > * 方法区中的根节点就已经恒河沙数了。查找遍历及其耗时
> > * 目前所有GC器在进行根节点枚举时都必须暂停用户线程
> > * 在查找引用链能做到并发但枚举根节点目前依然做不到并发
> >
> > #### 解决方法
> >
> > * 使用准确式垃圾收集
> > * 提前存储虚拟机栈和方法区什么地方是引用(根节点)
> > * 存储方式是使用OopMap数据结构(普通对象指针集合)
> > * 然后在所有线程停顿进行枚举时能够快速枚举出结果
> >
> > #### OopMap处理逻辑
> >
> > * 在指令执行时修改OopMap
> > * 例如调用与OopMap相关的指令，指出那个寄存器，栈上那个位置是引用且有效的截止范围
> > * 如：OopMap{ ebx = oop, [16] = oop off = 142}
> >
> > ***********
>
> ### 安全点
>
> > #### 出现原因
> >
> > * 如果每一条指令都生成对应的OopMap，那将极其地复杂，成本太高
> >
> > #### 实质
> >
> > * 只在某些特定的位置才记录信息
> > * 就是记录OopMap信息
> >
> > #### 特点
> >
> > * 安全点间隔时间不能太长也不能太短
> > * 单纯的指令流太长一般不会导致这段指令运行时间长，因为每条指令运行时间极短
> > * 运行时间长一般只会因为指令序列复用处
> > * 一般在指令序列复用的指令处设置安全点
> >
> > #### 主动式中断
> >
> > * 目的 —— 为了能让垃圾收集时所有线程都能到安全点，以便停止所有进行根节点枚举
> > * 实现 —— 设置一个标志位，执行期间一直轮询，一旦标志位为真就在最近的安全点中断挂起
> >
> > #### 轮询实现
> >
> > * 使用内存保护陷阱实现。即设置某内存页不可读而导致线程中断挂起
> > * 轮询操作被精简到只有一条指令
> > * 轮询标志的地方和安全点是重合的，即有安全点的地方必然有轮询指令
> > * 轮询指令也会出现在需要堆内存分配的地方，用来检查是否堆空间不足而需要收集
> >
> > ************
>
> ### 安全区域
>
> > #### 实质
> >
> > * 是线程的代码序列流中的一段，在此段进行垃圾回收不会有影响的代码片段
> >
> > #### 作用
> >
> > * 当一些线程没有分配处理器时间，如被Sleep，block的线程无法在即将垃圾回收时继续执行到安全点
> >
> > #### 安全区实现安全原理
> >
> > * 当一个线程进入安全区时，首先标记自己进入安全区，那么GC就与自己无关
> > * 当它想出安全区时，如果GC未完成它就被阻塞锁住
> >
> > #### 个人猜想
> >
> > * 当一个被阻塞的线程阻塞处不是安全区，当它可以继续执行时。如果此时没在GC就继续执行，如果此时正在GC就还是被阻塞直到GC结束才恢复运行
> >
> > **********
>
> ### 记忆集与卡表
>
> > #### 由来
> >
> > * 不只是新生代与老年代之间有记忆集数据结构
> > * 所有涉及部分区域收集(Partial GC)的GC都有记忆集
> >
> > #### 目的
> >
> > * 缩减GC Root扫描范围
> >
> > #### 定义
> >
> > * 记录从非收集区到收集区的指针集合的抽象数据结构
> > * 比如新生代收集时记录 O -> M的引用
> >
> > #### 粗粒度
> >
> > * 由于完全没必要详尽记录跨代引用的全部细节，只需要知道存在一个引用即可
> > * 因此可以采用粗粒度的记录，比如卡表
> >
> > #### 记忆集与卡表之间关系
> >
> > * 记忆集是一个抽象的接口概念，只定义了行为意图
> > * 卡表是遵循记忆集意图的一个实现，定义了行为的具体体现
> >
> > #### HotSpot卡表形式
> >
> > * 本质是一个字节数组
> > * 新生代卡表数组每一个元素代表老年代内存的一个卡页(2的整次幂大小)
> > * 当老年代内存某卡页存在至少一个跨代引用时，就将此新生代卡表数组对应元素设置成1
> > * GC时只将数组为1的对应内存放进GC Root扫描
> >
> > ***********
>
> ### 解释执行与即时编译
>
> > #### 解释执行
> >
> > * 对于字节码，JVM一边把它编译成机器码，一边执行
> >
> > #### 即使编译
> >
> > * JVM根据热点探测技术，提前找到高频执行代码，比如循环
> > * 首先把其编译机器码
> > * 然后直接执行
> >
> > #### 解释执行优缺点
> >
> > * 优点
> >   * JVM对代码的可操作性大
> >   * JVM能对代码进行优化
> >   * 能看到更多的中间过程
> > * 缺点
> >   * 运行速度慢
> >   * 第一次解释执行的话尤其慢
> >
> > #### 即时执行优缺点
> >
> > * 优点
> >   * 执行速度快且高效
> > * 缺点
> >   * JVM可操作性太低
> >   * 无法进行优化
> >   * 不知道中间过程
> >
> > ***********
>
> ### 写屏障 (write  barrier)
>
> > #### 卡表变脏时刻
> >
> > * 引用类型字段赋值的那一刻
> >
> > #### 作用
> >
> > * 维护卡表状态
> >
> > #### 实质
> >
> > * 在虚拟机层面对"引用类型字段赋值"这个动作的AOP切面
> > * 在赋值的时候会产生一个通知，供程序执行额外的动作
> > * 赋值的前后都在写屏障的范围内
> > * 即写屏障的范围完全包含了赋值的动作
> >
> > #### 缺点
> >
> > * 只要发生了引用类型字段赋值这个动作就要在写屏障范围内更新卡表
> > * 然而很多字符赋值根本不是跨代引用，就产生了额外开销
> >
> > #### 伪共享问题
> >
> > * 卡表是一个数组，每个元素的大小都不大，极其容易发生伪共享问题
> > * 当多个线程修改互相独立的变量时
> > * 如果这些变量恰好共享同一个缓存行
> > * 就会出现彼此影响而导致性能降低
> >
> > #### 伪共享解决方法
> >
> > * 并发读同一个缓存行没有问题，只有并发写才有问题
> > * 那就在写前加一个判断。如果卡表元素已经是1了就不用写
> > * 这样减少了写的次数解决了伪共享问题，但增加了判断开销。如何权衡根据情况考虑
> >
> > *********
>
> ### 并行的可达性分析
>
> > #### 目前问题
> >
> > * 枚举GC Root要暂停所有用户线程，这是确定的。但至少有Oop Map优化
> > * 从GC Root向下遍历对象问题就十分大了，时间开销几乎与java堆大小成正比
> > * 且遍历GC Root目前来看依然要暂停所有用户进程，不然可能本该存活的对象被标记成垃圾
> >
> > #### 三色标记
> >
> > * 白色 —— 表示尚未被垃圾收集器访问过。最后还是白色就是垃圾
> > * 黑色 —— 表示本对象且此对象的所有引用都被扫描过。表示不是垃圾且不会被扫描
> > * 灰色 —— 表示本对象已经扫描但此对象至少还有一个引用没有扫描
> >
> > #### 导致并发错误(黑当成白)的维二原因
> >
> > * 赋值器插入了至少一条从黑色对象到白色对象的新引用
> > * 赋值器删除了全部从灰色对象到白色对象的直接或间接引用
> > * 注 —— 以上二原因要同时满足才会导致，单独满足一个不会导致
> >
> > #### 解决措施
> >
> > * 原因一 —— 增量更新
> > * 原因二 —— 原始快照
> >
> > #### 增量更新
> >
> > * 记录下新增的引用关系
> > * 并发扫描结束后将引用关系中的黑色对象为更重新扫描
> >
> > #### 原始快照
> >
> > * 记录下删除的引用关系
> > * 并发扫描结束后，将引用关系中灰色对象为根，重新扫描
> >
> > #### 两种引用变更记录的实现机制
> >
> > * 写屏障
> >
> > ***********
>
> ### 垃圾回收时机
>
> > #### 新生代
> >
> > * Eden空间不足
> >
> > #### 老年代
> >
> > * 新生代晋升老年代太多导致空间不足
> > * 大对象进入导致空间不足
> > * 新生代分配担保机制导致老年代收集
> >
> > **********
>
> ### serial收集器
>
> > #### 简介
> >
> > * 非常古老原始
> > * 顾名思义是单线程GC
> >
> > #### 特点
> >
> > * 收集处 —— 新生代
> > * 算法 —— 标记复制
> > * 适用处 —— 客户端
> >
> > #### 缺点
> >
> > * GC时必须暂停所有用户线程，造成stop the world现象
> >
> > #### GC 努力方向
> >
> > * 降低用户线程停顿时间
> > * 但目前只能降低仍无法根除这个问题
> >
> > #### 优势
> >
> > * 简单高效
> > * 额外内存消耗(FootPrint)最少
> > * 对于单线程或者线程少的场景效果起始还很好。且没有线程间开销
> > * 由上，在用户端运行的JVM采用Serial GC来收集新生代起始挺不错
> >
> > **********
>
> ### ParNew收集器
>
> > #### 实质
> >
> > * 就是Serial GC的多线程版本
> >
> > #### 特点
> >
> > * 收集处 —— 新生代
> > * 算法 —— 标记复制
> > * 线程 —— 多线程并行但不并发
> > * 适用处 —— 服务端(因为服务端多核)
> >
> > #### 简介
> >
> > * 代码很多和Serial一模一样
> > * 在单线程里还打不过serial，只有在多线程里才能取胜
> >
> > #### parallel与concurrent
> >
> > * parallel —— 一个GC多条线程间的关系
> > * concurrent —— GC线程和用户线程的关系
> >
> > *******
>
> ### Parallel Scavenge收集器
>
> > #### 实质
> >
> > * 关注吞吐量的Parallel New收集器
> >
> > #### 特点
> >
> > * 适用处 —— 新生代
> > * 线程 —— 多线程并行
> > * 算法 —— 标记复制
> >
> > #### 吞吐与延迟
> >
> > * 低延迟代表良好的用户交互和服务响应
> > * 高吞吐代表可以最高效率地利用处理器资源，尽快完成计算任务
> >
> > #### 核心要素
> >
> > * 此款GC关注吞吐量而不是延迟
> > * 其他的GC很多都是关注延迟
> >
> > #### 控制吞吐量的相关参数
> >
> > * **-XX: MaxGCPauseMillis** —— 设置GC的最长时间，实质上就是设置延迟，高延迟能带来高吞吐
> > * **-XX:GCTimeRatio** —— 作用和上面类似
> >
> > #### 别名
> >
> > * 吞吐量优先GC
> >
> > #### 动态调整特性
> >
> > * parallel scavenge GC能够自适应调节，动态调整收集器参数
> > * 此特性对于那些对收集器运作不清楚的程序员来说是好事
> >
> > ***********
>
> ### serial old
>
> > #### 特点
> >
> > * 适用区 —— 老年代
> > * 算法 —— 标记整理
> > * 线程 —— 单线程(顾名思义)
> > * 适用 —— 客户端模式
> >
> > #### 特殊情况
> >
> > * 在CMS发生failure的时候救场备用
> >
> > *******
>
> ### parallel old
>
> > #### 实质
> >
> > * Parallel New的老年版本
> >
> > #### 特点
> >
> > * 适用区 —— 老年代
> > * 线程 —— 多线程并行
> > * 算法 —— 标记整理
> >
> > #### 服务端特点
> >
> > * 服务端的处理器和处理器核心数一般都比较多
> > * 因此服务端肯定要用带有并行处理能力的GC
> >
> > *******
>
> ### CMS (concurrent mark sweep)
>
> > #### 特点
> >
> > * 算法 —— 标记清除
> > * **收集区域 —— 老年区**
> > * 线程 —— 多线程并行，用户线程并发
> > * 低停顿
> >
> > #### 核心特点
> >
> > * 以低延迟为首要目标
> > * 尽可能获取最短停顿时间
> >
> > #### 标记清除四个步骤
> >
> > * initial mark
> > * concurrent mark
> > * remark
> > * concurrent sweep
> >
> > #### 初始标记
> >
> > * 非并发，需要stop the world
> > * 仅仅标记 GC Root和GC Root能直接引用的对象
> >
> > #### 并发标记
> >
> > * 遍历标记其他剩下的
> > * 可以和用户线程并发，且此步用时最长
> >
> > #### 重新标记
> >
> > * 并发之间可能引用关系会改变，需要重新标记
> > * 增量更新和原始快照两种方法
> > * 这一步需要stop the world
> >
> > #### 并发清除
> >
> > * 清除被标记的对象
> > * 这一步由于采用标记清除所以不用移动活的对象，且对象已被判断死亡无活过来的可能
> > * 因此这一步也可以并发
> >
> > #### 三个缺点
> >
> > * 对处理器资源敏感
> > * 无法处理浮动垃圾
> > * 容易产生内存碎片
> >
> > #### 缺点一
> >
> > * 面向并发的程序对处理器资源都比较敏感
> > * GC线程会占用一部分处理器资源，虽然用户进程没有停下来但速度会降低
> > * 解决思路： 增量式并发收集器 (现在已被弃用)
> >   * 收集线程和用户线程的调度方式使用抢占式调度
> >   * 这样虽然GC收集的总时间会变长，但用户程序就不会感觉那么慢
> >
> > #### 缺点二
> >
> > * 并发标记和并发清除这个过程中会产生新的垃圾
> > * 在标记过程结束以后出现的垃圾就是浮动垃圾
> > * 因为浮动垃圾存在CMS在老年代达到一定占用时就必须开始收集，而不是等满了才收集
> >
> > #### 并发失败 (concurrent mode failure)
> >
> > * GC预留的老年代空间不足以容纳浮动垃圾
> > * 冻结用户线程执行，启动serial old GC来重新收集老年代垃圾
> >
> > #### 缺点三
> >
> > * 标记清除算法会导致内存碎片
> > * 因为内存碎片可能会提前触发Full GC
> > * Full GC要移动对象，因此得stop the world
> >
> > *************
>
> ### G1 (garbage first)
>
> > #### 特点
> >
> > * 面向局部收集的设计思路
> > * 基于region内存布局形式
> > * 支持类型卸载
> > * 停顿时间模型
> >
> > * 服务端全功能GC
> >
> > #### 线程
> >
> > * 支持多线程并行，用户线程并发
> >
> > #### 回收范围对比
> >
> > * 旧GC
> >   * 整个新生代
> >   * 整个老年代
> >   * 整个堆
> > * G1
> >   * 内存region集合 (collection set)
> >
> > #### 回收的衡量标准
> >
> > * 那块内存region的垃圾最多，回收收益最大
> >
> > #### region概念
> >
> > * 将整个堆划分为大小相等的很多个region
> > * 每个region可以担任不同的空间职责(Eden、survivor、old)
> > * 不同职责的区域采取不同的收集策略
> >
> > #### humongous区域
> >
> > * 专门用来存放大对象的region区域
> > * region的大小用户可以自己设置
> > * 对于大小超过了一个region的对象，会存放在连续N个humongous region中
> > * 此区域被G1视作老年代的一部分
> >
> > #### 停顿时间模型
> >
> > * 用户能够指定在一个M毫秒的时间段内，消耗与GC的时间不超过N毫秒。即可以指定GC的时间
> > * 因为回收对象是region集合，因此每次回收内存大小必定是region大小的整数倍
> > * 在后台维护一个优先级表，优先值是每块region的回收价值
> > * 根据用户设置的GC参数在优先表中选择适当的region进行回收就能设置收集停顿时间
> >
> > #### region之间跨引用
> >
> > * 依旧使用记忆集方法，但记忆集的实现更复杂
> > * 因为每个region都可能存在跨region引用，因此每个region都有记忆集
> > * 由于记忆集那么多，因此G1收集器在GC时占用的堆内存就会比较高
> >
> > #### 并发用户线程干扰
> >
> > * G1采用原始快照处理而不是增量更新
> > * 每个region都有两个名为TAMS的指针，指针间的区域用于并发途中新对象创建
> > * 指针区域对象进行GC时默认存活不收集
> > * 如果指针区域不足以容纳并发中新对象，依然会冻结线程stop the world然后进行full gc
> >
> > #### 可靠的停顿预测
> >
> > * 以衰减均值理论为根据
> > * 衰减均值相对于普通均值的区别是其时效性更强，更能反映当前region的回收价值
> > * 在GC时会记录诸如回收耗时、标准偏差、置信度等统计信息
> >
> > #### 过程一 —— 初始标记
> >
> > * 非并发
> > * 仅仅标记GC Root直接访问到的对象
> > * 修改TAMS指针的初始值
> >
> > #### 过程二 —— 并发标记
> >
> > * 递归标记GC Root以下的结点
> > * 并发进行
> >
> > #### 过程三 —— 最终标记
> >
> > * 非并发
> > * 处理原始快照SATB
> >
> > #### 过程四 —— 筛选回收
> >
> > * 非并发，由于采取标记复制算法
> > * 注: G1每次标记是全堆都进行了标记，但扫描只扫描回收集内的region。和后面ZGC不同
> > * 更新region统计数据，回收价值排序，根据用户设置制定收集计划
> > * 自由选择回收哪一些region(构成回收集)，把存活对象复制到哪一些另外的region，然后清理掉整个region
> >
> > #### 定位
> >
> > * 并非纯粹准求低延迟(因为四个过程只有一个能并发)
> > * 定位是在延迟可控的情况下获得尽可能高的吞吐量
> >
> > #### 设置期望停顿时间
> >
> > * 设置停顿时间可以在不同的应用场景中取得吞吐量和延迟之间的平衡
> > * 停顿目标如果太短，会导致一次只能GC很小一部分，导致GC速度更不上allocate速度，导致无堆内存，导致stop the world，然后full GC
> >
> > #### 设计思路改变
> >
> > * 旧 —— 一次收集尽可能多的内存，恨不得报java堆清理干净
> > * 新 —— 只要收集的速度能够跟上分配的速度就行
> >
> > #### G1优点
> >
> > * 可以指定最大停顿时间
> > * 面向region收集
> > * 按收益动态调整回收处
> > * 由于未采用标记清除算法，因此无内存碎片
> >
> > #### G1算法
> >
> > * 整体上基于标记整理
> > * 局部(两个region之间)上基于标记复制
> >
> > ### G1缺点
> >
> > * 内存占用偏高 —— 如卡表维护复杂
> > * GC额外负载偏高 —— 如写后屏障维护卡表，写前屏障维护并发标记指针变化实现原始快照
> >
> > ************
>
> ### 低延时GC
>
> > #### 三个指标和不可能三角
> >
> > * 内存占用 - (footprint)
> > * 吞吐量 - (throughout)
> > * 延迟 - (latency)
> >
> > ***********
>
> ### ZGC收集器
>
> > #### 目标
> >
> > * 回收任意堆内存大小都能把垃圾收集的停顿时间(不是回收时间)限制在10ms以内
> >
> > #### 停顿时间与回收时间
> >
> > * 停顿时间是指回收过程中暂停用户线程stop the world的时间
> > * 回收时间是指GC的整个时间
> >
> > #### 简要概括
> >
> > * ZGC是一款基于region内存布局，(暂时)不设分代，使用读屏障、染色指针和内存多重映射等技术实现并发标记整理的，以低延迟为主要目标的垃圾收集器
> >
> > #### region的动态性
> >
> > * G1的region是固定大小的，而ZGC的region具有动态性
> >
> > * 动态体现在动态创建销毁，动态容量
> >
> > * ##### region的三种容量
> >
> >   * 小型 —— 固定2M，要求对象小于256k
> >   * 中型 —— 固定32M，要求对象小于4M
> >   * 大型 —— 容量必须是2的整倍数。只能存放一个对象(对象复制代价相对很高)，大型容量不一定比中型大
> >
> > #### 染色指针技术特点
> >
> > * 这些信息只供GC或者虚拟机本身使用，而不会被对象访问使用(如对象头某一些信息)
> > * 从与对象指针和内存本身无关的地方获取信息
> > * 如标记过程给对象打三色标记，标记信息只与对象引用有关而与对象本身无关
> > * 标记位置方案 —— 对象头，与对象无关的数据结构上，指针上
> >
> > #### 染色指针核心
> >
> > * 64位的指针根本不需要用64位，可以用其中一些位来表示信息
> > * 染色指针将本身用来表示内存的46位中的高4位用来存储四个标记信息
> > * 由于只用了本来用来内存寻址的4位，ZGC只支持4TB内存，不支持32位，只支持linux系统(目前)
> >
> > #### 四个标记
> >
> > * **marked 0** —— 与marked 1一起确定对象的三色状态
> > * **marked 1** —— 与marked 0一起确定对象的三色状态
> > * **remapped** —— 是否进入了重分配集(是否被移动过)
> > * **finalizable** —— 是否只有通过finalize()方法才能访问
> >
> > #### 优势
> >
> > * 一旦某个region的存活对象被全部移走之后，这个region就能马上被释放和重用。不必等待整个堆中所有指向该region的引用都被修正后在清理
> > * 大幅度减少垃圾收集过程中内存屏障的使用数量(因为内存屏障通常是为了记录对象引用改变，而现在这个改变是放在染色指针进行维护的。且ZGC不支持分代，就没记忆集而减少屏障使用)
> > * 可以作为一种可拓展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后提高性能
> >
> > #### 多重映射虚拟内存
> >
> > * 目的 —— 解决物理处理器不认指针上额外信息，只把指针当寻址地址的问题
> > * 多重原因 —— 不同标记的相同地址的指针值不同但却是同一个物理地址
> >
> > #### 并发标记
> >
> > * 和之前的并发标记一样，只不过标记中途的信息记录在染色体指针里
> > * 同样分为初始标记，冲突整理，重新标记
> >
> > #### 并发预备重分配
> >
> > * 根据查询条件统计出那些region组成分配集(relocation set)
> > * ZGC每次都会扫描所有region，用更大范围扫描换取记忆集维护成本
> > * 重分配集只是决定了这些集合内的存活对象会被复制到其他region中，然后将集合释放掉
> > * 回收行为针对的集合范围比分配集大，因为标记过程针对的是全堆
> >
> > #### 并发重分配
> >
> > * 此阶段是核心阶段
> > * 将重分配集中的存活对象复制到其他region，并为每个重分配集的region维护一分自己的转发表
> > * 由于有染色指针，仅仅从指针就能判断一个对象是否位于重分配集
> > * 自愈 —— 用户线程访问重分配集中的对象，触发内存屏障，根据转发表访问复制后的对象，在将原来的引用修改为新的引用
> > * 自愈优势 —— 仅仅只慢一次，后面的访问就正常不会触发内存屏障；复制完毕就能把region释放重用，只有保留转发表
> >
> > #### 并发重映射
> >
> > * 目的：修正整个堆中指向重分配集中旧对象的所有引用
> > * 进行时机：下一次并发标记时
> > * 滞后原因：修正不迫切，用户线程访问完全可以通过自愈；并发标记需要遍历所有对象，这样能节约一次遍历开销
> >
> > * 全部修正后就能释放转发表了
> >
> > #### 停顿时间与堆容量关系
> >
> > * ZGC的停顿时间只与GC Root数量有关，与堆容量大小无关
> > * 但整个回收时间还是与堆容量有关的
> >
> > #### GC速率可能赶不上分配速率
> >
> > * 产生原因： 由于没有采用分代回收，不能对需要高频大量回收的新生代做相应的回收策略改变而是整个堆一锅端一起回收，导致一次回收消耗的时间可能很长，导致浮动垃圾使堆溢出，然后导致Full GC 
> > * 解决方法一：尽可能增大堆容量，但这种方法不长久
> > * 根本解决方法：引入分代机制
> >
> > #### ZGC支持NUMA-Aware内存分配
> >
> > * NonUniform Memory Access
> > * 是一种为多核处理器或多处理器计算机设计的内存架构，是一种内存架构
> > * 由于摩尔定律失效，原来的提升性能的高频路线被迫换成多核路线
> > * 每个处理器都有一个内存控制器，都有自己能够快速访问的一部分内存，访问其他处理器内存就要通过中介速度降低
> > * ZGC为了速度会在多核心的后端上优先尝试请求当前线程处理器的本地内存上分配对象
> >
> > #### 未来定位
> >
> > * 服务端，多核心，大内存，低延迟首选
> >
> > #### 非商业性质原因
> >
> > * 不支持全平台，只支持linux
> > * 不支持类型卸载
> > * 不支持Graal编译器
> > * 上面的支持都只是时间问题
> >
> > *************

## 最终章