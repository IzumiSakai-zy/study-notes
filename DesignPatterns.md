# 设计模式-可复用的面向对象软件基础

## 前

> ### 面向对象系统质量评估
>
> * 设计者是否强调了对象之间的 **公共协调关系**
> * 强调了公共协调关系会使系统体系结构更 **精巧、简洁、便于理解**
>
> ### 本书目的
>
> * 描述了在面向对象设计过程中针对 **特定** 问题简洁而优雅的方案
> * 设计模式 **捕获** 这些方案，并用简洁的语言表达出来
>
> ### 设计模式特点
>
> * 不需要用户华丽的语言
> * 有时会多付一些功夫，但同时会大大增加软件的 **灵活性**
>
> ### 设计软件想达到的特点
>
> * 更加灵活
> * 模块化
> * 可复用
> * 易理解
>
> ### 设计模式之间关系
>
> * 23个设计模式并不是彼此单独，毫无关联的
> * 相反，他们是联系紧密的。一个设计模式往往和其他几个设计模式一起使用
>
> ### 设计模式三种分类
>
> * 创建型
> * 结构型
> * 行为型
>
> ***

## 第一章 - 引言

> ### 复用性
>
> * 设计一个面向对象系统是很难的
> * 但设计一个 **高复用性** 的面向对象系统更难
>
> ### 歌剧类比
>
> * 歌剧会沿袭大团圆式模式，浪漫主义模式，悲剧英雄模式等等
> * 而这种模式移植到软件系统设计中来就是设计模式
>
> #### 本书与设计模式关系
>
> * 将面向对象软件设计经验作为 **设计模式** 记录下来
> * 以前是有设计模式的，但是并无很好规范统一性的表述。常常是一种难以书面言出的个人式经验，此书就能很好解决这个问题
>
> ### 本书未涉及
>
> * 本书未讨论分布式和实时程序设计相关的模式
>
> ### 什么是设计模式
>
> * 每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题解决方案的核心。这样，你就能一次又一次地使用这个方案而不用做重复的劳动
> * 实际上，设计模式就是对软件开发经验的总结，归纳和规范化表述
>
> ### MVC模式
>
> * 其中View和Model是一种"订阅通知"的形式，这是一种`Observer`模式
> * MVC的一大特征是视图可以进行嵌套操作，这是一种`Composite`模式
> * View使用Controller子类的实例来实现不同的响应策略，即为了相同动作的不同响应只需要进行View的controller的替换。这种view和controller的关系叫做`strategy`模式
>
> ### 设计模式按照目的进行分类
>
> * 创造型(creational)
> * 结构性(structural)
> * 行为型(behavioral)
>
> ### 设计模式按照范围划分
>
> * 类
> * 对象
>
> ### 寻找合适的对象
>
> * 面向对象设计最困难的部分就是 **将系统拆分成对象的集合**
> * 这个拆分的过程会考虑很多很多东西
>
> ### 指定对象的接口
>
> * **型构**定义：对象操作的 **操作名、参数、返回值**
> * **接口**定义：对象操作所定义的 **所有型构** 的集合
> * **类型**定义：用来表示 **特定接口** 的一个名字，有超类型，子类型之分
> * 接口作用：对象只有通过接口才能与外界进行交流，如果不通过对象的接口就不知道对象的任何事情，也无法请求对象做任何事情
> * 动态绑定：当对象发出请求时，所引起的具体操作既与 **请求本身** 相关，又与 **接受对象** 相关。发送的请求真正的实现只有到运行时才知道
>
> ### 描述对象的实现
>
> * 抽象类：为他的字类定义公共接口
> * 混入类：给其他类提供可选择的接口和功能的类。它也不能实例化，混入类要求多继承。感觉就像序列化`Serializable`和比大小的`Comparable`
> * 对象的**类**与**类型**
>   * 对象的**类**规定了对象的具体实现
>   * 而对象的**类型**只与对象的的接口有关(前提是严格遵循接口定义，如C++的.h文件)
>
> ### 对接口编程而不是对类编程
>
> * 客户无需知道他们使用的对象的特定类型，只需要对象有客户所期望的接口就好
> * 客户无需知道他们正在使用的对象由什么类来实现，他们只需要知道定义接口的抽象类
> * 不将对象声明为某一个特定的具体类的实例对象，而是让它遵循抽象类所定义的接口
>
> ### 继承与组合
>
> * 继承又叫 **白箱复用**，因为继承后被复用的父类的细节子类是可以看到的
> * 组合又叫 **黑想复用**，因为组合之间的内部细节彼此是不知道的
> * 继承的缺点
>   * 继承关系是在编译期就确定死了的，在运行期无法改变
>   * 继承时子类是可以了解到父类的细节的，因此常常被认为是破坏了封装性
>   * 当要复用子类时，会产生依赖性问题。如果顺序继承不合适常常还要从父类起fork在写另外一个子类
> * 组合的优点
>   * 组合里面存放的是对象的引用，实际上就是接口。因此它是面向接口的，依赖就会更少
>   * 使用组合能细粒度化每个类的功能，使每个类更精炼，还能使整个类继承层次保持在较小的规模
> * 即你不应该为获得复用而去创建新的构件，而是优先使用组合技术
> * 现实情况是设计者往往过度使用了继承这种复用方式，这是不太好的
>
> ### 委托
>
> * 定义：是一种组合方法，它使组合具有与继承同样的复用能力
> * 接受请求的对象将操作委托给代理者，实际上就有点类似于子类将请求委托给父类
> * 委托优点：在运行时可以进行改变
> * 委托缺点：动态的，运行时效率比较低
> * 委托举例：Window没有与矩形相关的操作，于是在Window类有一个引用，将所有的矩形操作全部委托给外面
> * 委托是对象组合的特例，它说明了对象组合作为一个代码复用机制可以代替继承
>
> ### 参数化类型
>
> * 是除了继承和组合外的另一种复用技术
>
> ### 继承、组合、参数化类型比较
>
> * 组合提供了动态运行时改变的能力，但间接，效率比较低
> * 继承提供了操作的缺省实现，子类可以重定义这些操作
> * 参数化类型允许你改变类所用的类型，但不能在运行时改变
>
> ### 设计应支持变化
>
> * 无良好的设计会导致系统的修改异常艰难
> * 一般对象组合和参数化类型是除了继承之外的很好的复用手段
>
> ### 应用程序、工具箱、框架
>
> * 应用程序就是应用程序
> * 工具箱是一组相关的、可复用的类的集合
> * 框架是构成一类特定软件可复用设计的一组相互协作的类
> * 它们三者的难度递增，框架是最难的
> * 框架与设计模式的辨别
>   * 设计模式是比框架更抽象的存在
>   * 设计模式是比框架更小的体系结构元素
>   * 框架比设计模式更特例化
>
> ***

## 第三章 - 创建型模式

> ### 前述
>
> * 创建者模式抽象了实例化的过程
>
> ### 迷宫例子
>
> * 迷宫有多种元素构成，墙，房间，通道等等
> * 如果我们采用 **硬编码** 的模式，创建一个非常简单的迷宫需要比较复杂的代码
> * 代码量多其实并不是最致命的，最致命的是一旦你想修改这个迷宫的布局，你几乎需要全部推倒重来
>
> ### 根据迷宫初识创建型模式
>
> * 不调用**构造器**创建而是调用**虚函数**构建，通过不同的子类来实现创建不同的实例 —— **Factory Method** 
> * 通过传入**不同的参数**来创建不同类型的对象 —— **Abstract Factory**
> * 传入一个对象，这个对象可以在它自己建造的迷宫里面增删改查最后形成一个新的迷宫 —— **Builder**
> * 不同的迷宫构件有不同的原型，用不同的对象来替换这些原型来改变创建 —— **Prototype**
>
> ***

## 单一职责原则

> ### 定义
>
> * single responsibility principle —— 简称SRP
> * there should never be more than one reason for a class to change
>
> ### 用户信息举例
>
> * 用户类一般分为用户的 **属性** 和 **行为**
>
> * 我们可以把属性单独抽象出一个接口，将行为单独抽象出一个接口
>
>   ```bash
>   IUserPropertiy    IUserBehave
>        |                 |
>    UserProperty      UserBehave
>        |                 |
>        ___________________
>                  |
>                UserInfo
>   ```
>
> ### 电话举例
>
> * 日常的电话类设计其实是不太正确的
> * 因为电话分为 **行为** 和 **协议**，行为指接听和挂断两种行为，协议则是指数据进行传输的方式
> * 但一般我的都将它们合并在一起只设计一个 **IPhone**接口，不同的电话实现这个接口并没什么问题
> * 如果要真正的实现单一职责，就不得不使用 **组合复用** ，因为电话内容的传输即协议通讯是依赖于行为动作的
>
> ### 方法也能单一职责
>
> * 比如一个UserManager类，不要直接传一个User对象进去进行修改
> * 而是把每个属性的修改拆分开来，不同的属性修改调用不同的方法
>
> ### 总结单一职责原则
>
> * 这个原则理论上来说是很好的，但是实际的使用并不可能完全百分之百**SRP**
> * 它只是给我们提供一个指导意见，能拆分的职责就尽量进行拆分，不要全部写在一起。这样后期进行维护是极其不方便的
> * 但也不要为了追求满足SRP而去满足SRP，那样的话类的数量会爆炸
> * 即实际使用中要做职责的细粒度化，但也不要为了细而细
>
> ***

