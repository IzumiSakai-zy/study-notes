# 设计模式-可复用的面向对象软件基础

## 前

> ### 面向对象系统质量评估
>
> * 设计者是否强调了对象之间的 **公共协调关系**
> * 强调了公共协调关系会使系统体系结构更 **精巧、简洁、便于理解**
>
> ### 本书目的
>
> * 描述了在面向对象设计过程中针对 **特定** 问题简洁而优雅的方案
> * 设计模式 **捕获** 这些方案，并用简洁的语言表达出来
>
> ### 设计模式特点
>
> * 不需要用户华丽的语言
> * 有时会多付一些功夫，但同时会大大增加软件的 **灵活性**
>
> ### 设计软件想达到的特点
>
> * 更加灵活
> * 模块化
> * 可复用
> * 易理解
>
> ### 设计模式之间关系
>
> * 23个设计模式并不是彼此单独，毫无关联的
> * 相反，他们是联系紧密的。一个设计模式往往和其他几个设计模式一起使用
>
> ### 设计模式三种分类
>
> * 创建型
> * 结构型
> * 行为型
>
> ***

## 第一章 - 引言

> ### 复用性
>
> * 设计一个面向对象系统是很难的
> * 但设计一个 **高复用性** 的面向对象系统更难
>
> ### 歌剧类比
>
> * 歌剧会沿袭大团圆式模式，浪漫主义模式，悲剧英雄模式等等
> * 而这种模式移植到软件系统设计中来就是设计模式
>
> #### 本书与设计模式关系
>
> * 将面向对象软件设计经验作为 **设计模式** 记录下来
> * 以前是有设计模式的，但是并无很好规范统一性的表述。常常是一种难以书面言出的个人式经验，此书就能很好解决这个问题
>
> ### 本书未涉及
>
> * 本书未讨论分布式和实时程序设计相关的模式
>
> ### 什么是设计模式
>
> * 每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题解决方案的核心。这样，你就能一次又一次地使用这个方案而不用做重复的劳动
> * 实际上，设计模式就是对软件开发经验的总结，归纳和规范化表述
>
> ### MVC模式
>
> * 其中View和Model是一种"订阅通知"的形式，这是一种`Observer`模式
> * MVC的一大特征是视图可以进行嵌套操作，这是一种`Composite`模式
> * View使用Controller子类的实例来实现不同的响应策略，即为了相同动作的不同响应只需要进行View的controller的替换。这种view和controller的关系叫做`strategy`模式
>
> ### 设计模式按照目的进行分类
>
> * 创造型(creational)
> * 结构性(structural)
> * 行为型(behavioral)
>
> ### 设计模式按照范围划分
>
> * 类
> * 对象
>
> ### 寻找合适的对象
>
> * 面向对象设计最困难的部分就是 **将系统拆分成对象的集合**
> * 这个拆分的过程会考虑很多很多东西
>
> ### 指定对象的接口
>
> * **型构**定义：对象操作的 **操作名、参数、返回值**
> * **接口**定义：对象操作所定义的 **所有型构** 的集合
> * **类型**定义：用来表示 **特定接口** 的一个名字，有超类型，子类型之分
> * 接口作用：对象只有通过接口才能与外界进行交流，如果不通过对象的接口就不知道对象的任何事情，也无法请求对象做任何事情
> * 动态绑定：当对象发出请求时，所引起的具体操作既与 **请求本身** 相关，又与 **接受对象** 相关。发送的请求真正的实现只有到运行时才知道
>
> ### 描述对象的实现
>
> * 抽象类：为他的字类定义公共接口
> * 混入类：给其他类提供可选择的接口和功能的类。它也不能实例化，混入类要求多继承。感觉就像序列化`Serializable`和比大小的`Comparable`
> * 对象的**类**与**类型**
>   * 对象的**类**规定了对象的具体实现
>   * 而对象的**类型**只与对象的的接口有关(前提是严格遵循接口定义，如C++的.h文件)
>
> ### 对接口编程而不是对类编程
>
> * 客户无需知道他们使用的对象的特定类型，只需要对象有客户所期望的接口就好
> * 客户无需知道他们正在使用的对象由什么类来实现，他们只需要知道定义接口的抽象类
> * 不将对象声明为某一个特定的具体类的实例对象，而是让它遵循抽象类所定义的接口
>
> ### 继承与组合
>
> * 继承又叫 **白箱复用**，因为继承后被复用的父类的细节子类是可以看到的
> * 组合又叫 **黑想复用**，因为组合之间的内部细节彼此是不知道的
> * 继承的缺点
>   * 继承关系是在编译期就确定死了的，在运行期无法改变
>   * 继承时子类是可以了解到父类的细节的，因此常常被认为是破坏了封装性
>   * 当要复用子类时，会产生依赖性问题。如果顺序继承不合适常常还要从父类起fork在写另外一个子类
> * 组合的优点
>   * 组合里面存放的是对象的引用，实际上就是接口。因此它是面向接口的，依赖就会更少
>   * 使用组合能细粒度化每个类的功能，使每个类更精炼，还能使整个类继承层次保持在较小的规模
> * 即你不应该为获得复用而去创建新的构件，而是优先使用组合技术
> * 现实情况是设计者往往过度使用了继承这种复用方式，这是不太好的
>
> ### 委托
>
> * 定义：是一种组合方法，它使组合具有与继承同样的复用能力
> * 接受请求的对象将操作委托给代理者，实际上就有点类似于子类将请求委托给父类
> * 委托优点：在运行时可以进行改变
> * 委托缺点：动态的，运行时效率比较低
> * 委托举例：Window没有与矩形相关的操作，于是在Window类有一个引用，将所有的矩形操作全部委托给外面
> * 委托是对象组合的特例，它说明了对象组合作为一个代码复用机制可以代替继承
>
> ### 参数化类型
>
> * 是除了继承和组合外的另一种复用技术
>
> ### 继承、组合、参数化类型比较
>
> * 组合提供了动态运行时改变的能力，但间接，效率比较低
> * 继承提供了操作的缺省实现，子类可以重定义这些操作
> * 参数化类型允许你改变类所用的类型，但不能在运行时改变
>
> ### 设计应支持变化
>
> * 无良好的设计会导致系统的修改异常艰难
> * 一般对象组合和参数化类型是除了继承之外的很好的复用手段
>
> ### 应用程序、工具箱、框架
>
> * 应用程序就是应用程序
> * 工具箱是一组相关的、可复用的类的集合
> * 框架是构成一类特定软件可复用设计的一组相互协作的类
> * 它们三者的难度递增，框架是最难的
> * 框架与设计模式的辨别
>   * 设计模式是比框架更抽象的存在
>   * 设计模式是比框架更小的体系结构元素
>   * 框架比设计模式更特例化
>
> ***

## 第三章 - 创建型模式

> ### 前述
>
> * 创建者模式抽象了实例化的过程
>
> ### 迷宫例子
>
> * 迷宫有多种元素构成，墙，房间，通道等等
> * 如果我们采用 **硬编码** 的模式，创建一个非常简单的迷宫需要比较复杂的代码
> * 代码量多其实并不是最致命的，最致命的是一旦你想修改这个迷宫的布局，你几乎需要全部推倒重来
>
> ### 根据迷宫初识创建型模式
>
> * 不调用**构造器**创建而是调用**虚函数**构建，通过不同的子类来实现创建不同的实例 —— **Factory Method** 
> * 通过传入**不同的参数**来创建不同类型的对象 —— **Abstract Factory**
> * 传入一个对象，这个对象可以在它自己建造的迷宫里面增删改查最后形成一个新的迷宫 —— **Builder**
> * 不同的迷宫构件有不同的原型，用不同的对象来替换这些原型来改变创建 —— **Prototype**
>
> ***

## 单一职责原则

> ### 定义
>
> * single responsibility principle —— 简称SRP
> * there should never be more than one reason for a class to change
>
> ### 用户信息举例
>
> * 用户类一般分为用户的 **属性** 和 **行为**
>
> * 我们可以把属性单独抽象出一个接口，将行为单独抽象出一个接口
>
>   ```bash
>   IUserPropertiy    IUserBehave
>        |                 |
>    UserProperty      UserBehave
>        |                 |
>        ___________________
>                  |
>                UserInfo
>   ```
>
> ### 电话举例
>
> * 日常的电话类设计其实是不太正确的
> * 因为电话分为 **行为** 和 **协议**，行为指接听和挂断两种行为，协议则是指数据进行传输的方式
> * 但一般我的都将它们合并在一起只设计一个 **IPhone**接口，不同的电话实现这个接口并没什么问题
> * 如果要真正的实现单一职责，就不得不使用 **组合复用** ，因为电话内容的传输即协议通讯是依赖于行为动作的
>
> ### 方法也能单一职责
>
> * 比如一个UserManager类，不要直接传一个User对象进去进行修改
> * 而是把每个属性的修改拆分开来，不同的属性修改调用不同的方法
>
> ### 总结单一职责原则
>
> * 这个原则理论上来说是很好的，但是实际的使用并不可能完全百分之百**SRP**
> * 它只是给我们提供一个指导意见，能拆分的职责就尽量进行拆分，不要全部写在一起。这样后期进行维护是极其不方便的
> * 但也不要为了追求满足SRP而去满足SRP，那样的话类的数量会爆炸
> * 即实际使用中要做职责的细粒度化，但也不要为了细而细
>
> ***

## 里氏替换原则

> ### 名字
>
> * 简称`LSP`原则
>
> ### 定义
>
> * `functions that use pointers to references to base classes must be able to use objects of derivved classes without knowning it`
> * 所有引用基类的地方必须能够透明的使用子类对象
>
> ### 实际感觉
>
> * 只要父类出现的地方，子类就能出现，替换成子类不会出现任何问题
> * 最后的结果就是调用者根本不知道是在调用父类还是子类
>
> ### 子类必须完全实现父类的方法
>
> * 如果在实际的业务逻辑中，如果替换成子类会错误，则说明已经违背了`LSP原则`
> * 在实际的业务逻辑中，声明引用处尽量使用顶层接口和父类而不要使用子类
> * 如果子类不能完全实现父类的方法，则建议断开继承关系。采用 **依赖、组合、委托** 的关系代替继承
>
> ### 玩具枪失败例子
>
> * 一个`AbstractGun`接口有击杀的`shoot`方法
> * 而玩具枪有枪的特征，但是无法 **全部实现父类方法**，这里就已经违背了里氏替换原则
> * 最好的做法是重新创建一个类。通过 **委托** 的方式，将枪中除了`shoot`的逻辑交给`AbtractGun`处理
>
> ### 子类可以具有自己的个性
>
> * 向子类转型是安全的
> * 但向父类转型是不完全且禁止的
>
> ### 覆盖或实现父类的方法时输入参数可以被放大
>
> * 父类
>
>   ```kotlin
>   open class Father {
>       open fun doSomething(set:HashSet<String>):HashMap<String, Any>{
>           println("father")
>           return HashMap()
>       }
>   }
>   ```
>
> * 子类
>
>   ```kotlin
>   class Son:Father() {
>       fun doSomething(set: Set<String>): HashMap<String, Any> {
>           println("son")
>           return HashMap()
>       }
>   }
>   ```
>
> * main函数
>
>   ```kotlin
>   fun main(args: Array<String>) {
>       val son:Father = Son()
>       son.doSomething(HashSet())
>   }
>   ```
>
> * 执行结果`father`
>
> * 父类的参数类型是`HashSet`，子类参数类型是`Set`，范围更大
>
> * 实际参数类型是`HashSet`，范围更大。输出结果是`father`
>
> * 很自然这种哦调用方法是正确的，符合 **里氏原则**
>
> * 实际上这里是方法的 **重载** 而不是重写
>
> * 对比
>
>   ```kotlin
>   class Test {
>       fun doSomething(list: MutableList<String>):HashMap<String, Any>{
>           println("MutableList")
>           return HashMap()
>       }
>       fun doSomething(list: ArrayList<String>):HashMap<String, Any>{
>           println("ArrayList")
>           return HashMap()
>       }
>   }
>   //执行
>   Test().doSomething(ArrayList())
>   //输出结果
>   ArrayList
>   ```
>
> * 同一个类的两个重载，结果就是输出`ArrayList`，这符合重载调用最小粒度
>
> ### 第三点总结
>
> * 子类可以**重载**继承自父类的方法，即使重载时参数粒度变小，实际传入参数也是小粒度，这也会调用父类方法符合里氏替换原则（经实际代码测试是这样的，这也符合动态绑定规矩）
> * 因此上面这种情况是极其反人类的，不符合里氏替换原则。我们要求子类重载父类方法时参数范围必须扩大
>
> ### 覆盖或实现父类方法时输出结果可以缩小
>
> * 重载是函数名相同，函数的参数类型或者顺序不同。与返回值没有关系，返回值不作为重载区分
>
> * 重写是函数名相同，参数类型相同(不允许继承)。返回值可以是父类返回值的子类
>
> * 以下声明是合法的
>
>   ```kotlin
>   open class Father {
>       open fun doSomething(set:HashSet<String>):Map<String, Any>?{
>           println("father")
>           return HashMap()
>       }
>   }
>   
>   
>   class Son:Father() {
>       override fun doSomething(set: HashSet<String>): HashMap<String, Any>? {
>           println("son")
>           return HashMap()
>       }
>   }
>   ```
>
> * 父类的返回值是`Map`，子类重写返回值是`HashMap`。这是符合里氏替换原则的
>
> ### 总结
>
> * 满足以上原则就能很好地使用里氏替换原则
> * 就能增强程序的健壮性
> * 里氏替换原则要达到即使增加在多的子类，原始的子类和新的子类之间依然满足里氏替换原则
>
> ***

## 依赖倒置原则

> ### 定义
>
> * `High level moudules should not depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions`
> * low level就是不可分割的底层原子操作。high level 就是原子操作组装而成的复杂操作
>
> ### Java中表示
>
> * 模块间依赖通过 **抽象** 发生，实现类之间不发生直接依赖关系。
> * 接口或抽象类不依赖于实现类
> * 实现类依赖于接口或抽象类
>
> ### 一个好的设计范例
>
> ```bash
>    IDriver      ----->   ICar
>       |                    |
>     Driver              BMW   Benz
> ```
>
> * `IDriver`和`ICar`之间有依赖
> * 但具体的实现类`Driver`,`BMW`,`Benz`之间是没有依赖关系的
>
> ### 依赖的两种写法
>
> * 构造方法注入
>
> ```kotlin
> private ICar iCar
> public Driver (ICar _icar){
>   this.icar = _icar
> }
> ```
>
> * setter注入
>
> ```kotlin
> private ICar icar
> public void setICar(Icar _icar){
>   this.icar = _icar
> }
> ```
>
> ### 遵循规则
>
> * 每个类尽量都有接口和抽象类
> * 变量的静态类型尽量是接口或抽象类
> * 任何类不从具体类派生
> * 尽量不overwrite抽象类已经实现的方法
> * 结合里氏替换原则使用
>
> ### 三者功能划分
>
> * `接口`: 声明属性和方法，定义和其他接口之间的依赖关系
> * `抽象类`：公共构造部分的实现
> * `实现类`：精确实现业务逻辑
>
> ### 为什么叫倒置
>
> * 正置思想：我要用电脑就依赖电脑，我要用手机就依赖手机。这是正常人的思维
> * 倒置思想：依赖不具体，反而在抽象进行依赖
>
> ### 最后
>
> * 不要为了用依赖倒置而用依赖倒置
> * 还是要以业务为重
>
> ***

