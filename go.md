# Go Lang

## 序言

> ### 译者序
>
> * **Unix操作系统**和**C系家族语言**可以说成是整个计算机体系的根基
> * 为了解决多核网络环境下越来越复杂的编程问题而发明了go语言
> * go已渐成云计算、云服务的时代最重要的基础编程语言
>
> ### go特点
>
> * 并发编程特性很新
> * 数据抽象和面向对象编程十分灵活
> * 自动垃圾收集GC
> * 适合编写网络服务的基础设施
> * 一次编写到处运行
> * 借鉴其他语言，集大成之作
>
> ### go语言项目
>
> * go的核心精髓 —— **简洁**
> * 必须要有的特性一定有，可有可无的特性就选择无
>
> ***

## 第一章 - 入门

> ### Hello World
>
> * go语言在代码格式上采取了很强硬的态度
>
> ### 格式化
>
> * `fmt.Printf("two = %b,eight = %o,ten = %d,sixteen = %x",100,100,100,100)`
>
> ***

## 第二章 - 程序结构

> ### 命名
>
> * 小写字母开头的定义在包外是不可见的，但在包内是可见的
> * 即不论是否大小写在包内都是可见的，大小写只决定包外的可见性
>
> ### 变量
>
> * 基础格式`var 变量名 变量类型 = 变量值`
> * 如果没有类型会根据变量值自动推导
> * 即时没有变量值也会初始化零值
> * go语言不存在未初始化的变量
>
> ### 简短变量
>
> * 基础格式`变量名 := 变量值`
> * 变量类型根据变量值自动推导
> * `=`是一个赋值符号，而`:=`是一个声明符号
> * 多个简短变量联合声明必须保证左边至少有一个变量是声明
>
> ### 指针
>
> * go不像c语言，go的函数内的指针在返回后依然有效，而c则是无效
>
> ### new()函数
>
> * 返回的是一个指针
> * 用new()创建和普通的声明创建没有任何区别，只是一种语法糖
>
> ### 变量生命周期
>
> * 包级的变量生命周期和整个程序的生命周期是相同的，而局部变量则是不同情况生命周期不同
>
> * 局部变量生命周期 **只取决于是否可达**，因此生命周期可以超过作用域，如：
>
>   ```go
>   var global *int
>   func f(){
>       var x int
>       x = 1
>       global = &x
>   }
>   ```
>
> * 即x的生命周期被延伸了
>
> ### 变量分配位置问题
>
> * 栈上分配和堆上分配不取决于用`new()`还是用`var`，而且`new()`本身就是语法糖
> * go会自动判断在堆上分配还是在栈上分配
> * 即上面的x常理来看应该在栈上分配，然而实际上是在堆上进行分配
>
> ### 元组赋值
>
> * 太猛了，交换变量直接一步搞定
> * `x, y = y, x`
>
> ### 类型
>
> * 基础语法`type 类型名字 底层类型`
> * 底层类型一般为`struct`，如果不是`struct`则为类型另外取名
>
> ### 包的初始化和依赖
>
> * 导入得不好会最后搞成循环依赖
> * 包会进行初始化，且只进行一次初始化，最后初始化的是main包
> * 可以定义`func init(){}`来进行初始化
>
> ### 作用域与生命周期
>
> * 作用域是有效的文本范围，是一个编译时属性
> * 生命周期是存在的时间段，是一个运行时属性
> * `for`、`if`这种语句在判断时就有一个作用域
>
> ***

## 第三章 - 基础数据类型

> ### go语言四种类型
>
> * 基础类型
> * 符合类型
> * 引用类型
> * 接口类型
>
> ### 等价类型
>
> * `type rune int32`    `type byte uint8`   
> * 即实际底层类型是一样的

