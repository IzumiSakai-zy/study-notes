# Go Lang

## 序言

> ### 译者序
>
> * **Unix操作系统**和**C系家族语言**可以说成是整个计算机体系的根基
> * 为了解决多核网络环境下越来越复杂的编程问题而发明了go语言
> * go已渐成云计算、云服务的时代最重要的基础编程语言
>
> ### go特点
>
> * 并发编程特性很新
> * 数据抽象和面向对象编程十分灵活
> * 自动垃圾收集GC
> * 适合编写网络服务的基础设施
> * 一次编写到处运行
> * 借鉴其他语言，集大成之作
>
> ### go语言项目
>
> * go的核心精髓 —— **简洁**
> * 必须要有的特性一定有，可有可无的特性就选择无
>
> ***

## 第一章 - 入门

> ### Hello World
>
> * go语言在代码格式上采取了很强硬的态度
>
> ### 格式化
>
> * `fmt.Printf("two = %b,eight = %o,ten = %d,sixteen = %x",100,100,100,100)`
>
> ***

## 第二章 - 程序结构

> ### 命名
>
> * 小写字母开头的定义在包外是不可见的，但在包内是可见的
> * 即不论是否大小写在包内都是可见的，大小写只决定包外的可见性
>
> ### 变量
>
> * 基础格式`var 变量名 变量类型 = 变量值`
> * 如果没有类型会根据变量值自动推导
> * 即时没有变量值也会初始化零值
> * go语言不存在未初始化的变量
>
> ### 简短变量
>
> * 基础格式`变量名 := 变量值`
> * 变量类型根据变量值自动推导
> * `=`是一个赋值符号，而`:=`是一个声明符号
> * 多个简短变量联合声明必须保证左边至少有一个变量是声明
>
> ### 指针
>
> * go不像c语言，go的函数内的指针在返回后依然有效，而c则是无效
>
> ### new()函数
>
> * 返回的是一个指针
> * 用new()创建和普通的声明创建没有任何区别，只是一种语法糖
>
> ### 变量生命周期
>
> * 包级的变量生命周期和整个程序的生命周期是相同的，而局部变量则是不同情况生命周期不同
>
> * 局部变量生命周期 **只取决于是否可达**，因此生命周期可以超过作用域，如：
>
>   ```go
>   var global *int
>   func f(){
>       var x int
>       x = 1
>       global = &x
>   }
>   ```
>
> * 即x的生命周期被延伸了
>
> ### 变量分配位置问题
>
> * 栈上分配和堆上分配不取决于用`new()`还是用`var`，而且`new()`本身就是语法糖
> * go会自动判断在堆上分配还是在栈上分配
> * 即上面的x常理来看应该在栈上分配，然而实际上是在堆上进行分配
>
> ### 元组赋值
>
> * 太猛了，交换变量直接一步搞定
> * `x, y = y, x`
>
> ### 类型
>
> * 基础语法`type 类型名字 底层类型`
> * 底层类型一般为`struct`，如果不是`struct`则为类型另外取名
>
> ### 包的初始化和依赖
>
> * 导入得不好会最后搞成循环依赖
> * 包会进行初始化，且只进行一次初始化，最后初始化的是main包
> * 可以定义`func init(){}`来进行初始化
>
> ### 作用域与生命周期
>
> * 作用域是有效的文本范围，是一个编译时属性
> * 生命周期是存在的时间段，是一个运行时属性
> * `for`、`if`这种语句在判断时就有一个作用域
>
> ***

## 第三章 - 基础数据类型

> ### go语言四种类型
>
> * 基础类型
> * 符合类型
> * 引用类型
> * 接口类型
>
> ### 等价类型
>
> * `type rune int32`    `type byte uint8`   
> * 即实际底层类型是一样的
>
> ### 复数
>
> * `complex64`   `complex128` 分别对应32位和64位的 float
> * 复数声明`x := 3 + 4i`，`var x complex128 = complex(3,4)`
>
> ### 字符串
>
> * 和Java一样，go语言中的字符串是不可变的
> * 字符串是采用UTF-8进行编码的
> * `len()`函数返回的是字符串的**字节数目**而不是**rune**数目，这点要做区分。如`len("大人") = 6`
> * `s[i:j]`和Java的`substring(i,j)`一样，会重新产生一个字符串
> * 字符串支持比较，比较原则就是字符串的字典序
> * 由于字符串不变，因此某些情况下可以高效地共享底层的内存而不用重新分配，如进行字符串复制和切片的时候
>
> ### Unicode
>
> * `rune`对应的是一个`int32`类型，即Unicode每个码点都占4字节，即使是ASCII码都占4字节
>
> ### UTF-8
>
> * 一种将Unicode码点编码为字节序列的**变长**编码
> * 每个字符用`1-4`个字节来表示，在保证能表达信息的前提下使文本占据的体积尽量小
> * 中间不设置分隔符，即使用前缀编码
> * 缺点是无法通过索引直接定位到某一字符，有那么一点链表的感觉了
>
> ### iota使用
>
> * iota初始值被设置为0，用于常量的初始化操作
> * 如`B int = 1 << (iota * 10)`
>
> ### 无类型常量
>
> * 为一个常量提供了至少256位的精度，则无论在任何地方进行运算都能保证很高的精度
> * 只有常量能被声明为无类型，变量则不能
>
> ***

## 第四章 - 复合数据类型

> ### 数组
>
> * 大小固定，很少使用，除非能确定大小，否则不使用数组
> * 数组的长度必须是常量，即必须在编译器确定大小，如果不能确定，就不应该使用数组
> * 相同长度的数组可以进行大小比较
> * go语言也是和Java一样是值传递，因此传入一个数组要进行复制效率肯定比较低，因此大多数是传递数组的指针
>
> ### Slice
>
> * 可以理解成Java里面的List
> * Slice有两个重要属性
>   * cap值：代表现在底层数组的实际大小
>   * len值：代表现在实际正在使用的有多少
> * 访问范围大于cap但小于len是允许的，但大于cap是越界不允许的
> * slice是不能进行比较的
>
> ### json
>
> * 编码`json.Marshal()`
> * 解码`json.Unmarshal()`

