# 算法设计与分析

## 算法的概念

> * 概念
>   * 算法是解决问题的一种方法或一个过程，是一个由若干运算或指令组成的有穷序列
> * 特点
>   * 输入和输出
>   * 确定性
>   * 可行性
>   * 有穷性

>  * 插入排序
>    * 认为左边 **1...k** 个是有序的
>    * 用一个 **key** 来存储 **k+1** 的值
>    * k, k-1,k-2依次右移，选择适当位置插入key

******************

## 算法的正确性

> * 循环不变量
>   * 类似于数学归纳法
> * 循环不变量举例
>   * 插入排序前面 **1...k** 已经是排好序的
>   * 找最大值max已经是前面 **1...k** 里面最大的
> * 循环不变量核心
>   * 第0个
>   * 第k个
>   * 第k+1个
>   * 有穷性循环终止时第n+1个 

*****************

## 算法的效率

> * 算法时间与空间中往往更关注 **时间效率**
> * 算法计算的各种时间
>   * 最优时间
>   * 平均时间 —— 衡量时间效率
>   * **最坏时间** —— 往往关注最坏时间，是运行
> * 循环语句中外层语句执行次数会比内层语句执行次数加一
> * 算法的时间效率取决于 **n的规模**
> * 一个算法的最优，最坏，平均时间复杂度 **n的规模** 可能不同
>   * 插入排序最优时间复杂度为 n的平方
>   * 插入排序最坏时间复杂度为 n的线性
>   * 插入排序平均时间复杂大为 n的平方

> * 效率的比较
>   * n的规模低，当语句次数很大几百万时可以看出规模决定时间
>   * 计算机效率，编译器优劣等条件都不足以弥补n的规模
>
******************
## 问题的下界

> * 问题的下界
>   * 任何一种算法解决一个问题所必须的最小运行时间
> * 最优算法
>   * 设问题下界为F(n)，当算法A的最坏时间复杂度W(n)=F(n)时则可以认为算法A是这个问题最优算法
> * 排序算法的问题下界是 **(nlog2n)**

************

## 概率分析时复度

> * 概率分析
>   * 用概率的方法分析平均时间复杂度
> * 概率分析举例
>   * 线性搜索算法平均复杂度为 (n+1)/2，复杂度规模为n
>   * 插入排序算法平均时间复杂度为n的平方
> * 雇佣问题
>   * T(n)=n\*c(面试)+m\*(雇佣)。其中m指雇佣的次数，最好一次，最坏n次

****************

## 其他方法分析时复度

> * 分摊分析
>   * 估计每个的时间代价，最后乘总数
> * 累计分析
>   * 总体分析需要付出的代价
> * 记账方法
>   * 每个步骤分配一定的时间，如果未用完，就记着下面的步骤可以接着用
>
> * 举例：空栈执行n次进栈和出栈操作，其中出栈可以一次性出k个
>   * 分摊分析： 最坏可能每次都n，因此是n*n
>   * 累计分析： 只有进栈才会有机会出栈，因此总体最坏是n
>   * 记账方法：进栈代价2，出栈代价0，多次出栈代价0

***************

## 选择排序

> * 选择排序
>   * 从n个元素选出一张最小的
>   * 最小的放左边，右边是SelcectSort(n-1)
>   * T(n)=n+T(n-1)

*************

## 生成排列

> * n个元素全排列问题
>   * T(n)=n*T(n-1)

***************

## 递归方程的求解

> * 递归方程概念
>   * 类似于数列的通项公式
> * 公式法
>   * T(n)=aT(b/n)+F(n)；F(n)=D(n)+C(n)
>   * j解释：规模n的问题分解成a个规模为b/n的问题，并且加上分解和合并操作产生的复杂度
>   * 当F(n)=O(n的(logba-s)次方)时，说明aT(b/n)占主因素，则T(n)=O(n的(logba)次方)
>   * 当F(n)=O(n的(logba)次方)时，说明两者相当，则T(n)=O((n的(logba)次方)*lgn)
>   * 当F(n)=O(n的(logba-s)次方)时，说明F(n)占主因素，则T(n)=O(F(n))
> * 猜想法
>   * 已知 T(n)=f(T(n-1))
>   * 猜想假设T(n)=g(n)
>   * 则T(n)=f(g(n-1))
>   * 当存在一个n>n0，满足T(n)=f(g(n-1))<=c*g(n)时则猜想成立

****************

## 分治法

> * 分治法总体思想
>   * 将想求解的较大规模的问题分割成多个小规模的子问题，小问题继续分割成更小的问题，将求出的小规模问题的解合并成更大规模的问题的解，自底向上求出原问题的解
> * 分治法名字由来
>   * 分而治之，各个击破
> * 分治法适用条件
>   * 缩小到一定规模可以解决
>   * 具有最优子结构性质
>   * 子问题的解可以合并成原问题的解
>   * 子问题相互独立，即子问题无公共子问题
> * 分治法分割问题的一般规则
>   * 尽量分割的小问题规模大小相同，解法类似

*************

## 二分搜索

> * 天平找伪币问题
> * 二分搜索
>   * 一个有序序列，一个目标查找值
>   * 和mid值进行比较，逐渐二分

*********

##  排序

> * 冒泡排序
>   * 相邻交换，依次找到最大，次大...最小。就像泡沫一样冒出来
> * 快速排序
>   * 选一个哨兵元素
>   * 通过比较移动或交换元素，首先定下哨兵的最终位置，然后问题就被分解成了两个小问题
> * 归并排序
>   * 先两个两个排，在四个四个排……最后完成排序
>   * 算法的核心是如何将两个已经排好序的数组合并成一个数组

***********

## 覆盖残缺棋盘

> * 规则
>   * 棋盘大小为n*n，其中n是2的整数次幂
>   * 棋盘中有随机一块是残缺的
>   * 一共有(n*n-1)/3块L形格板
>   * 使用L形格板填满所有非残缺块，要求不重复不覆盖刚好填满
> * 解法
>   * 分割棋盘
>   * 假设三个完整残缺棋盘临接处残缺
>   * 三个残缺处刚好可以被一个L形格板覆盖
>   * 问题完成

***********

## 大整数乘法

> * 问题描述
>   * 两个n位数相乘
>   * 把n位数分为两个 n/2 数，变成4个数的乘法
>   * T(n)=4T(n/2)+O(n)
> * 核心
>   * 时间复杂度表达式基本都变不了
>   * 只能变 “4”
>   * 运用配方合并可以变成3个乘法
>   * 有加法有减法选择减法，因为减法能使乘数位数变少
>   * T(n)=3T(n/2)+O(n)

**************

## 矩阵乘法

> * 问题概述
>   * 两个n阶矩阵相乘
>   * 每个矩阵拆成4个n/2矩阵
>   * 最后每个四分之一矩阵是由两个矩阵乘法的和，一定是和
>   * T(n)=8T(n/2)+O(n\*n)  因为是矩阵加法，因此是O(n\*n)
> * 核心
>   * 降低子问题的个数来降低时间复杂度

*****************

## 动态规划引言

> * 引言
>   * DFS计算斐波那契数列有很多很多的重复
> * 备忘录解决方法
>   * 设置一个长度为n的数组
>   * 数组每个元素分别表示F(n)的值
>   * 当DFS计算时首先判断数组内有无值
>     * 无值情况： 计算出值后填入
>     * 有值情况： 直接取出值来用
> * 备忘录方法缺点
>   * 由于使用递归
>   * 当F(2)已知时仍然求F(2)仍然要使用函数调用
>   * 虽然不向下递归，但依然要分配空间等函数开销
> * 备忘录缺点解决方法
>   * 递归转递推 **自顶向下为递归，自底向上为递推**
>   * 使用递推的方法构造求F(n)就不用递归，无重复调用函数开销
>   * 但仍然要建立备忘录
> * 动态规划特点
>   * 通常会使用数组来保留子问题的解，用备忘录的思想

***********

## 动态规划算法思想

>* 动态规划基本步骤
>  * 找出最优解的性质并刻画其结构特征
>  * 递归地定义最优值
>  * 以 **自底向上** 方法计算出最优值
>  * 根据计算出的最优值时得到的信息构造最优解

*******

## 矩阵连乘问题

> * 概述
>   * 多个矩阵连续相乘，求乘法次数的最小值
>   * 矩阵的乘法满足结合律
>   * 不同的乘顺序与括号位置会导致最后乘法的次数不相同
> * 解决思路
>   * 使用穷举法可以解决，但会发现很多乘法次数需要重新计算
>   * 涉及多次重复计算可以考虑动态规划
>   * 设置A[1,n]表示n个矩阵连乘
>   * 所有的值空间就是一个类似倒乘法表的倒三角
>   * n个矩阵相乘可以切断分成n-1中情况
>   * 原问题的解等于子问题解的和在加上两个子问题相乘的开销
>   * 最优值一定是这n-1种情况中的一种，目的就是找出最优的这一种
>   * 涉及3个及其3个以上的矩阵乘法就继续分类讨论切分
>   * 最后会发现很多计算是重复的

************************************

## 最优二叉查找树

>* 二叉查找树概述
>  * 左子树一定都比结点小
>  * 右子树一定都比结点大
>* 解决思路
>  * 和矩阵连乘类似
>  * 分类成n种情况，最优解一定在这n种之一
>  * 子问题继续分
>  * 子问题合并成大问题的最优值
>  * 重复的只用计算一次