# 公司学习

## 工程师成长的真相

* 开头
  * 成长是自己的事情，
  * 目标是自己选的，别人的都只是参考
  * 过程需要自己努力，其他的都是资源

* 捕鼠器问题
  * 完成任务和解决问题是不同的
  * 要善于发现新的目标

* 脚踏实地
  * 要认为自己的 工作重要，因为一旦自己都认为不重要就不会有人认为其重要
  * 眼下的事情要看，但远处的事情也要考虑

* 新人基础建议
  * 努力做到最好，赢得信任
  * 要沟通
  * 向上，外，左右进行了解和学习
    * 上：看一下leader在做什么解决什么
    * 左右：了解同事在做什么，扩展知识面
    * 外：看下其他公司产品，体验，感受，找，改

* lead建议
  * 中层要开始寻找方向，明确目标并申请
  * 公司目标要对齐，不要对技术盲目崇拜，也不要过于执着于市场。
  * 技术方向和产品方向要balance

* 建设服务型团队
  * **大** 和 **高效** 是矛盾的
  * 关键点
    * 目标
    * 评价人
    * 需要的支持

  * 所处层级越低，稳定性越重要

* 公司机会
  * 公司内部机会会比外部多
  * 只要是还有缺陷的就还有机会
  * 最后一班都会平衡，很难有收益。要有一定的预期，并去发现尝试其他的事情

* 和lead不一致
  * 常常是由于沟通，最常见的原因是预期不一致
  * 沟通无效可以尝试跨级沟通

* 产品技术怎么选
  * 先了解自己。更在乎什么？更擅长什么？

***

## 工程师文化

* 六大原则
  * 质量第一
  * 承诺必达
  * 追求极致
  * 主动沟通
  * 数据说话
  * 关注产品

* 对原则总述
  * 前面两点是基本要求，是一个工程师基本应该做到的，然而还是很多人没做到
  * 中间两点是突破瓶颈
  * 最后两点是公司自己的特点和文化

* 质量第一
  * 质量不仅仅是bug的数目。质量是一种用户很综合的体验
  * 自己要对质量负责，不要期待别人发现自己问题
  * 线上服务是最最重要的
  * 质量问题检查优先度应该很高，不应该以很忙为理由推脱。一定要解决好质量问题，宁愿多花一点时间
  * 不要想当然，要对问题有敬畏之心。比如说接口定义，不要想当然一定要确认

* 承诺必达
  * 不是原封不动，可以中途调整
  * 既不要给个模棱两可的承诺，也不要过度承诺
  * 承诺有始有终，在中途设置里程碑进行汇报，及时沟通
  * 尽量不要拖，不要有拖延症
  * 你有多靠谱，你就有多少机会

* 追求极致
  * 定一个超预期的目标，才能指数级的突破
  * 极致不是完美，而是当前阶段的完美

* 主动沟通
  * 看似很易，其实是很难的
  * 邮件其实有时不是最有效的，然而可能根本没有看见
  * 沟通很重要，要高效
  * 留下文字是很好的方式
  * 沟通之前自己一定要先进行有效的思考

* 数据说话
  * 大胆假设，小心求证
  * 汇报结果时杜绝使用大概、可能、也许这种词汇
  * 每项结果尽量要可量化
  * 重视数据，但是不盲从数据
  * 不要盲目用AB
  * 数据分析能看出很多的问题，要进粒度行分析

* 关注产品
  * 技术不能脱离业务，只要在业务中才能体现技术
  * 自己要成为用户
  * 工程师不是锤PM的，而是帮助PM的

***

## 从idea到专利

* 为什么要申请
  * 字节专利是有奖金可以领的
  * 是一种荣誉奖励
  * 是研发能力的官方证明
  * 落户积分
  * 可以解决公司专利纠纷，可以收取许可金，建立技术壁垒，彰显创新实力

* 知识产权
  * 版权
  * 专利
  * 商标
  * 商业秘密

* 专利基础知识
  * 政府授予、一段时间、本国或本地区、发明创造、排他性
  * 类别：发明专利、实用新型专利(产品构造)、外观设计专利
  * 改良可以申请专利，从0到1的专利比较少，一般都是改进

* 满足条件
  * 授权主体：有一定要求，但能想到的几乎都在范围内
  * 实用性：能制造和使用，产生积极效果
  * 新颖性：和现有的有差异
  * 创造性：最难满足，有突出的特点和显著的进步

* 特点
  * 时间性
  * 空间性
  * 独占性

* 如何挖掘专利
  * 有创新点就去找专利同学
  * 新产品名称、UI、技术实现都可以进行专利申请

* 申请流程
  * 进入提案系统，按照模版进行申请
  * 申请后法务同学进行审核，然后上级审核(一般上级都给过
  * 然后就送去国家专利局审核，后面几乎没有事了

* 交底书
  * 清晰阐述专利提案要解决的技术问题
  * 能够详细介绍所提出的技术方案

* 专利权归属
  * 与职务相关的发明通通属于公司

***

## 业务安全风控和体系介绍

* 案例分析
  * 营销优惠
    * 星巴克薅羊毛：一个手机号薅一杯，然而中国一个手机号成本可能才几毛
    * 拼多多薅羊毛：凌晨100代金券，充值话费迅速到账
    * 直接经济损失，活动效果损失
  * 渠道推广费用
    * 隐蔽：用虚拟机模拟装APP进行假推广新增
  * 导流
    * 不正规的会使用抖音进行推广
  * 刷量
    * 大V进行刷赞，刷播放
    * 破坏产品整体公平性，带来错误决策

* 黑产画像
  * 产业化
  * 技术化
  * 隐蔽化

* 业务安全
  * 渠道作弊
  * 刷量业务
  * 数据安全
  * 流量作弊
  * 游戏作弊
  * 营销活动
  * 电商安全
  * 账户安全
  * 导流作弊

* 业务边界
  * 信息安全
  * 内容审核
  * 业务安全

* 业务特点-官方版本
  * 业务常耦合
  * 快速易变
  * 短板效应
  * 成本对抗

* 业务特点-民间版本
  * 幕后型业务
  * 冰山型业务

* 算法难点
  * 样本不均衡
  * 黑样本变化快
  * 场景多
  * 准召要求高

***

## 面向安全的设计原则

* 安全形式严峻
  * 各种大型数据泄漏很多，且被重大罚款
  * 国内外都有
  * 目前字节也是有一些安全信息泄漏
  * 随着字节发展越来越壮大，对黑客的吸引也是越来越大

* 成本收益博弈
  * 黑客视角：倾向于攻击成本低的公司，即安全措施不那么好的公司
  * 公司视角：产品规模与安全成本博弈，各种安全措施都是有成本的。在保证安全的前提下要去降低成本

* 安全风险
  * Spoofing: 伪装
  * Tampering：篡改
  * repudiation：否认行为
  * Information disclousure：访问无权内容
  * denial of service：拒绝访问
  * Elevation of perillege：越权

* 安全分类
  * 基础架构安全
  * 应用安全

* 面向安全的设计原则
  * 最小化受攻击面
  * 默认安全和出错安全
  * 最小化权限
  * 多层防御
  * 不信任原则
  * 职责分离
  * 不要自创安全算法
  * 敏感操作有审计日志

* 最小化攻击面
  * 攻击点常常是业务的边界，如接口
  * 简化接口设计，减少不必要接口数据传输可以最小化攻击面
  * 老接口常常容易暴露安全问题

* 默认安全和出错安全
  * 默认安全：默认是安全的，如果需要安全则用户自己开启，如mongod db甚至默认无密码
  * 出错安全：默认是不安全的，如默认使用更安全的https
  * 保证出错后还是安全的：即发生了错误，如服务请求失败，但不会造成安全事故，各种东西都是安全的

* 最小化权限
  * 只应该拥有完全工作的最小化权限

* 多层防御
  * 当某一层安全被攻破时，还有其他的层可以进行防御 
  * 如API层做了防御后，RPC层也要做，虽然会有一定的数据冗余
  * 如设置了密码后，还要开启两步验证

* 不信任原则
  * 对于未知的访问和依赖，默认都是不信任的。即默认都是黑名单

* 职责分离
  * 与最小化权限类似，系统各个模块不应该共享权限
  * 如电商系统中，订单、支付、出货三个模块要相互独立开
  * 如美国的三权分立

* 不要自创安全算法
  * 混淆不是加密

* 敏感操作有审计日志
  * 出现问题时可以快速进行定位

* 找到最薄弱一环
  * 系统的安全性

***

## AB实验之道

* 模糊定义
  * 把流量用户分为两种
  * 两组只会有一个变量
  * 线上跑一段时间
  * 观察转化率等数据指标

* 起源
  * 起源于临床医学而非是互联网

* 为什么使用
  * 相关性并不等于因果
  * 甚至一个feature可能是负向的，如果不加用户会增长得更好。如果不做AB实验可能不会发现
  * 提供了一个简单、清晰、可靠的

* 确定分组维度
  * 一般是按照用户进行分组

***

## SDLC安全培训

* SDLC
  * Software development life cycle
  * 更好、更快、更好的解决研发生命安全周期的问题 

* 需求评审
  * case必须要通过合规评审和安全技术评审
  * 合规评审：除了像button改颜色这种外一般都要进行评估
  * 安全技术评审：SDK，隐私

* case举例
  * SSRF(Server-Side Request Forgery:服务器端请求伪造)
  * RCE(remote code execution）
  * 任意文件读取和下载：无限拼路径访问到了etc等关键信息
  * TOS任意上传：上传一些黄赌毒内容进来
  * 使用正则表达式判断白名单防止绕过
  * SQL注入

* 安全测试
  * 白盒扫描：知道源代码进行扫描
  * 黑盒测试：不知道源代码进行扫描

* 漏洞管理

***

## 云原生趋势下微服务架构的机遇和挑战

* 什么是微服务架构

  * 架构都是之于服务的
  * 服务由简单到复杂可以分为：
    * 简单业务：个人大作业，全权管控
    * 复杂业务：初创公司一个小团队进行一个项目
    * 大规模、高并发业务：研发人数多，业务线多，主动迭代效率
  * 架构解决的问题：如何把服务、人联系起来，提高效率
  * 精细化分工，提高专业度；技术组织架构与服务架构相匹配
  * 微服务有一定边界，恰巧就是人的边界

* 微服务架构主要问题

  * 复杂性太大，完全交织成一个网
  * 服务变更频繁，一变更就容易有问题
  * 可观察性很差，在整个微服务系统中的调用栈无法看清
  * 每增加一点东西都会让系统更服务
  * 随着时间增加，耦合性增加，一个服务挂容易雪崩
  * 业务与基础设施耦合很重，一个服务几十个调用方，都不敢动
  * 研发体验痛苦：上下游删字段爆炸，问题排查难，请求调用链太长

* 可能的解决方案

  * 退回单体架构
    * 可以完全百分百精确掌控
    * 业务复杂度决定架构

  * 运行时单体，开发时微服务
    * 开发时按照微服务来，每个业务有明确边界
    * 运行时部署到同一台物理机上，看起来像一个大单体

  * 保持现状
    * 不迭代的业务才用这个方式没有任何毛病

* 什么是云原生

  * 提供一个`service runtime`
  * 业务与基础设施持续解耦
  * 各种基础库，开发环境，存储，扩容，SDK都不需要关心。只需要提供业务

* 云原生技术体系

  * 容器化:`docker`
  * 编排调度:`k8s`
  * 微服务治理：`service mesh`
  * 微服务监控:`OpenTracing`
  * 云原生数据库
  * 云原生网络
  * 中间件:`DAPA`

* 微服务云原生优势

  * 统一、安全的调用体系。因为都容器化了，可以统一调度
  * 完善统一的监控体系
  * 成本降低：复用技术提高物理机的利用率
  * 屏蔽底层，协和统一能力性强

* 标准化

  * 云原生与业务之间通过一个标准即接口来进行通信
  * 即得有一个统一的标准

* 挑战

  * 云原生很多不由自己控制了，自己能控制的就是业务。其他都是黑盒
  * 可观测性很难
  * 如何控制单元化
  * 非业务损耗极其大，甚至大于业务损耗
  * 架构升级难以推进

* 单体优势

  * 每个业务单独开发，开发完丢给运维
  * 运维集中一起打包，最后发布，一个大单体
  * 这样做时延可以做到很低
  * 微服务的一个缺点就是时延

* 问答

  * 复杂链路可观察性
    * 尝试分而治之，但也很难
    * 可以每个微服务前加一个虚拟网关，先把网关串起来再说

  *  合并部署
     *  开发时微服务
     *  部署时单体

  * 游戏
    * 不太推荐微服务
    * 时延是一个很重要的因素

  * 服务数爆炸
    * 不要因为增加微服务而微服务
    * 各个业务要自己评估下服务的粒度以及有无必要

  * 有状态和无状态服务
    * 即对同步性的要求，有状态同步性要求高，而无状态要求性低
    * 微服务特别适合无状态服务
    * 有状态服务建议将状态放在高速中间件而不是让业务自己持有

***

## 编写性能友好的C++代码

* 全局变量优化

  * 无法优化的代码

  ```c++
  const char *str = "Hello World;"
  char foo() {
    return str[1];//直接替换
  }
  ```

  * 无法优化原因
    * `C++`是分离式编译，在编译此文件时无法知道其他文件的行为
    * 其他文件完全有可能访问到`str`，然后`const_cast`，然后改值。编译器无法知道有无这种情况
    * `const`对编译器来说完全没有用处，因为随时可能被`const_cast<>`，const存在的意义更大是提醒程序员这是一个常量，但编译器无法保证其他没地方会改到它
  * 优化代码

  ```c++
  static const char *str = "Hello World;"
  char foo() {
    return str[1];
  }
  ```

  * 可以优化原因
    * `static`修饰全局变量时，这个全局变量只能在本文件中使用，因此限定了其他文件不可能访问此变量
    * 在这个编译单元内编译器知道没有其他地方修改这个全局变量的值，因此可以确定它在整个程序是一个定值
    * 因此可以直接进行替换优化
  * 全局打包对象，全文传递

  ```c++
  class Context {
    const char *str = "Hello World";
  }
  
  char foo(Context &c) {
    return c.str[2];
  }
  
  int main() {
    Context c;
    return foo(c); //直接替换
  }
  ```

  * 优化原理
    * `Context c`这个变量会在栈上进行分配
    * 栈变量就只有这个函数能改，其他任何函数都改不了
    * `Context`的整个构造实现在当前编译单元是可知的
    * 直接内联，替换优化掉

* `std::string`和`std::string_view`

  * 无法优化的代码

  ```c++
  static const std::string str = "Hello World;"
  char foo() {
    return str[1]; //即使是static也无法优化
  }
  ```

  * 原因
    * `std::string`的实现是维护了一个`buf`，这个`buf`实际上是在堆上的一个内容
    * 即构造时要调类似于这样的一个函数`memcpy(str.buf, "Hello World;", 12)`
    * 编译器不知道这个`memcpy`函数到底干了些啥，即`std::string`初始化还需要调用到非本单元的函数内容
    * 因此根本不可能直接就取一个字符出来优化
    * 如果`memcpy`还做了什么其他内容，程序语义就不对了
  * `std::string`
    * 这个玩意很方便很好用，但性能是真的低
    * 因为把本身`own`一块堆上的内存，即这块内存完全是它管理的。编译器很难进行优化
  * `std::string_view`
    * 这个和`const char*`很像，它本身不`own`这块内存，它只是指向这个内存
    * `std::string_view`就只能看，不能操作这个字符串
    * 它不用`内存拷贝`，性能十分高
    * 就和java的string一模一样
  * 笑话：`c++`大型项目第一件事就是重写一个`string`

* `std::vector`和`std::array`

  * `vector`不能优化，因为它支持可变，它的内容全部是运行时从堆内存去读。可以支持动态修改
  * `array`可以优化，因为它不可变，在编译器就定死了。既然定死了，编译器就可以做很多优化
  * `constexpr`，解决上面问题
  * 在那里分配内存不重要，重要的时编译期编译器能否知道信息来进行优化

* 尽量避免指针转换

  * 编译器假设两个类型不同的指针不会指向相同的内容
  * 编译器依靠这一个规则来做内存依赖分析，来进行优化
  * `int *`和`static_cast<int *>`一模一样，只是写法不同
  * 即代码尽量不要做指针类型转换
  * 编译器提供选项`-fno-strict-aliasing`来关掉`type based aliasing analysis`优化避免程序行为不正常
  * 但这个优化对编译器非常重要，对性能优化十分重要

* 慎用C++异常

  * 异常会一层层回溯调用栈，一步步执行析构函数
  * 性能开销十分大

* `auto &` 和 `auto`

  * `auto *`一定是指针，`auto`有可能推导出指针
  * 但`auto`一定不会推导出来`引用
  * 举例

  ```c++
  int &getRefrence();
  auto y = getRefrence(); //y类型推导出是`int`而不是`int &`
  ```

  * 即以为是引用不拷贝，但实际上不是引用执行拷贝，导致性能十分差
  * `auto`和`auto *`一定会执行拷贝，即使是指针也会拷贝指针地址；`auto &`才不会拷贝
  * `auto`使用
    * 指针：`auto* i;`
    * 引用：`auto& i`
    * 普通：`auto i;`

* 不要在头文件定义非`POD`数据

  * `pod`数据可以理解成`内置类型`
  * `a.h`

  ```c++
  #include<string>
  static const std::string x = "x";
  static const std::string y = "y";
  ```

  * 原因
    * `.h`文件都会被`#include`进去，即复制过去
    * 因为`std::string`构造过程中会有`call`其他编译单元，编译器无法感知其他编译单元的行为
    * 所以即使这个变量不用，编译器也不敢把它优化掉
    * 就会老老实实调用构造函数，然后构造函数里面`call memcopy`，然后创建出来，没人用
    * 如果这个`.h`文件被很多文件`#include`，这个过程还会执行多次
  * `非pod`数据
    * 就相当于内置类型，它没有构造函数，不用`call`
    * 编译器在本编译单元内完全清楚它的行为

* 端函数尽量在头文件内实现

  * 原因
    * 同一个类实现在不同的编译单元
    * 编译一个文件时根本不知道另一部分的实现干了些啥
    * 因此即使不用，根本不敢删除
  * 头文件问题
    * 由于编译单元分开，编译器无法获得足够信息，就无法进行优化
    * `inline`关键字和`const`差不多，编译器根本不管，它会自己判断
  * `inline`问题
    * `call`开销不是那么大
    * 可能导致一个函数极度膨胀，变量太多，内容太多不够分，总之容量大了问题就出来了
    * 比如寄存器不够，参数甚至会分到栈内存上
  * 极端实现
    * 定义和实现全部放在`.h`内
    * 就是为了让编译器尽可能优化

* 不要相信`const`

  * 示例

  ```c++
  void foo(const std::vector<int> &m) {
    for(auto it = m.begin, it != m.end();++it) {
      bar();//调用了一个call
      sum += *it;
    }
  }
  ```

  * 上面这个示例中不会优化成`for(auto it = m.begin, ed = m.end(), it != ed;++it)`

  * 原因
    * 因为编译器不知道`bar()`这个`call`对`m`有没有做修改
    * `const`编译器是不认的
    * 既然无法知道，编译器就不敢优化

* LTO优化`Link Time Optimization`

  * 链接时优化，发生在链接时；但优化者不是链接器，优化者是链接器调的编译器插件
  * 原理：上下文提高，增大优化的可能性
  * 做法：`.o`生成的不是汇编语言，而是`IR`，最后对`IR`做优化。等于是把真个项目编译成一个`.cpp`文件
  * 代价：问题规模很大，基于图算法优化时间很长
  * 好处：能够

* `std::move`

  * 如果某个类没有实现移动构造函数，它的成员很重量级但有移动构造函数
  * 因为你没有实现，导致这个类的成员也只能使用`拷贝构造函数`

* 程序行为不正常`print`一下就正常了

  * 因为多了一个`call`函数`print`，编译器不知道上下文
  * 不敢进行优化，就没有优化，程序行为就正常了

* `clang` vs `gcc`

  * 开源协议`clang`更友好
  * 框架比较好改，想改就改
  * `gcc`历史包袱太重

***

