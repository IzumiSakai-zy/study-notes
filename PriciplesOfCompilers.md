# 编译原理

## 1 第一次课

>### 程序执行步骤
>
>* 代码源文件编译成二进制文件 - **编译原理**
>* 操作系统分配资源成为进程 - **操作系统**
>* 进程跑在某一个特定的体系结构内 - **计算机体系与结构**
>* 最后跑出程序
>
>### 1.2 程序的编译器优化举例
>
>* 加了 **const **后说明指针str的值不会变，可以做编译器优化
>
>```c
>int atoi(const char *str)
>```
>
>* 加了 **volatile** 说明这个变量经常会变，编译器千万别对这个变量做任何优化，按部就班的算就最好
>
>  ```c
>  volatile double x; //比如嵌入式传回来温度传感器的值 
>  ```
>
>* Java 的 String 不能append，多次使用追加性能大降
>
>### 1.3 编译器原理概述
>
>* 建立人与机器的桥梁
>* 把人看懂的高级程序代码编译成机器能看懂的二进制代码
>
>> 广义编译器： 一种语言翻译成另一种语言，实际上就是翻译
>
>### 1.4 编译过程
>
>> a.c -> frontEnd -> IR(LLVM IR) -> backEnd -> nativeCode
>
>* 一个语言一个前端
>* 都向中间LLVM IR转化
>* 一个平台一个后端，如x86,ARM
>
>### 1.5 编译器前端
>
>* 预处理 - 比如展开 “#include<iostream>”
>* 词法分析器 - 拆分单词
>* 语法分析器 - 分析逻辑结构信息，如 if-else,while，得到一个语法树
>* ……
>
>### 1.6 语言
>
>* 语言是一个符号系统
>* 语言完成定义包括 **语法** 和 **语义**

*************************

## 编译器概述

>### 什么是编译器
>
>* 编译器是一个 **程序** ，把源代码翻译成目标代码
>
>>**源代码**： C++, Java, Python, HTML, C#
>>
>>**目标代码**： x86, IA64, ARM, MIPS

>### 编译特点
>
>* 语义相同，不改变源代码原意
>
>### 编译器与解释器区别
>
>* 编译器输入源代码产生的是 **可执行程序**，是一种离线 **offline**
>* 解释器输入源代码产生的是 **结果**， 是一种在线 **online**
>* 尽管有不同，但这两个相同点特别多，核心原理都一样

********************

## 编译器结构

>### 编译器的高层结构
>
>* 编译器是具有非常 **模块化** 的高层结构
>* 编译器分成前端后后端
>  * 前端： 词法分析，语法分析
>  * 后端： 指令集成， 指令优化
>* 编译器可以看成是一个流水线结构
>  * 使语言抽象程度依次降低，并不是一次性直接让高级语言编译成目标语言
>
>### 编译程序1+2+3到栈式计算机
>
>* 首先进行词法语法分析成一棵语法树
>* 然后进行后序遍历，进行语法生成
>  * 遇到数字就压栈
>  * 遇到符号就出栈两次，计算后在压栈
>
>### 编译器简要结构
>
>* 前端从输入到语法树
>* 后端从语法树到目标代码
>
>### 代码优化
>
>* 输入是语法树，输出也是语法树
>* 优化后在交给后端处理进行代码生成 

**************

## 编译器实例

> ### Sum语言到Stack计算机
>
> * 输入
>
> >整形数字：n
> >
> >加法：a+b
>
> * 输出
>
> > push n
> >
> > add
>
> ### 1+2+3编译简述
>
> * 词法分析：分析出5个字符
> * 语法分析：分析5个字符是否符合Sum的语法定义
> * 语法树构建：分析后构成一棵语法树

************

## 词法分析任务

> ### 任务
>
> * 读入 **字符流** 进行切分，输入出**记号流**
>
> ### 举例
>
> ```java
> if (x > 5)
> ```
>
> ```bash
> IF LPAREN IDENT(x) GT INT(5) RPAREN \N
> ```
>
> ### 记号集
>
> * 字符是一个集合
> * 比如说包含 
>
> > IF,  LPAREN,  IDENT,  GT,  INT,  RPAREN,  \N
>
> ### 记号的数据结构定义
>
> * 一个结构体，包含至少两个属性
>   * 属性一： 记号的类型
>   * 属性二： 记号的值
>   * ……
>
> ### 符号流和记号流
>
> * 字符流： 和被编译的语言密切相关，如ASCII，Unicode，Java，Python
> * 记号流： 编译器内部定义的数据结构，编码所识别出来的词法单元

**************

## 词法分析之手工构造法

> ### 词法分析器的两种方案
>
> * 手工生成： 相对复杂，容器出错，但是非常主流
> * 生成器生成： 可快速成型，代码量较少，但难以控制细节
>
> ### 状态图
>
> * 使用状态图来进行词法分析
>
> ### 识别关键字
>
> * 方法一： 在状态图中出分支，比如出一条单独判断 **if** 的分支
> * 方法二： 建一个关键字**哈希表**。所有输入都进行普通识别，然后在查表判断是不是关键字

****************

## 词法分析之正则表达式

> 利用正则表达式可以表示关键字，整数，字符串等
>
> ### 语法糖
>
> * 汇编语言只要有赋值和跳转两种指令就可以表示所有指令，其他指令都可以算作是语法糖

********************

## 自动机

> ### 组成部分
>
> * 字母表
> * 状态集
> * 初始状态
> * 终止状态集
> * 转移函数
>
> ### 有限状态自动机
>
> * 英文名称： DFA 确定有限自动机
> * 特点： 转移函数的值集合有且仅有一个元素
>
> ### 非确定有限状态自动机
>
> * 英文名称：NFA  非确定有限自动机
> * 特点：转移函数的值集合不一定只有一个元素
>
> ### 小结
>
> * 自动机分为DFA和NFA
> * DFA转移状态确定唯一，NFA转移状态不确定
> * NFA不好分析，一般会向DFA转化

**************

## RE -> NFA -> DFA -> 词法分析器代码

>### RE -> NFA
>
>* Thompson算法
>
>### NFA -> DFA
>
>* 子集构造算法
>
>### DFA -> 词法分析器代码
>
>* Hopcroft算法

***************

## RE -> NFA

> ### 如何转化
>
> * 使用递归算法
> * 从复杂结构递归到原子结构就是最终的NFA
>
> ### 注意
>
> * 两台自动机做与操作合并成一台自动机，一般是前面的终结状态通过空字符串跳转到后面的起始状态，不会直接省略后者自动机的起始状态直接开始连接

************

## NFA -> DFA

> ### 算法及特点
>
> * 子集构造算法
> * 是一个不动点算法，算法一定会终止
>
> ### 实现过程
>
> * 从起始状态开始，分别走a和b得到两个空字符串闭包集合状态
> * 空字符串闭包集合状态再分别走a和b得到新的或者旧的空字符闭包集合状态
> * 重复第二步，直到没有新的空字符串闭包集合状态产生为止
> * 包含NFA终止状态的集合状态就是DFA的终止状态

************

## x的空字符串闭包计算

> ### 计算方法
>
> * x本身是闭包集合的元素
> * 使用DFS或者BFS遍历空转移状态并加入集合
> * 最后得到x的空字符串闭包集

********************

## DFA最小化

> ### 算法
>
> * Hopcroft算法
>
> ### 实现过程
>
> * 首先把所有的状态切分为两个状态，接收集A和非接收集N
> * 对于任意字符，如果字符输入的结果还在本身集合内，那这个字符不能切分这个状态集合；否则切分这个状态集合为两个状态集合
> * 重复第二步直到集合不在变化为止
>
> ### 注意
>
> * 只用考虑状态的出边而不用考虑状态的入边

****************

## 语法分析

> ### 概述
>
> * 输入：记号流
> * 输出：语法树
> * 目的：判断输入是否符合某一门语言的语法规则
> * 体现：IDE控制台报错，比如无结尾分号，少括号

*************

## 上下文无关文法

> ### 组成
>
> * G=（T, N, P, S）
>
> > T：终结符
> >
> > N：非终结符
> >
> > P：产生式
> >
> > S：开始符
>
> ### 特点
>
> * 最后一定要推导到无非终结符为止
>
> ### 最左(右)推导
>
> * 概念：每次总是选择最左(右)侧的非终结符号来进行替换，不能从中间选择非终结符来推导
>
> ### 最后结果
>
> * 文法G拒绝或者接受一个记号流