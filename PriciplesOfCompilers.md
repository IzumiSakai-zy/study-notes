# 编译原理

## 1 第一次课

>### 程序执行步骤
>
>* 代码源文件编译成二进制文件 - **编译原理**
>* 操作系统分配资源成为进程 - **操作系统**
>* 进程跑在某一个特定的体系结构内 - **计算机体系与结构**
>* 最后跑出程序
>
>### 1.2 程序的编译器优化举例
>
>* 加了 **const **后说明指针str的值不会变，可以做编译器优化
>
>```c
>int atoi(const char *str)
>```
>
>* 加了 **volatile** 说明这个变量经常会变，编译器千万别对这个变量做任何优化，按部就班的算就最好
>
>  ```c
>  volatile double x; //比如嵌入式传回来温度传感器的值 
>  ```
>
>* Java 的 String 不能append，多次使用追加性能大降
>
>### 1.3 编译器原理概述
>
>* 建立人与机器的桥梁
>* 把人看懂的高级程序代码编译成机器能看懂的二进制代码
>
>> 广义编译器： 一种语言翻译成另一种语言，实际上就是翻译
>
>### 1.4 编译过程
>
>> a.c -> frontEnd -> IR(LLVM IR) -> backEnd -> nativeCode
>
>* 一个语言一个前端
>* 都向中间LLVM IR转化
>* 一个平台一个后端，如x86,ARM
>
>### 1.5 编译器前端
>
>* 预处理 - 比如展开 “#include<iostream>”
>* 词法分析器 - 拆分单词
>* 语法分析器 - 分析逻辑结构信息，如 if-else,while，得到一个语法树
>* ……
>
>### 1.6 语言
>
>* 语言是一个符号系统
>* 语言完成定义包括 **语法** 和 **语义**

*************************

## 编译器概述

>### 什么是编译器
>
>* 编译器是一个 **程序** ，把源代码翻译成目标代码
>
>>**源代码**： C++, Java, Python, HTML, C#
>>
>>**目标代码**： x86, IA64, ARM, MIPS

>### 编译特点
>
>* 语义相同，不改变源代码原意
>
>### 编译器与解释器区别
>
>* 编译器输入源代码产生的是 **可执行程序**，是一种离线 **offline**
>* 解释器输入源代码产生的是 **结果**， 是一种在线 **online**
>* 尽管有不同，但这两个相同点特别多，核心原理都一样

********************

## 编译器结构

>### 编译器的高层结构
>
>* 编译器是具有非常 **模块化** 的高层结构
>* 编译器分成前端后后端
>  * 前端： 词法分析，语法分析
>  * 后端： 指令集成， 指令优化
>* 编译器可以看成是一个流水线结构
>  * 使语言抽象程度依次降低，并不是一次性直接让高级语言编译成目标语言
>
>### 编译程序1+2+3到栈式计算机
>
>* 首先进行词法语法分析成一棵语法树
>* 然后进行后序遍历，进行语法生成
>  * 遇到数字就压栈
>  * 遇到符号就出栈两次，计算后在压栈
>
>### 编译器简要结构
>
>* 前端从输入到语法树
>* 后端从语法树到目标代码
>
>### 代码优化
>
>* 输入是语法树，输出也是语法树
>* 优化后在交给后端处理进行代码生成 

**************

## 编译器实例

> ### Sum语言到Stack计算机
>
> * 输入
>
> >整形数字：n
> >
> >加法：a+b
>
> * 输出
>
> > push n
> >
> > add
>
> ### 1+2+3编译简述
>
> * 词法分析：分析出5个字符
> * 语法分析：分析5个字符是否符合Sum的语法定义
> * 语法树构建：分析后构成一棵语法树

************

## 词法分析任务

> ### 任务
>
> * 读入 **字符流** 进行切分，输入出**记号流**
>
> ### 举例
>
> ```java
> if (x > 5)
> ```
>
> ```bash
> IF LPAREN IDENT(x) GT INT(5) RPAREN \N
> ```
>
> ### 记号集
>
> * 字符是一个集合
> * 比如说包含 
>
> > IF,  LPAREN,  IDENT,  GT,  INT,  RPAREN,  \N
>
> ### 记号的数据结构定义
>
> * 一个结构体，包含至少两个属性
>   * 属性一： 记号的类型
>   * 属性二： 记号的值
>   * ……
>
> ### 符号流和记号流
>
> * 字符流： 和被编译的语言密切相关，如ASCII，Unicode，Java，Python
> * 记号流： 编译器内部定义的数据结构，编码所识别出来的词法单元

**************

## 词法分析之手工构造法

> ### 词法分析器的两种方案
>
> * 手工生成： 相对复杂，容器出错，但是非常主流
> * 生成器生成： 可快速成型，代码量较少，但难以控制细节
>
> ### 状态图
>
> * 使用状态图来进行词法分析
>
> ### 识别关键字
>
> * 方法一： 在状态图中出分支，比如出一条单独判断 **if** 的分支
> * 方法二： 建一个关键字**哈希表**。所有输入都进行普通识别，然后在查表判断是不是关键字

****************

## 词法分析之正则表达式

> 利用正则表达式可以表示关键字，整数，字符串等
>
> ### 语法糖
>
> * 汇编语言只要有赋值和跳转两种指令就可以表示所有指令，其他指令都可以算作是语法糖

********************

## 自动机

> ### 组成部分
>
> * 字母表
> * 状态集
> * 初始状态
> * 终止状态集
> * 转移函数
>
> ### 有限状态自动机
>
> * 英文名称： DFA 确定有限自动机
> * 特点： 转移函数的值集合有且仅有一个元素
>
> ### 非确定有限状态自动机
>
> * 英文名称：NFA  非确定有限自动机
> * 特点：转移函数的值集合不一定只有一个元素
>
> ### 小结
>
> * 自动机分为DFA和NFA
> * DFA转移状态确定唯一，NFA转移状态不确定
> * NFA不好分析，一般会向DFA转化

**************

## RE -> NFA -> DFA -> 词法分析器代码

>### RE -> NFA
>
>* Thompson算法
>
>### NFA -> DFA
>
>* 子集构造算法
>
>### DFA -> 词法分析器代码
>
>* Hopcroft算法

***************

## RE -> NFA

> ### 如何转化
>
> * 使用递归算法
> * 从复杂结构递归到原子结构就是最终的NFA
>
> ### 注意
>
> * 两台自动机做与操作合并成一台自动机，一般是前面的终结状态通过空字符串跳转到后面的起始状态，不会直接省略后者自动机的起始状态直接开始连接

************

## NFA -> DFA

> ### 算法及特点
>
> * 子集构造算法
> * 是一个不动点算法，算法一定会终止
>
> ### 实现过程
>
> * 从起始状态开始，分别走a和b得到两个空字符串闭包集合状态
> * 空字符串闭包集合状态再分别走a和b得到新的或者旧的空字符闭包集合状态
> * 重复第二步，直到没有新的空字符串闭包集合状态产生为止
> * 包含NFA终止状态的集合状态就是DFA的终止状态

************

## x的空字符串闭包计算

> ### 计算方法
>
> * x本身是闭包集合的元素
> * 使用DFS或者BFS遍历空转移状态并加入集合
> * 最后得到x的空字符串闭包集

********************

## DFA最小化

> ### 算法
>
> * Hopcroft算法
>
> ### 实现过程
>
> * 首先把所有的状态切分为两个状态，接收集A和非接收集N
> * 对于任意字符，如果字符输入的结果还在本身集合内，那这个字符不能切分这个状态集合；否则切分这个状态集合为两个状态集合
> * 重复第二步直到集合不在变化为止
>
> ### 注意
>
> * 只用考虑状态的出边而不用考虑状态的入边

****************

## 语法分析

> ### 概述
>
> * 输入：记号流
> * 输出：语法树
> * 目的：判断输入是否符合某一门语言的语法规则
> * 体现：IDE控制台报错，比如无结尾分号，少括号

*************

## 上下文无关文法

> ### 组成
>
> * G=（T, N, P, S）
>
> > T：终结符
> >
> > N：非终结符
> >
> > P：产生式
> >
> > S：开始符
>
> ### 特点
>
> * 最后一定要推导到无非终结符为止
>
> ### 最左(右)推导
>
> * 概念：每次总是选择最左(右)侧的非终结符号来进行替换，不能从中间选择非终结符来推导
>
> ### 最后结果
>
> * 文法G拒绝或者接受一个记号流
>
> ### 分析树
>
> * 和推导的顺序无关
> * 树中每个内部结点代表非终结符
> * 树种叶子结点代表终结符
> * 分析树的含义取决于树的后序遍历(左右中父)顺序
>
> ### 二义性文法
>
> * 概念：一个句子有两棵或者以上的分析树
> * 解决方案：重写文法G
>
> ### 重写二义性文法
>
> * term -> factor -> atom
> * 一步一步地递归

****************

## 自顶向下分析算法

> ### 概念
>
> * 判断文法G是否接受句子s
> * 文法G从起始符号随意推导，如果推导出来就接受
> * 如果推导不出来就回溯换表达式继续推导
>
> ### 特点
>
> * 使用最左匹配规则
>
> ### 算法实现
>
> * 使用栈
> * 文法G的推导进行右侧优先压栈，如S -> ABC，压栈顺序为CBA。保证最左在栈顶
>
> ### 算法缺点
>
> * 需要回溯，时间复杂度太高
> * 编译器一般要求线性时间的算法

***************

## 递归下降分析算法

>### 算法基本思想
>
>* 预测分析
>* 每个终结符构造一个分析函数
>* 用前看符号指导产生式规则的选择

****************

## LL(1)算法

> ### 概述
>
> * 从左向右读入，最左推导，0个前看符号
> * 是一个基于表驱动的算法
>
> ### 表驱动的LL(1)架构
>
> * 由文法G生成一个分析表
> * 读入记号流使用分析栈基于分析表进行判断文法是否接受输入s
>
> ### 自顶向下算法缺陷
>
> * 它在确定选择那条产生式时根本不知道第一个字符是什么，就是盲选	
>
> ### 分析表的结构
>
> * 横轴是终结符，纵轴是非终结符
> * 相交坐标值表示从此非终结符要产生此终结符需要采用那一条产生式或者error
> * 从0开始对文法每条产生式标号
>
> ### 算法执行过程
>
> * 首先压入一个开始符S，读入第一个记号s
> * 根据分析表选择正确产生式，S出栈右逆序压入产生内容
> * 如果栈顶是终结符且与s相当，就出栈且读入下一个记号
> * 如果栈顶依然是非终结符就重复第二步

**********************

## First集

> ### 定义
>
> * First(N)表示由非终结符N能够推出所有的终结符集合
>
> ### 计算过程
>
> * 对于N -> a …
>
> > First(N) U= {a}
>
> * 对于N -> M …
>
> > First(N) U= First(M)
>
> * 一直重复第一第二步，直到没有任何集合改变为止
>
> ### 算法特点
>
> * 是一个不动点算法
>
> ### 多字符的First(ABC…)
>
> * 如果A是非终结符，First(ABC…)=First(A)
> * 如果A是终结符，First(ABC…)={A}
>
> ### LL(1)的冲突
>
> * 由非终结符N到终结符S分析表中有两条或者以上的产生式可以选择

**********

## 一般条件下LL(1)的构造

> ### 特殊情况
>
> * First(ABC)如果A, AB, ABC能推导出空串，则First(ABC)会有所改变
>
> ### NULLABLE集合
>
> * 能够最终推导出空字符串的非终结符集合 
> * 计算方法仍然是不动点算法
>
> ### 最终的First集计算方法
>
> * 和上面的类似
> * 就是增加考虑一个NULLABLE集合

***************

## Follow集合

> ### 概念
>
> * Follow(N)指能够紧跟在非终结符N之后终结符集合
>
> ### 计算方法
>
> * 根据每一条产生式，从右往左插点
> * 当存在XYZ时，Follow(Y)=First(Z)，如果Y属于NULLABLE，Follow(X)=Follow(Y) u Follow(Z)

******************

## LL(1)冲突分析处理

> ### 消除左递归
>
> * 利用空集和E`将左递归变成右递归
>
> ### 提取左公因子
>
> * 将公因子换成E`
>
> > 使用消除左递归和提取公因式可以将很大一部分有冲突的文法变成LL(1)文法

**************

## LR(0)算法

> ### LL(1)缺点
>
> * 能分析的文本类型有限
> * 往往需要改写文法
>
> ### 算法特点
>
> * 从左向右读入，最右推导，0个前看符号
> * 自底向上看是最右推导
> * 自顶向下看是从左边读入的归约
>
> ### 推导与归约
>
> * 推导：产生式从左侧到右侧
> * 归约：产生式从右侧到左侧
>
> ### 过程特点
>
> * 和递归下降对栈的操作刚好相反
> * 递归下降是把产生式的左部弹开，压入右部
> * LR(0)是把产生式的右部弹开，压入左部

***************

## 点记号

> ### 概述
>
> * 点的左边：已经读入的
> * 点的右边：剩余的输入

*************

## LR(0)算法思想

> ### DFA构建
>
> * 首先构建集合状态
> * 第一个集合状态是{S` -> .S$ , S -> .a… }，当输入为S或者a会发生状态转移，转移后如果点的右边是非终结字符，要把那个非终结字符的产生式加入进来
> * 一直重复第二步，直到构建完所有的集合状态
>
> ### 输入读入
>
> * 首先由一个栈，栈顶是1代表状态1
> * 依次读入输入，压入字符和跳转的状态序号
> * 栈变成一个状态跳转的路径
> * 如果遇到点在最右边的状态，就弹出压入进行归约。如果又构成状态跳转就压入状态序号
> * 重复上述步骤
>
> ### 状态表
>
> * 由状态自动机可以编码构成一张状态表，两者完全等架
> * 分为action表和goto表

****************

## SLR算法

> ### LR(0)的缺点
>
> * 可能过延误报错的时机，导致很久才报错
> * 会有冲突
>
> ### SLR算法思想
>
> * X -> a. 进行归约，当且仅当 y 属于 Follow(X)

***************

## LR(1)算法

> ### 算法特点
>
> * 用一个元祖表示
> * 元祖第二个属性为向前看期待的内容

*************

## 语法分析总结

> ### 手工方式
>
> * 递推下降分析
>
> ### 语法分析器生成
>
> * LL(1)
> * LR(1)

**********************

## Linux操作词法分析

> ### 太难了，略

*******************

## 语法制导翻译

> ### LR中的语法制导翻译
>
> * 在归约的时候进行，归约是关键
> * 遍历顺序是后序遍历，先遍历孩子结点算出值在遍历父亲结点
>
> ### 基本思想
>
> * 给每条产生式附加一个语义动作，一般是一条代码片段
> * 语义动作在归约的时候执行 
>
> ### 执行过程
>
> * 其实就是在之前LR算法的归约前面执行产生式的代码片段
> * 在分析栈上维护三元组<symbol, value, state>

******************

## 抽象语法树

> ### 分析树的优缺点
>
> * 分析树编码了句子的推导过程，清晰直观
> * 但有些结点占用了额外的存储空间，是不必要的
>
> ### 分析树到抽象树
>
> * 分析树含有太多的无关结点，进行省略删除浓缩可以得到抽象语法树
>
> ### 具体语法与抽闲语法
>
> * 具体语法是语法分析器使用的语法，包含去出分隔符，消除左递归，提取左公因子等等
> * 抽象语法是用来表达语法内部的结构，现代编译器前端后端的接口一般都采用抽象语法树